<!DOCTYPE html>    
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Hannah's Grammar Exercises</title>

  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #ffffff;
      background-image: url('../../../imagens/fundo.png');
      background-repeat: repeat;
      background-size: auto;
      margin: 0;
      padding: 0;
      line-height: 1.6;
    }
    .container {
      max-width: 800px;
      margin: auto;
      padding: 20px;
      position: relative;
    }
    .back-button {
      position: absolute;
      top: 20px;
      left: 20px;
      background-color: black;
      color: white;
      border: 2px solid #333;
      padding: 10px 15px;
      border-radius: 5px;
      text-decoration: none;
      font-size: 1rem;
      cursor: pointer;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
    }
    .back-button:hover {
      background-color: #444;
    }
    h1 {
      text-align: center;
      color: #333;
      font-size: 2rem;
      margin-top: 70px;
    }
    .exercise-title {
      font-weight: bold;
      font-size: 1.4rem;
      margin-top: 30px;
      margin-bottom: 10px;
    }
    .exercise-description {
      font-weight: bold;
      margin-bottom: 10px;
    }
    .exercise-line {
      margin: 10px 0;
      font-size: 1rem;
      word-break: break-word; 
      white-space: normal; 
    }
    .answer-input {
      padding: 5px;
      border: 1px solid #000; 
      border-radius: 5px;
      font-size: 1rem;
      max-width: 150px; 
      box-sizing: border-box; 
    }
    .free-text-span {
      border-bottom: 1px solid #000; 
      display: inline-block;
      width: 200px; 
      margin-left: 10px;
      vertical-align: bottom;
      min-height: 20px;
    }
    .free-text-input {
      border: none;
      outline: none;
      width: 180px; 
    }
    .correct {
      color: blue; 
    }
    .incorrect {
      color: red;  
    }
    .correct-answer-span {
      display: none; 
      font-weight: bold;
      margin-left: 10px;
      color: blue;
    }
    #check-all-btn, #generate-pdf-btn, #show-examples-btn {
      background-color: black;
      color: white;
      border: 2px solid #333;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1rem;
      box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
      margin-top: 20px;
      margin-right: 10px;
    }
    #check-all-btn:hover, #generate-pdf-btn:hover, #show-examples-btn:hover {
      background-color: #444;
    }
    .modal-overlay {
      position: fixed;
      top: 0; 
      left: 0; 
      width: 100%; 
      height: 100%;
      background: rgba(0,0,0,0.5);
      display: none; 
      justify-content: center;
      align-items: center;
      z-index: 9999;
    }
    .modal-content {
      background: white;
      padding: 20px;
      border-radius: 8px;
      width: 300px;
      text-align: center;
    }
    .close-modal-btn {
      margin-top: 10px;
      background-color: black;
      color: white;
      padding: 8px 16px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    .close-modal-btn:hover {
      background-color: #444;
    }
    table {
      border-collapse: collapse;
      margin: 10px 0;
    }
    table, th, td {
      border: 1px solid #000;
    }
    th, td {
      padding: 8px;
    }
    .choice-container {
      margin-left: 20px;
      margin-bottom: 10px;
    }
    .info-box {
      border: 1px solid #333;
      background-color: #f0f8ff;
      padding: 10px;
      border-radius: 5px;
      margin: 10px 0;
    }
    @media (max-width: 600px) {
      .container {
        padding: 10px;
      }
      h1 {
        font-size: 1.5rem;
      }
      .exercise-title {
        font-size: 1.2rem;
      }
      .back-button {
        font-size: 0.9rem;
        padding: 8px 12px;
      }
      #check-all-btn, #generate-pdf-btn, #show-examples-btn {
        width: 100%;
        margin-top: 10px;
        margin-right: 0;
      }
      .exercise-line {
        font-size: 1rem; 
        word-break: break-word;
        white-space: normal;
      }
      .free-text-span {
        width: 100px; 
      }
    }
  </style>
</head>
<body>

<div class="container">
  <a href="javascript:goBack()" class="back-button">Back</a>
  <h1>Hannah's Grammar Exercises</h1>

  <!-- Botão para exibir exemplos do primeiro item de cada exercício -->
  <button id="show-examples-btn" onclick="showExamples()">Show Examples</button>
  <div id="exercises"></div>

  <!-- Botão para checar TODAS as respostas -->
  <button id="check-all-btn" onclick="checkAllAnswers()">Check Answers</button>

  <!-- Botão para gerar PDF -->
  <button id="generate-pdf-btn" onclick="generatePDF()" style="display: none;">Generate PDF</button>
</div>

<!-- Modal -->
<div class="modal-overlay" id="completion-modal-overlay">
  <div class="modal-content" id="completion-modal-content">
    <p>Congratulations! You have completed the activity.</p>
    <button class="close-modal-btn" onclick="closeModal()">OK</button>
  </div>
</div>

<!-- Firebase -->
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

<!-- jsPDF + html2canvas (via doc.html) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<script>
  //====================================================
  // (1) Firebase Configuration
  //====================================================
  const firebaseConfig = {
    apiKey: "AIzaSyDGgo2H_hDKXF88xN7XnLFNUj8ikMY7Xdc",
    authDomain: "hannahenglishcourse.firebaseapp.com",
    projectId: "hannahenglishcourse",
    storageBucket: "hannahenglishcourse.appspot.com",
    messagingSenderId: "449818788486",
    appId: "1:449818788486:web:8a49d3f68591e6fb3f0707",
    measurementId: "G-07VVJG9LRS",
    databaseURL: "https://hannahenglishcourse-default-rtdb.asia-southeast1.firebasedatabase.app"
  };
  firebase.initializeApp(firebaseConfig);

  //====================================================
  // (2) Global Variables
  //====================================================
  let checkCount = 0;
  let userData = {};
  let linesFromFile = [];
  let questionObjects = [];
  let exercisesMapping = [];
  let currentExerciseIndex = -1;

  //====================================================
  // (3) Auth & Data
  //====================================================
  function ensureUserIsAuthenticated(callback) {
    firebase.auth().onAuthStateChanged(function (user) {
      if (user) {
        loadUserData(user.uid, () => {
          callback(user.uid);
        });
      } else {
        console.error("User is not authenticated.");
        alert("You need to be logged in to proceed.");
      }
    });
  }

  async function loadUserData(userId, callback) {
    try {
      const snapshot = await firebase.database().ref('usuarios/' + userId).once('value');
      userData = snapshot.val() || {};
      callback();
    } catch (error) {
      console.error("Error loading user data:", error);
      alert("Error loading user data.");
    }
  }

  //====================================================
  // (4) Phase Navigation
  //====================================================
  function getParamsFromURL() {
    const params = new URLSearchParams(window.location.search);
    return {
      level: params.get('level'),
      unit: params.get('unit'),
      fase: params.get('fase'),
    };
  }

  async function updateNextPhase(userId) {
    const { level, unit, fase } = getParamsFromURL();
    const dbRef = firebase.database().ref(`usuarios/${userId}/progresso/${level}/${unit}`);

    try {
      if (fase === "last") {
        const nextUnit = `Unit${parseInt(unit.replace('Unit', '')) + 1}`;
        await firebase.database().ref(`usuarios/${userId}/progresso/${level}/${nextUnit}`).set({ fase1: true });
      } else if (fase === "end") {
        const nextLevel = `Level${parseInt(level.replace('Level', '')) + 1}`;
        await firebase.database().ref(`usuarios/${userId}/progresso/${nextLevel}/Unit1`).set({ fase1: true });
      } else {
        const nextFase = parseInt(fase, 10) + 1;
        await dbRef.update({ 
          [`fase${fase}`]: true,
          [`fase${nextFase}`]: true 
        });
      }
    } catch (error) {
      console.error("Error updating the next phase:", error);
    }
  }

  function markPhaseCompleted() {
    ensureUserIsAuthenticated((userId) => {
      updateNextPhase(userId);
    });
  }

  function goBack() {
    const { level, unit, fase } = getParamsFromURL();
    ensureUserIsAuthenticated((userId) => {
      const dbRef = firebase.database().ref(`usuarios/${userId}/progresso/${level}/${unit}`);
      dbRef.get().then((snapshot) => {
        if (snapshot.exists()) {
          const progress = snapshot.val();
          const nextFaseKey = `fase${parseInt(fase, 10) + 1}`;
          if (progress[nextFaseKey]) {
            window.history.back();
          } else {
            const confirmNavigation = confirm("The next phase is locked. Do you still want to go back?");
            if (confirmNavigation) {
              window.history.back();
            }
          }
        } else {
          alert("Progress could not be verified. Please try again later.");
        }
      }).catch((error) => {
        console.error("Error checking progress:", error);
        alert("An error occurred while verifying progress. Please try again.");
      });
    });
  }

  //====================================================
  // (5) Alarm
  //====================================================
  function playAlarm() {
    const audio = new Audio('alarme.mp3');
    audio.play();
    setTimeout(() => {
      audio.pause();
      audio.currentTime = 0;
    }, 4000);
  }

  //====================================================
  // (6) Check Answers
  //====================================================
  function checkAllAnswers() {
    checkCount++;
    let allCorrect = true;
    let wrongItems = [];

    questionObjects.forEach(qObj => {
      //-------------- TEXT INPUT --------------
      if (qObj.qtype === 'textInput') {
        const userAnswer = qObj.userInputDOM.value.trim().toLowerCase();
        const correct = qObj.correctAnswer.trim().toLowerCase();
        if (userAnswer === correct) {
          qObj.userInputDOM.classList.remove('incorrect');
          qObj.userInputDOM.classList.add('correct');
          qObj.correctSpanDOM.style.display = 'none';
        } else {
          allCorrect = false;
          wrongItems.push(qObj.userInputDOM);
          qObj.userInputDOM.classList.remove('correct');
          qObj.userInputDOM.classList.add('incorrect');
        }
      }
      //-------------- MULTIPLE CHOICE --------------
      else if (qObj.qtype === 'multipleChoice') {
        const radios = qObj.containerDOM.querySelectorAll('input[type="radio"]');
        let userChoice = null;
        radios.forEach(r => {
          if (r.checked) userChoice = r.value.trim().toUpperCase();
        });
        if (!userChoice || userChoice !== qObj.correctAnswer.toUpperCase()) {
          allCorrect = false;
          wrongItems.push(qObj.containerDOM);
          qObj.containerDOM.style.color = 'red';
        } else {
          qObj.containerDOM.style.color = 'blue';
        }
      }
      //-------------- TRUE/FALSE --------------
      else if (qObj.qtype === 'trueFalse') {
        const radios = qObj.containerDOM.querySelectorAll('input[type="radio"]');
        let userChoice = null;
        radios.forEach(r => {
          if (r.checked) userChoice = r.value.trim().toUpperCase();
        });
        if (!userChoice || userChoice !== qObj.correctAnswer.toUpperCase()) {
          allCorrect = false;
          wrongItems.push(qObj.containerDOM);
          qObj.containerDOM.style.color = 'red';
        } else {
          qObj.containerDOM.style.color = 'blue';
        }
      }
      //-------------- MATCHING --------------
      else if (qObj.qtype === 'matching') {
        let mismatch = false;
        qObj.pairs.forEach(pair => {
          const typed = pair.inputDOM.value.trim().toLowerCase();
          const corr = pair.correctValue.trim().toLowerCase();
          if (typed !== corr) {
            mismatch = true;
            wrongItems.push(pair.inputDOM);
            pair.inputDOM.classList.remove('correct');
            pair.inputDOM.classList.add('incorrect');
          } else {
            pair.inputDOM.classList.remove('incorrect');
            pair.inputDOM.classList.add('correct');
          }
        });
        if (mismatch) allCorrect = false;
      }
      //-------------- ORDERING --------------
      else if (qObj.qtype === 'ordering') {
        let containerDOM = qObj.containerDOM;
        let inputs = containerDOM.querySelectorAll('input.answer-input');
        let anyWrong = false;
        for (let i = 0; i < qObj.items.length; i++) {
          const correctPos = qObj.correctPositions[i]; 
          let userVal = parseInt(inputs[i].value.trim(), 10);
          if (isNaN(userVal) || userVal !== correctPos) {
            anyWrong = true;
            inputs[i].classList.remove('correct');
            inputs[i].classList.add('incorrect');

            let correctSpan = inputs[i].parentNode.querySelector('.correct-answer-span');
            if (checkCount >= 3 && correctSpan) {
              correctSpan.textContent = `Right position: ${correctPos}`;
              correctSpan.style.display = 'inline';
            }
          } else {
            inputs[i].classList.remove('incorrect');
            inputs[i].classList.add('correct');
            let correctSpan = inputs[i].parentNode.querySelector('.correct-answer-span');
            if (correctSpan) correctSpan.style.display = 'none';
          }
        }
        if (anyWrong) allCorrect = false;
      }
    });

    // toco alarme se houver erro e se for aluno atrelado a professor
    if (!allCorrect) {
      if (userData.role === 'aluno' && userData.atrelado_professor && userData.atrelado_professor.trim() !== '') {
        playAlarm();
      }
      if (wrongItems.length > 0 && wrongItems[0].scrollIntoView) {
        wrongItems[0].scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }

    // terceira tentativa: mostro respostas
    if (checkCount === 3) {
      questionObjects.forEach(qObj => {
        if (qObj.qtype === 'textInput') {
          const typed = qObj.userInputDOM.value.trim().toLowerCase();
          const correct = qObj.correctAnswer.trim().toLowerCase();
          if (typed !== correct) {
            qObj.correctSpanDOM.textContent = `Right answer: ${qObj.correctAnswer}`;
            qObj.correctSpanDOM.style.display = 'inline';
          }
        }
        else if (qObj.qtype === 'multipleChoice') {
          const radios = qObj.containerDOM.querySelectorAll('input[type="radio"]');
          let userChoice = null;
          radios.forEach(r => {
            if (r.checked) userChoice = r.value.trim().toUpperCase();
          });
          if (!userChoice || userChoice !== qObj.correctAnswer.toUpperCase()) {
            qObj.containerDOM.insertAdjacentHTML(
              'beforeend',
              `<div class="exercise-line" style="color:blue; font-weight:bold;">Right answer: ${qObj.correctAnswer}</div>`
            );
          }
        }
        else if (qObj.qtype === 'trueFalse') {
          const radios = qObj.containerDOM.querySelectorAll('input[type="radio"]');
          let userChoice = null;
          radios.forEach(r => {
            if (r.checked) userChoice = r.value.trim().toUpperCase();
          });
          if (!userChoice || userChoice !== qObj.correctAnswer.toUpperCase()) {
            qObj.containerDOM.insertAdjacentHTML(
              'beforeend',
              `<div class="exercise-line" style="color:blue; font-weight:bold;">Right answer: ${qObj.correctAnswer}</div>`
            );
          }
        }
        else if (qObj.qtype === 'matching') {
          qObj.pairs.forEach(pair => {
            const typed = pair.inputDOM.value.trim().toLowerCase();
            const corr = pair.correctValue.trim().toLowerCase();
            if (typed !== corr) {
              pair.correctSpanDOM.textContent = `Right answer: ${pair.correctValue}`;
              pair.correctSpanDOM.style.display = 'inline';
            }
          });
        }
        else if (qObj.qtype === 'ordering') {
          let containerDOM = qObj.containerDOM;
          let inputs = containerDOM.querySelectorAll('input.answer-input');
          for (let i = 0; i < qObj.items.length; i++) {
            const correctPos = qObj.correctPositions[i];
            const userVal = parseInt(inputs[i].value.trim(), 10);
            if (userVal !== correctPos) {
              const span = inputs[i].parentNode.querySelector('.correct-answer-span');
              if (span) {
                span.textContent = `Right position: ${correctPos}`;
                span.style.display = 'inline';
              }
            }
          }
        }
      });
      markPhaseCompleted();
      showModal();
    } else {
      // se não é terceira tentativa e está tudo certo => concluído
      if (allCorrect) {
        markPhaseCompleted();
        showModal();
      }
    }
  }

  function showModal() {
    const overlay = document.getElementById('completion-modal-overlay');
    overlay.style.display = 'flex';
  }
  function closeModal() {
    const overlay = document.getElementById('completion-modal-overlay');
    overlay.style.display = 'none';
  }

  //====================================================
  // (7) Parse .txt lines
  //====================================================
  function parseFileLines(lines) {
    let htmlAccum = '';  
    let i = 0;
    function nextLine() { i++; }

    while (i < lines.length) {
      let raw = lines[i];
      let line = raw.trim();
      if (!line) { nextLine(); continue; }

      // #TITLE
      if (line.toUpperCase().startsWith('#TITLE:')) {
        let titleText = line.substring(7).trim();
        htmlAccum += `<h2 class="exercise-title">${titleText}</h2>`;
        nextLine();
        continue;
      }

      // Exercise X:
      if (/^Exercise\s+\d+:/i.test(line)) {
        currentExerciseIndex++;
        exercisesMapping[currentExerciseIndex] = { questions: [] };
        htmlAccum += `<div class="exercise-description">${line}</div>`;
        nextLine();
        continue;
      }

      // #IMG:
      if (line.toUpperCase().startsWith('#IMG:')) {
        let file = line.substring(5).trim();
        // Se estiver em outro domínio, precisa de crossOrigin
        htmlAccum += `<div class="exercise-line"><img data-imgfile="${file}" style="max-width:100%; height:auto;" alt="Image" crossorigin="anonymous"></div>`;
        nextLine();
        continue;
      }

      // #TABLE
      if (line.toUpperCase().startsWith('#TABLE')) {
        let tableLines = [];
        nextLine();
        while (i < lines.length) {
          let check = lines[i].trim().toUpperCase();
          if (check.startsWith('#ENDTABLE')) { nextLine(); break; }
          tableLines.push(lines[i]);
          nextLine();
        }
        htmlAccum += `<table>`;
        tableLines.forEach(row => {
          if (!row) return;
          let cells = row.split('|').map(x=>x.trim());
          htmlAccum += `<tr>`;
          cells.forEach(td => {
            htmlAccum += `<td>${td}</td>`;
          });
          htmlAccum += `</tr>`;
        });
        htmlAccum += `</table>`;
        continue;
      }

      // #BOX
      if (line.toUpperCase().startsWith('#BOX')) {
        let boxLines = [];
        nextLine();
        while (i < lines.length) {
          let c = lines[i].trim().toUpperCase();
          if (c.startsWith('#ENDBOX')) { nextLine(); break; }
          boxLines.push(lines[i]);
          nextLine();
        }
        let boxHTML = `<div class="info-box">`;
        boxLines.forEach(bl => {
          boxHTML += bl + "<br>";
        });
        boxHTML += `</div>`;
        htmlAccum += boxHTML;
        continue;
      }

      // #MULTIPLE_CHOICE
      if (line.toUpperCase().startsWith('#MULTIPLE_CHOICE:')) {
        let questionText = line.substring(17).trim();
        let questionIndex = questionObjects.length;
        let options = [];
        let corrLetter = null;
        nextLine();
        while (i < lines.length) {
          let check = lines[i].trim();
          if (check.toUpperCase().startsWith('#END_MULTIPLE_CHOICE')) {
            nextLine();
            break;
          }
          if (check.toUpperCase().startsWith('#CORRECT:')) {
            corrLetter = check.substring(9).trim();
            nextLine();
          } else {
            options.push(lines[i]);
            nextLine();
          }
        }
        let containerID = `multichoice_container_${questionIndex}`;
        htmlAccum += `<div class="exercise-line"><strong>${questionText}</strong></div>`;
        htmlAccum += `<div class="choice-container" id="${containerID}"></div>`;
        questionObjects.push({
          qtype: 'multipleChoice',
          index: questionIndex,
          questionText,
          correctAnswer: (corrLetter||'').toUpperCase(),
          options, 
          containerDOM: null
        });
        if (currentExerciseIndex >= 0 && exercisesMapping[currentExerciseIndex]) {
          exercisesMapping[currentExerciseIndex].questions.push(questionIndex);
        }
        continue;
      }

      // #TRUE_FALSE
      if (line.toUpperCase().startsWith('#TRUE_FALSE:')) {
        let statement = line.substring(11).trim();
        let questionIndex = questionObjects.length;
        let correctVal = 'V';
        nextLine();
        while (i < lines.length) {
          let check = lines[i].trim().toUpperCase();
          if (check.startsWith('#END_TRUE_FALSE')) {
            nextLine();
            break;
          }
          if (check.startsWith('#CORRECT:')) {
            correctVal = lines[i].substring(9).trim();
            nextLine();
          } else {
            nextLine();
          }
        }
        let containerID = `truefalse_container_${questionIndex}`;
        htmlAccum += `<div class="exercise-line"><strong>${statement}</strong></div>`;
        htmlAccum += `<div class="choice-container" id="${containerID}"></div>`;
        questionObjects.push({
          qtype: 'trueFalse',
          index: questionIndex,
          statement,
          correctAnswer: correctVal,
          containerDOM: null
        });
        if (currentExerciseIndex >= 0 && exercisesMapping[currentExerciseIndex]) {
          exercisesMapping[currentExerciseIndex].questions.push(questionIndex);
        }
        continue;
      }

      // #MATCHING
      if (line.toUpperCase().startsWith('#MATCHING:')) {
        let questionIndex = questionObjects.length;
        let pairs = [];
        nextLine();
        while (i < lines.length) {
          let check = lines[i].trim().toUpperCase();
          if (check.startsWith('#END_MATCHING')) { nextLine(); break; }
          if (!lines[i].trim()) { nextLine(); continue; }
          if (lines[i].includes('=')) {
            let [left, right] = lines[i].split('=');
            pairs.push({
              leftValue: (left||'').trim(),
              correctValue: (right||'').trim()
            });
          }
          nextLine();
        }
        let containerID = `matching_container_${questionIndex}`;
        htmlAccum += `<div class="exercise-line"><strong>Match the columns</strong></div>`;
        htmlAccum += `<div class="choice-container" id="${containerID}"></div>`;
        questionObjects.push({
          qtype: 'matching',
          index: questionIndex,
          pairs, 
          containerDOM: null
        });
        if (currentExerciseIndex >= 0 && exercisesMapping[currentExerciseIndex]) {
          exercisesMapping[currentExerciseIndex].questions.push(questionIndex);
        }
        continue;
      }

      // #ORDERING
      if (line.toUpperCase().startsWith('#ORDERING:')) {
        let questionIndex = questionObjects.length;
        let items = [];
        let correctPositions = [];
        nextLine();
        while (i < lines.length) {
          let check = lines[i].trim();
          if (check.toUpperCase().startsWith('#END_ORDERING')) {
            nextLine();
            break;
          }
          if (check.toUpperCase().startsWith('#CORRECT_ORDER:')) {
            let seq = check.substring(14).trim();
            correctPositions = seq.split(',').map(x => {
              let cleaned = x.replace(/[^\d]/g, '').trim(); 
              let num = parseInt(cleaned, 10);
              if (isNaN(num) || num <= 0) return -1;
              return num;
            });
            nextLine();
          } else {
            if (check) items.push(check);
            nextLine();
          }
        }
        let containerID = `ordering_container_${questionIndex}`;
        htmlAccum += `<div class="exercise-line"><strong>Use numbers to arrange in correct order.</strong></div>`;
        htmlAccum += `<div class="choice-container" id="${containerID}"></div>`;
        questionObjects.push({
          qtype: 'ordering',
          index: questionIndex,
          items,
          correctPositions,
          containerDOM: null
        });
        if (currentExerciseIndex >= 0 && exercisesMapping[currentExerciseIndex]) {
          exercisesMapping[currentExerciseIndex].questions.push(questionIndex);
        }
        continue;
      }

      // [Answer: ] + [FreeText]
      if (line.includes('[Answer:') && line.includes('[FreeText]')) {
        let [qPart, aPart] = line.split('[Answer:');
        let correctVal = aPart.split(']')[0].trim();
        let inputSize = '150px';
        let useTextarea = false;

        let sizeMatch = qPart.match(/\[size:(.*?)\]/);
        if (sizeMatch) {
          let sizeVal = sizeMatch[1].trim().toLowerCase();
          if (sizeVal === 'small') inputSize = '30px';
          if (sizeVal === 'medium') inputSize = '150px';
          if (sizeVal === 'large') inputSize = '300px';
          if (sizeVal === 'huge') inputSize = '800px';
          if (sizeVal === 'essay') useTextarea = true;
        }
        let cleanedQ = qPart.replace(/\[size:.*?\]/,'').trim();
        let placeholderIndex = questionObjects.length;

        // input de resposta
        htmlAccum += `<div class="exercise-line" data-question-idx="${placeholderIndex}" data-qtype="textInputWithFreeText">`;
        if (!useTextarea) {
          cleanedQ = cleanedQ.replace('___', `<input type="text" class="answer-input" style="width:${inputSize};" />`);
        } else {
          cleanedQ = cleanedQ.replace('___', `<textarea rows="4" class="answer-input" style="width:100%;"></textarea>`);
        }
        htmlAccum += `${cleanedQ}<span class="correct-answer-span"></span></div>`;

        // input free text
        htmlAccum += `<div class="exercise-line"><span class="free-text-span"><input type="text" class="free-text-input" /></span></div>`;

        questionObjects.push({
          qtype: 'textInput',
          correctAnswer: correctVal,
          userInputDOM: null,
          correctSpanDOM: null
        });
        if (currentExerciseIndex >= 0 && exercisesMapping[currentExerciseIndex]) {
          exercisesMapping[currentExerciseIndex].questions.push(questionObjects.length - 1);
        }
        nextLine();
        continue;
      }

      // Somente [FreeText]
      if (line.includes('[FreeText]') && !line.includes('[Answer:')) {
        let stripped = line.replace('[FreeText]','').trim();
        htmlAccum += `<div class="exercise-line">${stripped} <span class="free-text-span"><input type="text" class="free-text-input" /></span></div>`;
        nextLine();
        continue;
      }

      // Somente [Answer:]
      if (line.includes('[Answer:') && !line.includes('[FreeText]')) {
        let [qPart, aPart] = line.split('[Answer:');
        let correctVal = aPart.replace(']','').trim();
        let inputSize = '150px';
        let useTextarea = false;
        let sizeM = qPart.match(/\[size:(.*?)\]/);
        if (sizeM) {
          let sVal = sizeM[1].trim().toLowerCase();
          if (sVal === 'small') inputSize = '30px';
          if (sVal === 'medium') inputSize = '150px';
          if (sVal === 'large') inputSize = '300px';
          if (sVal === 'huge') inputSize = '800px';
          if (sVal === 'essay') useTextarea = true;
        }
        let cQ = qPart.replace(/\[size:.*?\]/,'').trim();
        let placeIndex = questionObjects.length;
        htmlAccum += `<div class="exercise-line" data-question-idx="${placeIndex}" data-qtype="textInputOnly">`;
        if (!useTextarea) {
          cQ = cQ.replace('___', `<input type="text" class="answer-input" style="width:${inputSize};" />`);
        } else {
          cQ = cQ.replace('___', `<textarea rows="4" class="answer-input" style="width:100%;"></textarea>`);
        }
        htmlAccum += `${cQ}<span class="correct-answer-span"></span></div>`;

        questionObjects.push({
          qtype: 'textInput',
          correctAnswer: correctVal,
          userInputDOM: null,
          correctSpanDOM: null
        });
        if (currentExerciseIndex >= 0 && exercisesMapping[currentExerciseIndex]) {
          exercisesMapping[currentExerciseIndex].questions.push(questionObjects.length - 1);
        }
        nextLine();
        continue;
      }

      // Se não bateu em nada, é texto normal
      htmlAccum += `<div class="exercise-line">${line}</div>`;
      nextLine();
    }

    return htmlAccum;
  }

  //====================================================
  // (8) Render 
  //====================================================
  function renderQuestions(container) {
    questionObjects.forEach((qObj) => {
      if (qObj.qtype === 'multipleChoice') {
        let cID = `multichoice_container_${qObj.index}`;
        let containerDOM = container.querySelector(`#${cID}`);
        if (containerDOM) {
          qObj.options.forEach(optLine => {
            let trimmedOpt = optLine.trim();
            let letterMatch = trimmedOpt.match(/^([A-Z])\)\s*/i);
            let rValue = trimmedOpt;
            if (letterMatch) rValue = letterMatch[1].toUpperCase();
            let divOption = document.createElement('div');
            divOption.innerHTML = `
              <label>
                <input type="radio" name="mcq_group_${qObj.index}" value="${rValue}">
                ${trimmedOpt}
              </label>
            `;
            containerDOM.appendChild(divOption);
          });
        }
        qObj.containerDOM = containerDOM;
      }
      else if (qObj.qtype === 'trueFalse') {
        let cID = `truefalse_container_${qObj.index}`;
        let containerDOM = container.querySelector(`#${cID}`);
        if (containerDOM) {
          containerDOM.innerHTML = `
            <label><input type="radio" name="tf_group_${qObj.index}" value="V">True</label>
            <label style="margin-left:20px;"><input type="radio" name="tf_group_${qObj.index}" value="F">False</label>
          `;
        }
        qObj.containerDOM = containerDOM;
      }
      else if (qObj.qtype === 'matching') {
        let cID = `matching_container_${qObj.index}`;
        let containerDOM = container.querySelector(`#${cID}`);
        if (containerDOM) {
          qObj.pairs.forEach((p) => {
            let lineDiv = document.createElement('div');
            lineDiv.classList.add('exercise-line');
            lineDiv.innerHTML = `
              <strong>${p.leftValue}</strong> =
              <input type="text" class="answer-input" style="width:150px;" />
              <span class="correct-answer-span"></span>
            `;
            containerDOM.appendChild(lineDiv);
          });
        }
        qObj.containerDOM = containerDOM;
      }
      else if (qObj.qtype === 'ordering') {
        let cID = `ordering_container_${qObj.index}`;
        let containerDOM = container.querySelector(`#${cID}`);
        if (containerDOM) {
          qObj.items.forEach((txt) => {
            let divLine = document.createElement('div');
            divLine.classList.add('exercise-line');
            divLine.innerHTML = `
              <strong>${txt}</strong>
              <input type="text" class="answer-input" style="width:50px; margin-left:10px;" placeholder="Pos"/>
              <span class="correct-answer-span"></span>
            `;
            containerDOM.appendChild(divLine);
          });
        }
        qObj.containerDOM = containerDOM;
      }
    });

    let textLines = container.querySelectorAll('[data-qtype]');
    textLines.forEach(tLine => {
      let qIdx = parseInt(tLine.getAttribute('data-question-idx'),10);
      let questObj = questionObjects[qIdx];
      let inputEl = tLine.querySelector('.answer-input');
      let spanEl = tLine.querySelector('.correct-answer-span');
      if (questObj && questObj.qtype === 'textInput') {
        questObj.userInputDOM = inputEl;
        questObj.correctSpanDOM = spanEl;
      }
    });

    // matching
    questionObjects.forEach((qObj) => {
      if (qObj.qtype === 'matching') {
        let cDOM = qObj.containerDOM;
        let lineDivs = cDOM ? cDOM.querySelectorAll('.exercise-line') : [];
        qObj.pairs.forEach((pair, pIdx) => {
          let input = lineDivs[pIdx].querySelector('.answer-input');
          let cSpan = lineDivs[pIdx].querySelector('.correct-answer-span');
          pair.inputDOM = input;
          pair.correctSpanDOM = cSpan;
        });
      }
    });
  }

  //====================================================
  // (9) Load .txt & Build
  //====================================================
  async function loadContent() {
    const { level, unit } = getParamsFromURL();
    if (!level || !unit) {
      console.error("Missing 'level' or 'unit' in URL.");
      document.getElementById('exercises').textContent = "Content could not be loaded.";
      return;
    }

    const basePath = `../../../../${level}/${unit}/DataExerciciosdaGramatica/`;
    try {
      const response = await fetch(`${basePath}exercicios.txt`);
      if (!response.ok) throw new Error(`Error loading file: ${basePath}exercicios.txt`);

      const data = await response.text();
      linesFromFile = data.split('\n');

      let container = document.getElementById('exercises');
      let rawHTML = parseFileLines(linesFromFile);
      container.innerHTML = rawHTML;

      // Render
      renderQuestions(container);

      // Carrega imagens (se existirem)
      let allImgTags = container.querySelectorAll('img[data-imgfile]');
      allImgTags.forEach(imgTag => {
        let fname = imgTag.getAttribute('data-imgfile');
        imgTag.src = basePath + fname;
      });

    } catch (error) {
      console.error("Error loading exercises:", error);
      document.getElementById('exercises').textContent = "Exercises could not be loaded.";
    }
  }

  //====================================================
  // (10) Geração de PDF com layout 
  //====================================================
  async function generatePDF() {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF('p', 'pt', 'a4');

    // 1) Clonar a div.container sem as respostas
    let containerOriginal = document.querySelector('.container');
    let containerClone = containerOriginal.cloneNode(true);

    // remover botões do clone
    let checkAllBtn = containerClone.querySelector('#check-all-btn');
    if (checkAllBtn) checkAllBtn.remove();
    let showExamplesBtn = containerClone.querySelector('#show-examples-btn');
    if (showExamplesBtn) showExamplesBtn.remove();
    let generatePdfBtn = containerClone.querySelector('#generate-pdf-btn');
    if (generatePdfBtn) generatePdfBtn.remove();
    let backButton = containerClone.querySelector('.back-button');
    if (backButton) backButton.remove();

    // Limpar inputs .answer-input
    let allAnswerInputs = containerClone.querySelectorAll('.answer-input');
    allAnswerInputs.forEach(input => {
      if (input.tagName.toLowerCase() === 'textarea') {
        input.value = "";
        input.textContent = "___________";
      } else {
        input.value = "";
        input.setAttribute('placeholder', '___________');
      }
      // tira classes de cor (correct/incorrect)
      input.classList.remove('correct', 'incorrect');
    });

    // Limpar inputs .free-text-input
    let allFreeText = containerClone.querySelectorAll('.free-text-input');
    allFreeText.forEach(f => {
      f.value = "";
      f.setAttribute('placeholder', '____________');
    });

    // esconder spans de resposta
    let correctSpans = containerClone.querySelectorAll('.correct-answer-span');
    correctSpans.forEach(span => {
      span.style.display = 'none';
    });

    // 2) Converter em PDF via doc.html
    // Ajustar dimensões e permitir crossOrigin para imagens
    doc.html(containerClone, {
      x: 20,
      y: 20,
      width: 560,               // ajusta largura para caber
      windowWidth: 800,         // simula largura de render
      autoPaging: 'text',       // autoquebra
      html2canvas: {
        scale: 0.9,             // diminuir se estiver cortando a direita
        useCORS: true           // permitir imagens se estiverem no mesmo domínio
      },
      callback: function (doc) {
        doc.save("Hannah_Grammar_Exercises.pdf");
      }
    });
  }

  //====================================================
  // (11) Show Examples
  //====================================================
  function showExamples() {
    exercisesMapping.forEach(exObj => {
      if (exObj.questions.length > 0) {
        let firstQIndex = exObj.questions[0];
        let qObj = questionObjects[firstQIndex];
        revealFirstItemAnswer(qObj);
      }
    });
  }

  function revealFirstItemAnswer(qObj) {
    if (!qObj) return;
    if (qObj.qtype === 'textInput') {
      qObj.correctSpanDOM.textContent = `Right answer: ${qObj.correctAnswer}`;
      qObj.correctSpanDOM.style.display = 'inline';
    }
    else if (qObj.qtype === 'multipleChoice') {
      if (qObj.containerDOM) {
        qObj.containerDOM.insertAdjacentHTML(
          'beforeend',
          `<div class="exercise-line" style="color:blue; font-weight:bold;">Right answer: ${qObj.correctAnswer}</div>`
        );
      }
    }
    else if (qObj.qtype === 'trueFalse') {
      if (qObj.containerDOM) {
        qObj.containerDOM.insertAdjacentHTML(
          'beforeend',
          `<div class="exercise-line" style="color:blue; font-weight:bold;">Right answer: ${qObj.correctAnswer}</div>`
        );
      }
    }
    else if (qObj.qtype === 'matching') {
      if (qObj.pairs && qObj.pairs.length > 0) {
        let firstPair = qObj.pairs[0];
        if (firstPair.correctSpanDOM) {
          firstPair.correctSpanDOM.textContent = `Right answer: ${firstPair.correctValue}`;
          firstPair.correctSpanDOM.style.display = 'inline';
        }
      }
    }
    else if (qObj.qtype === 'ordering') {
      if (qObj.containerDOM && qObj.items.length > 0) {
        let firstInput = qObj.containerDOM.querySelectorAll('input.answer-input')[0];
        let correctPos = qObj.correctPositions[0];
        let span = firstInput.parentNode.querySelector('.correct-answer-span');
        if (span) {
          span.textContent = `Right position: ${correctPos}`;
          span.style.display = 'inline';
        }
      }
    }
  }

  //====================================================
  // (12) DOMContentLoaded
  //====================================================
  document.addEventListener('DOMContentLoaded', () => {
    ensureUserIsAuthenticated(() => {
      loadContent();
      const generatePdfBtn = document.getElementById('generate-pdf-btn');
      if (userData.role === 'professor' || userData.role === 'proprietario') {
        generatePdfBtn.style.display = 'inline-block';
      } else {
        generatePdfBtn.style.display = 'none';
      }
    });
  });
</script>
</body>
</html>
