<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hannah Mixed Letters</title>

    <link href="https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible:wght@400;700&display=swap" rel="stylesheet">

    <style>
        :root{
            --brand:#ff4500; --bg-soft:#ffe7d1; --ok:#2e7d32; --focus:#1e88e5; --tile:#fff; --tile-border:#333; --err:#e53935;

            /* Dimensões padrão (máximas) dos slots/tiles */
            --slot-w:56px; --slot-h:64px; --tile-font:1.6rem; --slot-gap:8px;

            /* Limites padrão */
            --slot-w-min:48px; --slot-h-min:56px; --slot-w-max:56px; --slot-h-max:64px; --slot-gap-min:6px;

            /* Overflow UI */
            --track-height:30px;
            --thumb-min:40px;
            --track-radius:14px;
            --track-bg:#e9eef5;
            --thumb-bg:#c4d2e6;
            --arrow-bg:#ffffff;
            --arrow-bd:#c8d2e0;
            --fade:linear-gradient(90deg, rgba(255,255,255,0.0), rgba(0,0,0,0.08) 90%);
        }
        @media (max-width:480px){
          :root{ --slot-w-min:42px; --slot-h-min:50px; --slot-gap:6px; --slot-gap-min:4px; }
        }
        @media (max-width:360px){
          :root{ --slot-w-min:40px; --slot-h-min:48px; --slot-gap:6px; --slot-gap-min:4px; }
        }

        *{ box-sizing:border-box }
        body{
            font-family:'Atkinson Hyperlegible', system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
            margin:0; padding:16px;
            display:flex; flex-direction:column; align-items:center;
            background-image:url('../../../imagens/fundo.png'); background-repeat:repeat; background-size:auto;
            -webkit-tap-highlight-color:transparent;
        }
        h1{ text-align:center; color:var(--brand); font-size:clamp(1.8rem,4vw,3rem); margin:12px 0 8px; }
        .toolbar{ display:flex; gap:10px; flex-wrap:wrap; justify-content:center; margin-bottom:8px; }
        .btn{ background:#000; color:#fff; border:0; border-radius:12px; padding:12px 18px; font-size:1.05rem; cursor:pointer; }
        .btn--pdf{ background:var(--ok) }
        .btn:focus-visible{ outline:3px solid var(--focus) }
        .activity-container{ margin-top:8px; width:100%; max-width:960px }
        .activity{
            display:grid; grid-template-columns:140px 1fr; gap:16px; align-items:center; position:relative;
            padding:16px; background-color:var(--bg-soft); border-radius:16px; box-shadow:0 6px 12px rgba(0,0,0,.08);
            margin-bottom:18px;
        }
        .activity img{
            width:120px; height:120px; object-fit:contain; border-radius:12px; background:#fff; border:2px solid #eee; justify-self:center;
        }
        .word-area{ display:grid; gap:12px }
        .status{ font-size:.95rem; color:#444 } .good{ color:var(--ok); font-weight:700 }

        /* ====== Linha pontilhada (drop) ====== */
        .drop-wrap{ display:grid; gap:8px; }
        .drop-viewport{
            position:relative;
            overflow-x:auto; /* mantém gesto natural, mas o trilho custom guia o aluno */
            -webkit-overflow-scrolling:touch;
            padding-bottom:2px; /* espaço para não “colar” na borda */
            touch-action:pan-x;
        }
        .drop-viewport[data-gradient-left="1"]::before,
        .drop-viewport[data-gradient-right="1"]::after{
            content:""; position:absolute; top:0; bottom:0; width:14px; pointer-events:none;
        }
        .drop-viewport[data-gradient-left="1"]::before{
            left:0; transform:scaleX(-1); background:var(--fade); border-radius:12px 0 0 12px;
        }
        .drop-viewport[data-gradient-right="1"]::after{
            right:0; background:var(--fade); border-radius:0 12px 12px 0;
        }

        .drop-zone{
            display:flex; gap:var(--slot-gap); flex-wrap:nowrap; min-height:var(--slot-h); align-items:center;
            padding:2px 4px; /* para respirador das bordas */
        }

        .slot{
            width:var(--slot-w); height:var(--slot-h);
            border:3px dashed #999; border-radius:12px; background:#fff;
            display:grid; place-items:center; position:relative; outline:none; flex:0 0 var(--slot-w);
            scroll-snap-align:center;
        }
        .slot.correct{ border-style:solid; border-color:var(--ok) }
        .slot.wrong{ border-style:solid; border-color:var(--err) }
        .slot.empty{ border-style:dashed; border-color:#999 }
        .slot[data-ghost]::after{ content:attr(data-ghost); position:absolute; color:#bbb; font-weight:700; font-size:calc(var(--tile-font)*0.85); pointer-events:none; }
        .slot:focus, .slot:focus-visible{ outline:none }

        /* ====== Trilho custom do overflow ====== */
        .overflow-ui{ display:none; align-items:center; gap:10px; }
        .drop-wrap[data-overflow="1"] .overflow-ui{ display:flex; }
        .drop-track{
            position:relative; flex:1 1 auto; height:var(--track-height);
            background:var(--track-bg); border-radius:var(--track-radius); overflow:hidden;
        }
        .drop-thumb{
            position:absolute; top:4px; bottom:4px; left:4px; width:120px;
            background:var(--thumb-bg); border-radius:999px; cursor:pointer;
        }
        .drop-arrow{
            width:44px; height:var(--track-height);
            display:grid; place-items:center; user-select:none; cursor:pointer;
            background:var(--arrow-bg); border:1px solid var(--arrow-bd); border-radius:12px;
        }
        .drop-arrow:active{ transform:scale(0.98) }

        .tray{
            display:flex; gap:var(--slot-gap); flex-wrap:wrap; justify-content:center;
            background:rgba(255,255,255,.8); border:2px solid #eee; border-radius:12px; padding:8px;
        }
        .tile{
            width:var(--slot-w); height:var(--slot-h);
            border:3px solid var(--tile-border); border-radius:12px; background:var(--tile);
            display:grid; place-items:center; font-size:var(--tile-font); font-weight:700;
            cursor:grab; user-select:none; touch-action:none; transition:transform 0.2s ease; outline:none; flex:0 0 var(--slot-w);
        }
        .tile:active{ cursor:grabbing }
        .tile.dragging, .tile[aria-grabbed="true"]{ outline:3px solid var(--focus); transform:scale(1.1); z-index:100 }
        body.touch .tile.dragging{ position:fixed; pointer-events:none; }

        .controls{ display:flex; gap:8px; flex-wrap:wrap }
        .pill{ background:#fff; border:2px solid #ddd; border-radius:999px; padding:8px 12px; cursor:pointer; font-size:.95rem; }
        .pill:focus-visible{ outline:3px solid var(--focus) }

        /* Modal */
        #overlay{ position:fixed; inset:0; background:rgba(0,0,0,.6); display:none; z-index:1000; }
        #completion-modal{
            position:fixed; top:50%; left:50%; transform:translate(-50%,-50%);
            background:#fff; padding:28px; border-radius:16px; box-shadow:0 10px 30px rgba(0,0,0,.25);
            text-align:center; display:none; z-index:1001; width:min(92vw,520px);
        }
        #completion-modal h2{ margin:0; font-size:1.8rem; color:var(--ok) }
        #completion-modal p{ font-size:1rem; margin:8px 0 0 }
        #completion-modal button{ margin-top:16px; padding:10px 16px; font-size:1rem; cursor:pointer; border:none; border-radius:10px; background:var(--ok); color:#fff; }

        /* Confete */
        .confetti{ position:fixed; pointer-events:none; z-index:1200; width:8px; height:12px; background:#ffd54f; animation:fall 900ms ease-out forwards; }
        @keyframes fall{ to{ transform:translateY(120vh) rotate(540deg); opacity:0 } }

        @media (max-width:700px){
            .activity{ grid-template-columns:1fr; justify-items:center }
            .activity img{ width:140px; height:140px }
        }
    </style>
</head>
<body>
    <div class="toolbar" aria-label="Toolbar">
        <button id="backButton" class="btn">Back</button>
        <button id="pdfButton" class="btn btn--pdf" style="display:none" onclick="generatePDF()">Generate PDF</button>
    </div>

    <h1>Hannah Mixed Letters</h1>
    <p class="status" id="sessionStatus" aria-live="polite"></p>

    <div id="activity-container" class="activity-container"></div>

    <div id="overlay" role="presentation"></div>
    <div id="completion-modal" role="dialog" aria-modal="true" aria-labelledby="modal-title">
        <h2 id="modal-title">Phase Completed!</h2>
        <p>Great job! You finished this phase.</p>
        <button onclick="closeModal()">Close</button>
    </div>

    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.4.0/jspdf.umd.min.js"></script>

    <script>
    /* ================== Firebase (mantido) ================== */
    const firebaseConfig = {
        apiKey: "AIzaSyDGgo2H_hDKXF88xN7XnLFNUj8ikMY7Xdc",
        authDomain: "hannahenglishcourse.firebaseapp.com",
        projectId: "hannahenglishcourse",
        storageBucket: "hannahenglishcourse.appspot.com",
        messagingSenderId: "449818788486",
        appId: "1:449818788486:web:8a49d3f68591e6fb3f0707",
        measurementId: "G-07VVJG9LRS",
        databaseURL: "https://hannahenglishcourse-default-rtdb.asia-southeast1.firebasedatabase.app"
    };
    firebase.initializeApp(firebaseConfig);

    document.getElementById('backButton').addEventListener('click', async function () {
        const { level, unit } = getLevelAndUnitFromURL();
        const currentPhase = parseInt(getPhaseFromURL());
        const nextPhase = currentPhase + 1;
        const user = firebase.auth().currentUser;
        if (!user) { alert("You must be logged in to perform this action."); return; }
        const userId = user.uid;
        const progressRef = firebase.database().ref(`usuarios/${userId}/progresso/${level}/${unit}/fase${nextPhase}`);
        try {
            const snapshot = await progressRef.once('value');
            const isUnlocked = snapshot.val();
            if (isUnlocked) { history.back(); }
            else { if (confirm("The next phase is still locked. Leave this page before finishing it?")) history.back(); }
        } catch (e) { alert("Error checking phase progress."); }
    });

    firebase.auth().onAuthStateChanged((user) => {
        if (user) {
            const userId = user.uid;
            const userRoleRef = firebase.database().ref(`usuarios/${userId}/role`);
            userRoleRef.once('value').then((snapshot) => {
                const role = snapshot.val();
                if (role === 'professor' || role === 'proprietário') {
                    document.getElementById("pdfButton").style.display = "inline-block";
                }
            });
        }
    });

    /* ================== TTS + MP3 (iOS safe) ================== */
    let selectedVoice = null;
    let wordPlayer = new Audio();
    wordPlayer.preload = 'auto';
    wordPlayer.setAttribute('playsinline', '');
    wordPlayer.setAttribute('webkit-playsinline', '');

    let audioPrimed = false;
    function primeAudioPipelineOnce() {
      if (audioPrimed) return;
      audioPrimed = true;
      try {
        const AC = window.AudioContext || window.webkitAudioContext;
        if (AC) {
          const ctx = new AC(); const osc = ctx.createOscillator(); const gain = ctx.createGain();
          gain.gain.value = 0; osc.connect(gain); gain.connect(ctx.destination); osc.start(); osc.stop(ctx.currentTime + 0.01);
        }
      } catch {}
    }
    window.addEventListener('pointerdown', primeAudioPipelineOnce, { once:true, passive:true });
    window.addEventListener('touchstart',  primeAudioPipelineOnce, { once:true, passive:true });
    window.addEventListener('click',       primeAudioPipelineOnce, { once:true, passive:true });

    function initializeVoices(){
        const v = window.speechSynthesis.getVoices();
        selectedVoice = v.find(x => x.lang && x.lang.toLowerCase().startsWith("en-")) || v[0] || null;
    }
    window.speechSynthesis.onvoiceschanged = initializeVoices;

    function speak(text){
        const synth = window.speechSynthesis;
        try{ if(!audioPrimed) primeAudioPipelineOnce(); }catch{}
        try{ if(!wordPlayer.paused){ wordPlayer.pause(); wordPlayer.currentTime = 0; } }catch{}
        try{ synth.cancel(); }catch{}
        if(!selectedVoice) initializeVoices();
        const u = new SpeechSynthesisUtterance(text);
        u.lang = "en-US"; if(selectedVoice) u.voice = selectedVoice; synth.speak(u);
    }
    function stopCurrentAudio(){ try{ if(!wordPlayer.paused){ wordPlayer.pause(); wordPlayer.currentTime = 0; } }catch{} }
    function tryPlayAudio(url){
      return new Promise((resolve)=>{
        try{ stopCurrentAudio(); }catch{}; try{ if(!audioPrimed) primeAudioPipelineOnce(); }catch{}
        wordPlayer.src = url; wordPlayer.onerror = () => resolve(false);
        try{
          wordPlayer.load(); const p = wordPlayer.play();
          if(p && typeof p.then === 'function'){ p.then(()=>resolve(true)).catch(()=>resolve(false)); } else { resolve(true); }
        }catch{ resolve(false); }
      });
    }
    async function playFirstAvailable(urls){ for(const u of urls){ if(await tryPlayAudio(u)) return true; } return false; }
    let suppressLettersUntil = 0;
    function playWordMp3OrSpeak(wordIndexZeroBased, wordText){
        const { level, unit } = getLevelAndUnitFromURL();
        const n = wordIndexZeroBased + 1;
        const base = `../../${level}/${unit}/data3/sounds`;
        const urls = [`${base}/som${n}.mp3`, `${base}/som.${n}.mp3`];
        suppressLettersUntil = Date.now() + 900;
        playFirstAvailable(urls).then(ok => { if(!ok) speak(wordText); });
    }
    function letterIndex(ch){ const up=(ch||'').toUpperCase(); const code=up.charCodeAt(0); if(code>=65&&code<=90) return code-64; return null; }
    async function playLetterMp3OrSpeak(ch){
        if(Date.now()<suppressLettersUntil) return;
        const idx = letterIndex(ch); if(!idx){ speak(ch); return; }
        const urls = [`./letras/som${idx}.mp3`, `./letras/som.${idx}.mp3`];
        const ok = await playFirstAvailable(urls); if(!ok) speak(ch);
    }

    /* ================== Estado / sessão ================== */
    const SESSION_LIMIT = 6;
    let activities = []; let completedWords = 0;
    const sessionStatus = document.getElementById('sessionStatus');
    const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

    document.addEventListener('DOMContentLoaded', () => {
        if (isTouchDevice) document.body.classList.add('touch');
        initializeVoices();
        loadActivities();
        window.addEventListener('resize', debounce(reflowAllDropZones,120));
        window.addEventListener('orientationchange', debounce(reflowAllDropZones,120));
    });

    function getPhaseFromURL(){ return new URLSearchParams(window.location.search).get('fase'); }
    function getLevelAndUnitFromURL(){ const p=new URLSearchParams(window.location.search); return { level:p.get('level'), unit:p.get('unit') }; }

    /* =============== Core DnD + Overflow amigável =============== */
    function createActivity(imageUrl, word, wordIndex){
        const container = document.getElementById('activity-container');
        const div = document.createElement('div'); div.className = 'activity'; div.dataset.completed = "false";

        const img = document.createElement('img'); img.src=imageUrl; img.alt=`Image hint for ${word}`; img.onerror=()=>img.style.display='none'; div.appendChild(img);

        const area = document.createElement('div'); area.className='word-area'; div.appendChild(area);

        // --- Drop: wrap + viewport + zone ---
        const dropWrap = document.createElement('div'); dropWrap.className='drop-wrap'; dropWrap.setAttribute('role','region'); dropWrap.setAttribute('aria-label','Build the word');
        const dropViewport = document.createElement('div'); dropViewport.className='drop-viewport';
        const dropZone = document.createElement('div'); dropZone.className='drop-zone'; dropZone.dataset.letters = String(word.length);
        dropViewport.appendChild(dropZone); dropWrap.appendChild(dropViewport); area.appendChild(dropWrap);

        // --- Overflow UI (arrows + track) ---
        const overflowUi = document.createElement('div'); overflowUi.className='overflow-ui';
        const leftBtn = elArrow('◄'); const rightBtn = elArrow('►');
        const track = document.createElement('div'); track.className='drop-track';
        const thumb = document.createElement('div'); thumb.className='drop-thumb';
        track.appendChild(thumb); overflowUi.appendChild(leftBtn); overflowUi.appendChild(track); overflowUi.appendChild(rightBtn);
        dropWrap.appendChild(overflowUi);

        // --- Tray (teclado) ---
        const tray = document.createElement('div'); tray.className='tray';

        // Cria slots
        const slots=[];
        for(let i=0;i<word.length;i++){
            const s=document.createElement('div'); s.className='slot empty'; s.setAttribute('aria-label',`Position ${i+1}`); s.setAttribute('role','button'); s.tabIndex=0;

            s.addEventListener('dragenter', e=>e.preventDefault());
            s.addEventListener('dragover',  e=>e.preventDefault());
            s.addEventListener('drop', e=>handleDrop(e,s));

            if(isTouchDevice){
                s.addEventListener('touchstart',e=>handleTouchStart(e,s),{passive:false});
                s.addEventListener('touchmove', e=>handleTouchMove(e,s),{passive:false});
                s.addEventListener('touchend',  e=>handleTouchEnd(e,s),{passive:false});
                s.addEventListener('touchcancel', e=>handleTouchCancel(e,s));
            }
            s.addEventListener('click', ()=>{
                const child = s.querySelector('.tile');
                if(child){
                    child.setAttribute('draggable','true'); child.setAttribute('aria-grabbed','false'); child.style.outline='none';
                    tray.appendChild(child);
                    s.innerHTML=''; s.classList.remove('correct','wrong'); s.classList.add('empty');
                    if(i===0 && revealHintBtn.disabled) s.dataset.ghost = word[0].toUpperCase();
                    updatePerSlotFeedback();
                }
            });
            slots.push(s); dropZone.appendChild(s);
        }

        // Hint + Reset
        const revealHintBtn=document.createElement('button'); revealHintBtn.className='pill'; revealHintBtn.textContent='Hint (1st letter)';
        revealHintBtn.addEventListener('click',()=>{ if(!slots[0].dataset.ghost){ slots[0].dataset.ghost = word[0].toUpperCase(); revealHintBtn.disabled = true; }});
        const resetBtn=document.createElement('button'); resetBtn.className='pill'; resetBtn.textContent='Reset'; resetBtn.addEventListener('click',()=>resetActivity());
        const controls=document.createElement('div'); controls.className='controls'; controls.appendChild(revealHintBtn); controls.appendChild(resetBtn);
        area.appendChild(controls);

        area.appendChild(tray);

        // Letras embaralhadas
        const shuffled = shuffleWord(word);
        const finalShuffle = (shuffled.toUpperCase() === word.toUpperCase()) ? forcedShuffle(word) : shuffled;

        for(const ch of finalShuffle.toUpperCase()){
            const tile=document.createElement('div'); tile.className='tile'; tile.textContent=ch;
            tile.setAttribute('draggable','true'); tile.setAttribute('role','button'); tile.setAttribute('aria-grabbed','false'); tile.tabIndex=0;

            // Desktop
            tile.addEventListener('dragstart', async (e)=>{ try{ e.dataTransfer.setData('text/plain',tile.textContent); e.dataTransfer.effectAllowed='move'; }catch{} tile.setAttribute('aria-grabbed','true'); tile.classList.add('dragging'); await playLetterMp3OrSpeak(ch); startAutoScroll(dropViewport); });
            tile.addEventListener('dragend',   ()=>{ tile.setAttribute('aria-grabbed','false'); tile.classList.remove('dragging'); tile.style.outline='none'; stopAutoScroll(); });

            // Tap
            tile.addEventListener('click', async ()=>{ await playLetterMp3OrSpeak(ch); });

            // Touch
            if(isTouchDevice){
                tile.addEventListener('touchstart', async (e)=>{ handleTileTouchStart(e,tile); await playLetterMp3OrSpeak(ch); startAutoScroll(dropViewport); }, {passive:false});
                tile.addEventListener('touchmove',  (e)=>handleTileTouchMove(e,tile), {passive:false});
                tile.addEventListener('touchend',   (e)=>{ handleTileTouchEnd(e,tile); stopAutoScroll(); }, {passive:false});
                tile.addEventListener('touchcancel',(e)=>{ handleTileTouchCancel(e,tile); stopAutoScroll(); });
            }
            tray.appendChild(tile);
        }

        function handleDrop(e, slotEl){
            e.preventDefault();
            const tile=document.querySelector('.tile[aria-grabbed="true"]'); if(!tile) return;
            if(slotEl.firstElementChild){ tray.appendChild(slotEl.firstElementChild); }
            slotEl.innerHTML=''; if(slotEl.dataset.ghost) delete slotEl.dataset.ghost;
            tile.setAttribute('draggable','false'); tile.setAttribute('aria-grabbed','false'); tile.classList.remove('dragging'); tile.style.outline='none';
            slotEl.appendChild(tile);
            updatePerSlotFeedback(); checkAnswer();
        }

        /* ===== Touch DnD ===== */
        let activeTile=null, touchOffsetX=0, touchOffsetY=0;
        function handleTileTouchStart(e,tile){
            e.preventDefault(); const t=e.touches[0]; const r=tile.getBoundingClientRect(); touchOffsetX=t.clientX-r.left; touchOffsetY=t.clientY-r.top; activeTile=tile; tile.setAttribute('aria-grabbed','true'); tile.classList.add('dragging');
        }
        function handleTileTouchMove(e){
            if(!activeTile) return; e.preventDefault();
            const t=e.touches[0]; const currentX=t.clientX - touchOffsetX; const currentY=t.clientY - touchOffsetY;
            activeTile.style.left=currentX+'px'; activeTile.style.top=currentY+'px';
            // highlight de slot
            const slotsEls=dropZone.querySelectorAll('.slot');
            slotsEls.forEach(slot=>{ const r=slot.getBoundingClientRect(); if(t.clientX>=r.left&&t.clientX<=r.right&&t.clientY>=r.top&&t.clientY<=r.bottom){ slot.style.backgroundColor='#f0f0f0'; }else{ slot.style.backgroundColor=''; }});
            // auto-scroll quando perto das bordas
            checkAutoScrollEdge(t.clientX, dropViewport);
        }
        function handleTileTouchEnd(e,tile){
            if(!activeTile) return; e.preventDefault();
            const t=e.changedTouches[0]; const slotsEls=dropZone.querySelectorAll('.slot'); let dropped=false;
            slotsEls.forEach((slot)=>{ const r=slot.getBoundingClientRect(); if(t.clientX>=r.left&&t.clientX<=r.right&&t.clientY>=r.top&&t.clientY<=r.bottom){
                if(slot.firstElementChild){ const existing=slot.firstElementChild; existing.setAttribute('draggable','true'); existing.setAttribute('aria-grabbed','false'); existing.classList.remove('dragging'); existing.style.left=''; existing.style.top=''; existing.style.outline='none'; tray.appendChild(existing); }
                slot.innerHTML=''; if(slot.dataset.ghost) delete slot.dataset.ghost;
                tile.setAttribute('draggable','false'); tile.setAttribute('aria-grabbed','false'); tile.classList.remove('dragging'); tile.style.left=''; tile.style.top=''; tile.style.outline='none'; slot.appendChild(tile);
                dropped=true; updatePerSlotFeedback(); checkAnswer(); }
                slot.style.backgroundColor='';
            });
            if(!dropped){ tray.appendChild(tile); tile.classList.remove('dragging'); tile.setAttribute('aria-grabbed','false'); tile.style.left=''; tile.style.top=''; tile.style.outline='none'; updatePerSlotFeedback(); }
            activeTile=null;
        }
        function handleTileTouchCancel(e,tile){ if(activeTile){ tile.classList.remove('dragging'); tile.setAttribute('aria-grabbed','false'); tile.style.left=''; tile.style.top=''; tile.style.outline='none'; activeTile=null; } }
        function handleTouchStart(e){ e.preventDefault(); }
        function handleTouchMove(e){ e.preventDefault(); }
        function handleTouchEnd(e, slot){
            if(!activeTile){ const child=slot.querySelector('.tile'); if(child){ child.setAttribute('draggable','true'); child.setAttribute('aria-grabbed','false'); child.style.outline='none'; tray.appendChild(child); slot.innerHTML=''; slot.classList.remove('correct','wrong'); slot.classList.add('empty'); const index=Array.from(slots).indexOf(slot); if(index===0 && revealHintBtn.disabled) slot.dataset.ghost=word[0].toUpperCase(); updatePerSlotFeedback(); } }
        }
        function handleTouchCancel(){}

        function currentAnswer(){ return slots.map(s => (s.querySelector('.tile')?.textContent || '')).join(''); }
        function updatePerSlotFeedback(){
            slots.forEach((s,idx)=>{
                const t=s.querySelector('.tile');
                if(!t){ s.classList.remove('correct','wrong'); s.classList.add('empty'); return; }
                const ok=word[idx].toUpperCase()===t.textContent;
                s.classList.remove('empty'); s.classList.toggle('correct', !!t && ok); s.classList.toggle('wrong', !!t && !ok);
            });
        }
        async function checkAnswer(){
            const ans=currentAnswer(); if(ans.length!==word.length || slots.some(s=>!s.querySelector('.tile'))) return;
            if(ans.toUpperCase()===word.toUpperCase()){
                if(div.dataset.completed==="false"){ div.dataset.completed="true"; playWordMp3OrSpeak(wordIndex, word); celebrate(div); completedWords++; updateSessionStatus(); }
                slots.forEach(s=>{ const t=s.querySelector('.tile'); if(t) t.setAttribute('draggable','false'); s.classList.remove('wrong','empty'); s.classList.add('correct'); });
                if(completedWords===activities.length){ showCompletionModal(); firebase.auth().onAuthStateChanged((user)=>{ if(user) updateNextPhase(user.uid); }); }
            } else { updatePerSlotFeedback(); }
        }
        function resetActivity(){
            slots.forEach((s,i)=>{
                const t=s.querySelector('.tile'); if(t){ t.setAttribute('draggable','true'); t.setAttribute('aria-grabbed','false'); t.classList.remove('dragging'); t.style.left=''; t.style.top=''; t.style.outline='none'; tray.appendChild(t); }
                s.innerHTML=''; s.classList.remove('correct','wrong'); s.classList.add('empty');
                if(i===0 && !revealHintBtn.disabled) delete s.dataset.ghost;
                if(i===0 && revealHintBtn.disabled) s.dataset.ghost = word[0].toUpperCase();
            });
            updatePerSlotFeedback();
            requestAnimationFrame(()=> fitSlotsToOneLine(dropViewport, dropZone, dropWrap, track, thumb));
        }

        // Layout + overflow
        const ro = new ResizeObserver(()=> fitSlotsToOneLine(dropViewport, dropZone, dropWrap, track, thumb));
        ro.observe(div);
        img.addEventListener('load', ()=> fitSlotsToOneLine(dropViewport, dropZone, dropWrap, track, thumb));
        dropViewport.addEventListener('scroll', ()=> syncThumb(dropViewport, dropZone, track, thumb));
        leftBtn.addEventListener('click', ()=> nudgeScroll(dropViewport, -stepSize(dropZone)));
        rightBtn.addEventListener('click',()=> nudgeScroll(dropViewport,  stepSize(dropZone)));

        // Track drag
        enableThumbDrag(track, thumb, dropViewport, dropZone);

        // Inicial
        requestAnimationFrame(()=> fitSlotsToOneLine(dropViewport, dropZone, dropWrap, track, thumb));

        container.appendChild(div);
    }

    // ===== Overflow helpers =====
    function elArrow(txt){ const b=document.createElement('div'); b.className='drop-arrow'; b.setAttribute('role','button'); b.setAttribute('tabindex','0'); b.textContent=txt; b.addEventListener('keydown',e=>{ if(e.key==='Enter'||e.key===' ') b.click(); }); return b; }
    function stepSize(dropZone){ // 1 slot + gap
        const cs=getComputedStyle(dropZone);
        const w=parseFloat(cs.getPropertyValue('--slot-w'))||56;
        const g=parseFloat(cs.getPropertyValue('gap'))||8;
        return Math.round(w+g);
    }
    function nudgeScroll(viewport, delta){
        viewport.scrollTo({ left: clamp(viewport.scrollLeft + delta, 0, viewport.scrollWidth - viewport.clientWidth), behavior:'smooth' });
    }
    function enableThumbDrag(track, thumb, viewport, dropZone){
        let dragging=false, startX=0, startLeft=0;
        function onDown(e){ dragging=true; startX=(e.touches?e.touches[0].clientX:e.clientX); startLeft=parseFloat(getComputedStyle(thumb).left)||0; e.preventDefault(); }
        function onMove(e){
            if(!dragging) return;
            const x=(e.touches?e.touches[0].clientX:e.clientX);
            const dx=x-startX;
            const limits = track.clientWidth - thumb.clientWidth - 8; // 4px padding each side
            const left = clamp(startLeft + dx, 4, 4 + limits);
            thumb.style.left = left+'px';
            const ratio = (left-4) / limits;
            const target = (viewport.scrollWidth - viewport.clientWidth) * ratio;
            viewport.scrollLeft = target;
        }
        function onUp(){ dragging=false; }
        thumb.addEventListener('mousedown',onDown); thumb.addEventListener('touchstart',onDown,{passive:false});
        window.addEventListener('mousemove',onMove); window.addEventListener('touchmove',onMove,{passive:false});
        window.addEventListener('mouseup',onUp); window.addEventListener('touchend',onUp);
    }
    function syncThumb(viewport, dropZone, track, thumb){
        const contentW = dropZone.scrollWidth, vpW = viewport.clientWidth;
        const overflow = contentW > vpW + 1;
        const limits = Math.max(8, track.clientWidth - (parseFloat(getComputedStyle(thumb).width)||120) - 8);
        if(!overflow){ thumb.style.left='4px'; return; }
        const ratio = viewport.scrollLeft / (contentW - vpW);
        thumb.style.left = (4 + limits * ratio) + 'px';

        // gradientes laterais
        const nearLeft = viewport.scrollLeft <= 2;
        const nearRight = (contentW - vpW - viewport.scrollLeft) <= 2;
        viewport.dataset.gradientLeft  = nearLeft ? '0' : '1';
        viewport.dataset.gradientRight = nearRight ? '0' : '1';
    }
    function fitSlotsToOneLine(viewport, dropZone, dropWrap, track, thumb){
        if(!viewport || !dropZone) return;

        const root = getComputedStyle(document.documentElement);
        const DZstyles = getComputedStyle(dropZone);

        const MIN_W = parseInt(root.getPropertyValue('--slot-w-min'))||42;
        const MAX_W = parseInt(root.getPropertyValue('--slot-w-max'))||56;
        const MIN_H = parseInt(root.getPropertyValue('--slot-h-min'))||50;
        const MAX_H = parseInt(root.getPropertyValue('--slot-h-max'))||64;
        const gapDefault = parseFloat(DZstyles.getPropertyValue('gap'))||8;
        const gapMin = parseFloat(root.getPropertyValue('--slot-gap-min'))||4;

        const letters = (dropZone.dataset.letters|0)||0;
        const available = Math.floor(viewport.clientWidth);

        let gap = gapDefault;
        let totalGaps = Math.max(0, letters-1)*gap;
        let idealW = Math.floor((available - totalGaps)/letters);
        if(!Number.isFinite(idealW) || idealW<=0) idealW = MAX_W;
        let slotW = clamp(idealW, MIN_W, MAX_W);
        let needed = slotW*letters + totalGaps;

        if(needed>available && gap>gapMin){
            gap = gapMin; dropZone.style.gap = gap+'px';
            totalGaps = Math.max(0, letters-1)*gap;
            idealW = Math.floor((available - totalGaps)/letters);
            slotW = clamp(idealW, MIN_W, MAX_W);
            needed = slotW*letters + totalGaps;
        } else dropZone.style.gap='';

        if(needed>available) slotW = MIN_W;

        const ratio = MAX_H/MAX_W;
        let slotH = Math.round(slotW*ratio); slotH = clamp(slotH, MIN_H, MAX_H);

        const baseRem=1.6, scale=slotW/MAX_W; let fontRem = clamp(baseRem*scale, 1.0, 1.6);

        dropZone.style.setProperty('--slot-w', slotW+'px');
        dropZone.style.setProperty('--slot-h', slotH+'px');
        dropZone.style.setProperty('--tile-font', fontRem+'rem');

        // Ativa UI de overflow se necessário
        const contentW = dropZone.scrollWidth, vpW = viewport.clientWidth;
        const overflow = contentW > vpW + 1;
        dropWrap.dataset.overflow = overflow ? '1' : '0';

        // Thumb size proporcional (mínimo visível)
        if(overflow){
            const trackInner = track.clientWidth - 8; // padding 4 + 4
            const thumbW = clamp(Math.round((vpW/contentW)*trackInner), parseInt(getComputedStyle(document.documentElement).getPropertyValue('--thumb-min'))||40, trackInner);
            thumb.style.width = thumbW + 'px';
        }

        syncThumb(viewport, dropZone, track, thumb);
    }

    // ===== Auto-scroll ao arrastar perto da borda =====
    let autoScrollRAF=null, autoScrollDir=0, autoScrollViewport=null;
    function startAutoScroll(viewport){ autoScrollViewport=viewport; if(!autoScrollRAF){ autoScrollRAF = requestAnimationFrame(autoScrollStep); } }
    function stopAutoScroll(){ autoScrollDir=0; if(autoScrollRAF){ cancelAnimationFrame(autoScrollRAF); autoScrollRAF=null; } autoScrollViewport=null; }
    function checkAutoScrollEdge(pointerX, viewport){
        const r = viewport.getBoundingClientRect();
        const edge = 24; // zona de acionamento
        if(pointerX < r.left + edge) autoScrollDir = -1;
        else if(pointerX > r.right - edge) autoScrollDir = 1;
        else autoScrollDir = 0;
    }
    function autoScrollStep(){
        if(autoScrollViewport && autoScrollDir!==0){
            const speed = 10; // px por frame
            autoScrollViewport.scrollLeft = clamp(autoScrollViewport.scrollLeft + autoScrollDir*speed, 0, autoScrollViewport.scrollWidth - autoScrollViewport.clientWidth);
        }
        autoScrollRAF = requestAnimationFrame(autoScrollStep);
    }

    // ===== Util =====
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function debounce(fn, ms){ let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn.apply(this,args), ms); }; }

    // Confete
    function celebrate(host){
        const rect=host.getBoundingClientRect(); const baseY=Math.max(0,rect.top+10);
        const minX=Math.max(0,rect.left-50); const maxX=Math.min(window.innerWidth, rect.right+50);
        for(let i=0;i<18;i++){ const c=document.createElement('div'); c.className='confetti'; const x=Math.random()*(maxX-minX)+minX; c.style.left=`${x}px`; c.style.top=`${baseY}px`; c.style.background=['#ffd54f','#4fc3f7','#ce93d8','#81c784','#ff8a65'][i%5]; document.body.appendChild(c); setTimeout(()=>c.remove(),1000); }
    }

    /* =========== Progresso (mantido) =========== */
    async function updateNextPhase(userId){
        const currentPhase=getPhaseFromURL(); const { level, unit }=getLevelAndUnitFromURL();
        const dbRef=firebase.database().ref(`usuarios/${userId}/progresso/${level}/${unit}`);
        try{
            if(currentPhase==="last"){
                const nextUnit=`Unit${parseInt(unit.replace('Unit',''))+1}`;
                await firebase.database().ref(`usuarios/${userId}/progresso/${level}/${nextUnit}`).set({ fase1:true });
            }else if(currentPhase==="end"){
                const nextLevel=`Level${parseInt(level.replace('Level',''))+1}`;
                await firebase.database().ref(`usuarios/${userId}/progresso/${nextLevel}/Unit1`).set({ fase1:true });
            }else{
                const nextPhase=parseInt(currentPhase)+1;
                await dbRef.update({ [`fase${currentPhase}`]:true, [`fase${nextPhase}`]:true });
            }
        }catch(err){ console.error("Erro ao atualizar o progresso da fase:", err); }
    }

    /* =========== Carregamento / sessão =========== */
    async function loadActivities(){
        const { level, unit } = getLevelAndUnitFromURL();
        try{
            const wordsPath = `../../${level}/${unit}/data3/words.txt`;
            const resp = await fetch(wordsPath);
            if(!resp.ok) throw new Error(`Erro ao buscar palavras. Status: ${resp.status}`);
            const text = await resp.text();
            let words = text.trim().split('\n').map(w=>w.trim()).filter(Boolean);
            if(words.length>SESSION_LIMIT) words = words.slice(0,SESSION_LIMIT);
            words.forEach((word,index)=>{
                const imageUrl = `../../${level}/${unit}/data3/imagens/imagem${index+1}.png`;
                activities.push(word);
                createActivity(imageUrl, word, index);
            });
            updateSessionStatus();
        }catch(e){ console.error('Erro ao carregar palavras ou imagens:', e); }
    }

    function updateSessionStatus(){
        const total=activities.length, done=completedWords;
        if(total===0){ sessionStatus.textContent=''; return; }
        sessionStatus.textContent = `Activities: ${done}/${total}`;
        if(done===total) sessionStatus.innerHTML = `<span class="good">All done! Great job!</span>`;
    }

    // Embaralhador estável
    function shuffleWord(word){
        const arr=word.toUpperCase().split('');
        for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; }
        return arr.join('');
    }
    function forcedShuffle(word){ const arr=word.toUpperCase().split(''); if(arr.length<2) return arr.join(''); [arr[0],arr[1]]=[arr[1],arr[0]]; return arr.join(''); }

    function showCompletionModal(){ document.getElementById('overlay').style.display='block'; document.getElementById('completion-modal').style.display='block'; }
    function closeModal(){ document.getElementById('overlay').style.display='none'; document.getElementById('completion-modal').style.display='none'; }

    // PDF (mantido)
    async function generatePDF(){
        const { jsPDF } = window.jspdf; const doc=new jsPDF(); const logo=new Image(); logo.src='Logo.png';
        function header(){ doc.setFontSize(12); doc.text("Name: __________________________________________ Date: ____________", 50,20); doc.setFontSize(16); doc.text("Hannah Mixed Letters", 10, 50); }
        function drawActivity(activityEl, y){
            const imgEl=activityEl.querySelector('img');
            if(imgEl){ try{ const cv=document.createElement('canvas'); const ctx=cv.getContext('2d'); cv.width=imgEl.naturalWidth||120; cv.height=imgEl.naturalHeight||120; ctx.drawImage(imgEl,0,0,cv.width,cv.height); const data=cv.toDataURL('image/png'); doc.addImage(data,'PNG',10,y,24,24);}catch{} }
            const slotsCount=activityEl.querySelectorAll('.slot').length; let x=50; doc.setFontSize(14);
            for(let i=0;i<slotsCount;i++){ doc.text("_____", x, y+10); x+=16; }
            const trayTiles=[...activityEl.querySelectorAll('.tray .tile')].map(t=>t.textContent).join(' ');
            const filledTiles=[...activityEl.querySelectorAll('.slot .tile')].map(t=>t.textContent).join(' ');
            const mixed=(trayTiles||filledTiles||'').trim(); if(mixed){ doc.setFontSize(11); doc.text(`Letters (mixed): ${mixed}`, 50, y+20); }
        }
        logo.onload=function(){ try{ doc.addImage(logo,'PNG',10,10,30,30); }catch{} header(); let y=60; document.querySelectorAll('.activity').forEach(a=>{ if(y>270){ doc.addPage(); y=20; } drawActivity(a,y); y+=36; }); doc.save("Hannah_Mixed_Letters.pdf"); };
        logo.onerror=function(){ header(); doc.save("Hannah_Mixed_Letters.pdf"); };
    }
    </script>
</body>
</html>
