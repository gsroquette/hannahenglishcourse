<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Story Sequencer ‚Äî Ordene a Hist√≥ria</title>
  <link href="https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --brand:#ff6b00; --ok:#2e7d32; --warn:#c62828; --ink:#222;
      --slot:#ffffff; --slot-border:#bbb; --tile:#fff; --tile-border:#333;
      --shadow: 0 6px 18px rgba(0,0,0,.08);
    }
    *{ box-sizing:border-box }

    /* === Mant√©m o mesmo body das outras atividades === */
    body { 
      font-family: Arial, sans-serif;
      text-align: center;
      margin-top: 50px;
      background-color: #f5f5f5;
      background-image: url('../../../imagens/fundo.png');
      background-repeat: repeat;
      background-size: auto;
      padding: 0 20px;
    }

    header{
      padding:12px 16px; display:flex; align-items:center; gap:12px; justify-content:center;
      margin: 0 auto 8px; max-width:1100px;
    }
    header h1{ font-size:1.2rem; margin:0; font-weight:700 }
    header .pill { padding:6px 12px; border-radius:999px; background:#fff; border:1px solid #eee; font-size:.85rem; box-shadow: var(--shadow)}

    .wrap{ width:min(1100px, 100%); margin:0 auto 24px; display:flex; flex-direction:column; gap:16px }

    .controls{ display:flex; gap:10px; justify-content:center; }
    .btn{
      appearance:none; border:1px solid #ddd; background:#fff; padding:10px 14px; border-radius:12px; cursor:pointer;
      font-weight:600; box-shadow:var(--shadow); transition:.15s transform ease;
    }
    .btn:active{ transform:translateY(1px) }
    .btn.primary{ background:var(--brand); color:#fff; border-color:transparent }
    .btn.ghost{ background:#fff }

    .board{ display:grid; gap:16px }
    .timeline{
      background:#fff; border:1px dashed #ddd; padding:16px; border-radius:16px; box-shadow:var(--shadow);
      overflow:auto; white-space:nowrap; display:flex; gap:12px; align-items:flex-start;
    }
    .slot{
      min-width:110px; width:110px; height:110px; background:#fafafa; border:2px dashed var(--slot-border);
      border-radius:14px; display:flex; align-items:center; justify-content:center; position:relative;
      flex:0 0 auto; transition:border-color .15s ease;
    }
    .slot .num{
      position:absolute; top:6px; left:6px; font-size:.8rem; background:#0000000d; border:1px solid #00000014; padding:2px 6px; border-radius:999px;
    }
    .slot.filled{ border-style:solid; border-color:#aaa }
    .slot.correct{ outline:3px solid var(--ok) }
    .slot.wrong{ animation:shake .25s linear }
    @keyframes shake{ 0%{ transform:translateX(0) } 25%{ transform:translateX(-4px) } 50%{ transform:translateX(4px) } 75%{ transform:translateX(-2px) } 100%{ transform:translateX(0) } }

    .pool{
      background:#fff; border:1px dashed #ddd; padding:12px; border-radius:16px; box-shadow:var(--shadow);
      display:grid; grid-template-columns:repeat(auto-fill, minmax(94px, 1fr)); gap:12px;
    }

    .tile{
      background:var(--tile); border:2px solid var(--tile-border); border-radius:12px; overflow:hidden; cursor:grab; position:relative;
      display:flex; align-items:center; justify-content:center; height:94px; user-select:none;
    }
    .tile:active{ cursor:grabbing }
    .tile img{ max-width:100%; max-height:100%; display:block }

    .hint-glow{ box-shadow:0 0 0 3px rgba(255,107,0,.35), 0 0 0 6px rgba(255,107,0,.15) !important }

    /* Modal */
    .modal{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.4); z-index:50 }
    .modal.open{ display:flex }
    .card{ background:#fff; border-radius:20px; padding:20px; width:min(520px, 92vw); text-align:center; box-shadow:var(--shadow) }
    .card h2{ margin:0 0 8px }
    .confetti{ font-size:42px; line-height:1.2 }
  </style>
</head>
<body>
  <header>
    <span class="pill" id="crumbs">Level ‚Äî Unit ‚Äî Loading‚Ä¶</span>
    <h1 id="title">Story Sequencer</h1>
  </header>

  <main class="wrap">
    <div class="controls" role="toolbar" aria-label="Controles">
      <button class="btn primary" id="btnCheck">Check</button>
      <button class="btn ghost" id="btnReset" title="Limpar e reembaralhar">Reset</button>
      <button class="btn ghost" id="btnHint" title="Revelar pr√≥ximo slot correto">Hint</button>
    </div>

    <section class="board" aria-live="polite">
      <div>
        <p style="margin:6px 0 8px; font-weight:700">Linha do tempo</p>
        <div id="timeline" class="timeline" role="list" aria-label="Slots da sequ√™ncia"></div>
      </div>
      <div>
        <p style="margin:6px 0 8px; font-weight:700">Imagens (embaralhadas)</p>
        <div id="pool" class="pool" aria-label="Banco de pe√ßas"></div>
      </div>
    </section>
  </main>

  <div id="modalWin" class="modal" role="dialog" aria-modal="true" aria-labelledby="winTitle">
    <div class="card">
      <div class="confetti">üéâ‚ú®‚≠ê</div>
      <h2 id="winTitle">Muito bem!</h2>
      <p>Voc√™ colocou a hist√≥ria na ordem certa.</p>
      <button class="btn primary" id="btnCloseWin">Continuar</button>
    </div>
  </div>

  <script>
    // ===================== Utilit√°rios =====================
    const qs = (s, el=document) => el.querySelector(s);
    const qsa = (s, el=document) => [...el.querySelectorAll(s)];
    const shuffle = (arr) => {
      const a = arr.slice();
      for(let i=a.length-1;i>0;i--){ const j = Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; }
      return a;
    };

    function getParams(){
      const url = new URL(location.href);
      const level = url.searchParams.get('level');
      const unit = url.searchParams.get('unit');
      const fase  = url.searchParams.get('fase') || 'seq';
      if(!level || !unit){ alert('Missing URL params: level, unit'); }
      return {level, unit, fase};
    }

    function storageKey({level,unit,fase}){ return `sequencer:${level}:${unit}:${fase}`; }

    // ===================== Estado global =====================
    const state = {
      meta:null, // {level, unit, fase}
      frames:[], // [{id,image}]
      orderIds:[],
      poolIds:[],
      slots:[],
      stats:{ start: Date.now(), checks:0, hints:0 }
    };

    function frameById(id){ return state.frames.find(f=>f.id===id); }

    // ===================== Renderiza√ß√£o =====================
    function renderCrumbs(){
      const {level, unit} = state.meta;
      qs('#crumbs').textContent = `Level ${level} ¬∑ Unit ${unit}`;
      qs('#title').textContent = 'Story Sequencer';
    }

    function renderBoard(){
      const timeline = qs('#timeline');
      timeline.innerHTML = '';
      state.slots.forEach((val, idx)=>{
        const slot = document.createElement('div');
        slot.className = 'slot' + (val? ' filled':'');
        slot.setAttribute('role','listitem');
        slot.setAttribute('data-idx', idx);
        slot.setAttribute('aria-label', `Slot ${idx+1}`);
        slot.tabIndex = 0;

        const num = document.createElement('span');
        num.className = 'num'; num.textContent = idx+1; slot.appendChild(num);

        if(val){
          const frame = frameById(val);
          if(frame){ slot.appendChild(makeTile(frame, {draggable:false, asPlaced:true})); }
        }

        // Click-to-place
        slot.addEventListener('click', handleSlotClick);
        slot.addEventListener('keydown', (e)=>{ if(e.key==='Enter') handleSlotClick(e); });

        // Drag-over for desktop DnD
        slot.addEventListener('dragover', e=>{ e.preventDefault(); slot.style.borderColor = '#999'; });
        slot.addEventListener('dragleave', e=>{ slot.style.borderColor = ''; });
        slot.addEventListener('drop', (e)=>{
          e.preventDefault(); slot.style.borderColor = '';
          const id = e.dataTransfer.getData('text/plain');
          if(!id) return;
          placeIdIntoSlot(id, idx);
        });

        timeline.appendChild(slot);
      });

      const pool = qs('#pool');
      pool.innerHTML = '';
      state.poolIds.forEach(id=>{
        const frame = frameById(id);
        if(frame){ pool.appendChild(makeTile(frame, {draggable:true})); }
      });
    }

    function makeTile(frame, {draggable=true, asPlaced=false}={}){
      const t = document.createElement('div');
      t.className = 'tile';
      t.setAttribute('data-id', frame.id);
      if(draggable){ t.draggable = true; }

      const img = document.createElement('img');
      img.src = frame.image;
      img.alt = 'story frame';
      t.appendChild(img);

      if(draggable){ t.addEventListener('dragstart', (e)=>{ e.dataTransfer.setData('text/plain', frame.id); }); }
      t.addEventListener('click', ()=>{ selectTile(t); });
      if(asPlaced){ t.addEventListener('click', ()=> selectTile(t)); }
      return t;
    }

    // ===================== Sele√ß√£o e coloca√ß√£o =====================
    let selectedId = null; // id selecionado a partir do pool ou de um slot
    function selectTile(tile){
      const id = tile.getAttribute('data-id');
      qsa('.tile').forEach(el=> el.style.outline='');
      if(selectedId === id){ selectedId = null; return; }
      selectedId = id; tile.style.outline = '3px solid var(--brand)';
    }

    function handleSlotClick(e){
      const slot = e.currentTarget;
      const idx = +slot.getAttribute('data-idx');
      if(selectedId){
        placeIdIntoSlot(selectedId, idx);
        selectedId = null; qsa('.tile').forEach(el=> el.style.outline='');
      }
    }

    function placeIdIntoSlot(id, idx){
      // If id is currently in another slot, swap
      const currentIdx = state.slots.findIndex(v=>v===id);
      if(currentIdx === idx) return;

      if(currentIdx !== -1){
        // Moving from one slot to another
        const targetId = state.slots[idx];
        state.slots[idx] = id;
        state.slots[currentIdx] = targetId || null;
      } else {
        // From pool to slot (maybe swapping with occupant)
        const occupant = state.slots[idx];
        state.slots[idx] = id;
        if(occupant){
          state.poolIds = state.poolIds.filter(x=>x!==id);
          state.poolIds.push(occupant);
        } else {
          state.poolIds = state.poolIds.filter(x=>x!==id);
        }
      }
      persistAndRerender();
    }

    function persistAndRerender(){
      saveState(storageKey(state.meta), { slots:state.slots, poolIds:state.poolIds, stats:state.stats });
      renderBoard();
    }

    // ===================== Controles =====================
    function checkSequence(){
      state.stats.checks++;
      let allCorrect = true;
      qsa('.slot').forEach((slotEl, i)=>{
        const id = state.slots[i];
        slotEl.classList.remove('correct','wrong');
        if(!id){ allCorrect = false; return; }
        const isCorrect = id === state.orderIds[i];
        if(isCorrect){ slotEl.classList.add('correct'); }
        else { slotEl.classList.add('wrong'); allCorrect = false; }
        setTimeout(()=> slotEl.classList.remove('correct','wrong'), 800);
      });
      if(allCorrect){ onWin(); }
    }

    function doReset(){
      const ids = [...state.orderIds];
      state.poolIds = shuffle(ids);
      state.slots = new Array(ids.length).fill(null);
      state.stats = { start: Date.now(), checks:0, hints:0 };
      persistAndRerender();
    }

    function doHint(){
      // Find first empty or incorrect slot
      const n = state.orderIds.length;
      let targetIdx = -1;
      for(let i=0;i<n;i++){
        if(state.slots[i] !== state.orderIds[i]){ targetIdx = i; break; }
      }
      if(targetIdx === -1) return; // already correct
      state.stats.hints++;

      const correctId = state.orderIds[targetIdx];
      // If correctId is in another slot, swap to correct position
      const where = state.slots.findIndex(v=>v===correctId);
      if(where !== -1){
        const tmp = state.slots[targetIdx];
        state.slots[targetIdx] = correctId;
        state.slots[where] = tmp || null;
      } else {
        // move from pool
        state.poolIds = state.poolIds.filter(x=>x!==correctId);
        const occupant = state.slots[targetIdx];
        if(occupant) state.poolIds.push(occupant);
        state.slots[targetIdx] = correctId;
      }

      // Visual glow on the correct slot
      const slotEl = qsa('.slot')[targetIdx];
      slotEl.classList.add('hint-glow');
      setTimeout(()=> slotEl.classList.remove('hint-glow'), 900);

      persistAndRerender();
    }

    function onWin(){
      const duration = Math.round((Date.now() - state.stats.start)/1000);
      qs('#modalWin').classList.add('open');
      try{
        if(window.updateNextPhase && window.currentUserId){ window.updateNextPhase(window.currentUserId); }
        if(window.logActivity){ window.logActivity({ type:'story-sequencer', meta:state.meta, stats:{ ...state.stats, duration_s:duration } }); }
      }catch(e){}
    }

    // ===================== Storage helpers =====================
    function saveState(key, stateObj){ try{ localStorage.setItem(key, JSON.stringify(stateObj)); }catch(e){} }
    function loadState(key){ try{ return JSON.parse(localStorage.getItem(key) || 'null'); }catch(e){ return null } }

    // ===================== Bootstrap =====================
    async function init(){
      state.meta = getParams();
      const key = storageKey(state.meta);

      // Base din√¢mica a partir da URL
      const base = `/${state.meta.level}/${state.meta.unit}/DataStory/images/`;
      qs('#crumbs').setAttribute('title', 'Imagens em: ' + base);

      // Carrega imagens sequenciais imagem1.png ... imagemN.png
      state.frames = await loadSequentialImages(base, 1, 30);
      console.log('[Sequencer] Base:', base, 'Frames:', state.frames);
      if(!state.frames.length){
        alert('Nenhuma imagem encontrada em ' + base + ' (esperado: imagem1.png, imagem2.png, ...)');
        return;
      }
      state.orderIds = state.frames.map(f=>f.id);

      // Restaura estado, se existir
      const saved = loadState(key);
      if(saved && Array.isArray(saved.slots) && Array.isArray(saved.poolIds)){
        state.slots = saved.slots;
        state.poolIds = saved.poolIds;
        state.stats = saved.stats || state.stats;
      } else {
        state.poolIds = shuffle([...state.orderIds]);
        state.slots = new Array(state.orderIds.length).fill(null);
      }

      renderCrumbs();
      renderBoard();

      // Controles
      qs('#btnCheck').addEventListener('click', checkSequence);
      qs('#btnReset').addEventListener('click', doReset);
      qs('#btnHint').addEventListener('click', doHint);
      qs('#btnCloseWin').addEventListener('click', ()=>{ qs('#modalWin').classList.remove('open'); });
    }

    function imageExists(url){
      return new Promise(res=>{
        const img = new Image();
        img.onload = ()=> res(true);
        img.onerror = ()=> res(false);
        img.src = url + (url.includes('?')?'&':'?') + 'v=' + Date.now();
      });
    }

    async function loadSequentialImages(base, start=1, max=20){
      const frames = [];
      for(let i=start; i<=max; i++){
        const url = base + `imagem${i}.png`;
        // eslint-disable-next-line no-await-in-loop
        const ok = await imageExists(url);
        if(!ok){
          if(i===start) continue; // tenta pr√≥ximo se a 1 n√£o existir
          else break; // para no primeiro furo
        }
        frames.push({ id: 'f'+i, image: url });
      }
      return frames;
    }

    window.addEventListener('load', init);
  </script>
</body>
</html>