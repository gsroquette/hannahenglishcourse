<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Story Sequencer — Ordene a História (Layout Vertical)</title>
  <style>
    /* === Mesmo body das outras atividades === */
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin-top: 50px;
      background-color: #f5f5f5;
      background-image: url('../../../imagens/fundo.png');
      background-repeat: repeat;
      background-size: auto;
      padding: 0 20px;
    }

    :root{
      --brand:#ff6b00; --ok:#2e7d32; --warn:#c62828; --ink:#222;
      --slot:#ffffff; --slot-border:#bbb; --tile:#fff; --tile-border:#333;
      --shadow: 0 6px 18px rgba(0,0,0,.08);
    }
    *{ box-sizing:border-box }

    header{
      padding:12px 16px; display:flex; align-items:center; gap:12px; justify-content:center;
      margin: 0 auto 8px; max-width:1100px;
    }
    header h1{ font-size:1.2rem; margin:0; font-weight:700 }
    .pill { padding:6px 12px; border-radius:999px; background:#fff; border:1px solid #eee; font-size:.85rem; box-shadow: var(--shadow) }

    .wrap{ width:min(1100px, 100%); margin:0 auto 24px; display:flex; flex-direction:column; gap:12px }

    /* Mini-mapa (ancoras 1..N) */
    .minimap{
      position: sticky; top: 0; z-index: 5;
      background: rgba(245,245,245,.9);
      padding: 6px 8px; border-radius: 12px; border:1px solid #eee;
      display:flex; gap:8px; overflow:auto; justify-content:center;
      backdrop-filter: blur(2px);
    }
    .dot{
      width:28px; height:28px; border-radius:999px; border:1px solid #ddd; background:#fff; box-shadow: var(--shadow);
      display:flex; align-items:center; justify-content:center; font-size:.85rem; cursor:pointer; user-select:none;
    }
    .dot.filled{ border-color:#999 }
    .dot.focus{ outline:2px solid var(--brand) }

    .controls{ display:flex; gap:10px; justify-content:center; flex-wrap:wrap }
    .btn{
      appearance:none; border:1px solid #ddd; background:#fff; padding:10px 14px; border-radius:12px; cursor:pointer;
      font-weight:600; box-shadow:var(--shadow); transition:.15s transform ease;
    }
    .btn:active{ transform:translateY(1px) }
    .btn.primary{ background:var(--brand); color:#fff; border-color:transparent }
    .btn.ghost{ background:#fff }
    .btn.toggle[aria-pressed="true"]{ outline:2px solid var(--brand) }

    .cols{
      display:grid; gap:14px;
      grid-template-columns: 1fr; /* mobile empilhado */
    }
    @media (min-width: 900px){
      .cols{ grid-template-columns: 1fr 1fr; align-items:start }
    }

    /* Linha do tempo: lista vertical de cartões */
    .timelineCol, .poolCol{
      background:#fff; border:1px dashed #ddd; padding:12px; border-radius:16px; box-shadow:var(--shadow);
      text-align: left;
    }
    .sectionTitle{ margin:6px 0 10px; font-weight:700; text-align:left }

    .slotCard{
      display:grid; grid-template-columns: 44px 110px 1fr; gap:10px;
      align-items:center; padding:10px; border:1px solid #eee; border-radius:12px; background:#fff; margin-bottom:10px;
    }
    .slotNum{
      width:44px; height:44px; border-radius:12px; background:#fafafa; border:1px solid #ddd; display:flex; align-items:center; justify-content:center; font-weight:700;
    }
    .slot{
      width:110px; height:110px; background:#fafafa; border:2px dashed var(--slot-border); border-radius:12px;
      display:flex; align-items:center; justify-content:center; position:relative; overflow:hidden;
    }
    .slot.filled{ border-style:solid; border-color:#aaa }
    .slot.correct{ outline:3px solid var(--ok) }
    .slot.wrong{ animation:shake .25s linear }
    @keyframes shake{ 0%{ transform:translateX(0) } 25%{ transform:translateX(-4px) } 50%{ transform:translateX(4px) } 75%{ transform:translateX(-2px) } 100%{ transform:translateX(0) } }

    .slotText{
      font-size:.9rem; color:#222;
      display:-webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow:hidden;
      white-space:normal;
    }
    .tile{
      background:var(--tile); border:2px solid var(--tile-border); border-radius:12px; overflow:hidden; cursor:grab; position:relative;
      display:flex; align-items:center; justify-content:center; height:100%; width:100%; user-select:none;
    }
    .tile img{ max-width:100%; max-height:100%; display:block }

    .ret-btn{
      position:absolute; top:6px; right:6px; width:24px; height:24px; border-radius:999px; border:1px solid #ddd; background:#fff; font-size:14px; line-height:22px; box-shadow: var(--shadow); cursor:pointer
    }

    /* Pool: lista/grade vertical rolável */
    .poolList{
      max-height: 55vh; overflow:auto; display:grid; grid-template-columns: repeat(auto-fill, minmax(94px, 1fr)); gap:10px;
    }
    @media (max-width: 480px){
      .poolList{ grid-template-columns: repeat(3, 1fr); }
    }
    .poolTile{
      height:94px; border:2px solid var(--tile-border); border-radius:12px; overflow:hidden; background:#fff; display:flex; align-items:center; justify-content:center; position:relative;
    }

    /* Touch helpers */
    .tile, .slot{ touch-action: manipulation; -webkit-tap-highlight-color: transparent; }
    .selected{ outline:3px solid var(--brand) }

    /* Modal */
    .modal{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.4); z-index:50 }
    .modal.open{ display:flex }
    .card{ background:#fff; border-radius:20px; padding:20px; width:min(520px, 92vw); text-align:center; box-shadow:var(--shadow) }
    .card h2{ margin:0 0 8px }
  </style>
</head>
<body>
  <header>
    <span class="pill" id="crumbs">Level — Unit — …</span>
    <h1 id="title">Story Sequencer</h1>
  </header>

  <div class="wrap">
    <div class="minimap" id="miniMap" aria-label="Mapa da sequência"></div>

    <div class="controls" role="toolbar" aria-label="Controles">
      <button class="btn primary" id="btnCheck">Check</button>
      <button class="btn ghost" id="btnReset" title="Limpar e reembaralhar">Reset</button>
      <button class="btn ghost" id="btnHint" title="Revelar próximo slot correto">Hint</button>
      <button class="btn toggle" id="btnText" aria-pressed="true">Texto</button>
      <button class="btn ghost" id="btnFull">Tela cheia</button>
    </div>

    <div class="cols">
      <section class="timelineCol">
        <p class="sectionTitle">Linha do tempo</p>
        <div id="timelineList"></div>
      </section>

      <section class="poolCol">
        <p class="sectionTitle">Imagens (embaralhadas)</p>
        <div id="poolList" class="poolList"></div>
      </section>
    </div>
  </div>

  <div id="modalWin" class="modal" role="dialog" aria-modal="true" aria-labelledby="winTitle">
    <div class="card">
      <h2 id="winTitle">Muito bem!</h2>
      <p>Você colocou a história na ordem correta.</p>
      <button class="btn primary" id="btnCloseWin">Continuar</button>
    </div>
  </div>

  <script>
    // ===== Utils
    var qs = function(s, el){ return (el||document).querySelector(s); };
    var qsa = function(s, el){ return Array.prototype.slice.call((el||document).querySelectorAll(s)); };
    var shuffle = function(arr){ var a=arr.slice(); for(var i=a.length-1;i>0;i--){ var j=Math.floor(Math.random()*(i+1)); var t=a[i]; a[i]=a[j]; a[j]=t; } return a; };

    function getParams(){
      var url = new URL(location.href);
      var level = url.searchParams.get('level');
      var unit = url.searchParams.get('unit');
      var fase = url.searchParams.get('fase') || 'seq';
      if(!level || !unit){ alert('Missing URL params: level, unit'); }
      return {level:level, unit:unit, fase:fase};
    }
    function storageKey(meta){ return 'sequencer:'+meta.level+':'+meta.unit+':'+meta.fase+':vertical'; }

    // ===== Global state
    var state = {
      meta:null,
      frames:[],       // [{id, image}]
      orderIds:[],     // ['f1','f2',...]
      poolIds:[],      // ids no pool
      slots:[],        // ids nos slots (ou null)
      storyTitle:null,
      storyTexts:[],   // texto correto por índice
      showText:true,
      stats:{ start: Date.now(), checks:0, hints:0 }
    };

    function frameById(id){ return state.frames.find(function(f){ return f.id===id; }); }

    // ===== Rendering
    function renderCrumbs(){
      var m = state.meta;
      qs('#crumbs').textContent = 'Level '+m.level+' · Unit '+m.unit;
      qs('#title').textContent = state.storyTitle || 'Story Sequencer';
    }

    function renderMiniMap(){
      var mm = qs('#miniMap'); mm.innerHTML = '';
      for(var i=0;i<state.orderIds.length;i++){
        var d = document.createElement('button');
        d.className = 'dot'+(state.slots[i]?' filled':'');
        d.type='button'; d.textContent = (i+1);
        (function(idx){
          d.addEventListener('click', function(){
            var card = qs('[data-slot-card="'+idx+'"]');
            if(card){ card.scrollIntoView({behavior:'smooth', block:'center'}); }
            qsa('.dot').forEach(function(x){ x.classList.remove('focus'); });
            d.classList.add('focus');
            setTimeout(function(){ d.classList.remove('focus'); }, 800);
          });
        })(i);
        mm.appendChild(d);
      }
    }

    function renderBoard(){
      renderMiniMap();

      var list = qs('#timelineList'); list.innerHTML='';
      for(var i=0;i<state.orderIds.length;i++){
        var idPlaced = state.slots[i];

        var card = document.createElement('div');
        card.className = 'slotCard';
        card.setAttribute('data-slot-card', i);

        var num = document.createElement('div');
        num.className='slotNum'; num.textContent = (i+1);
        card.appendChild(num);

        var slot = document.createElement('div');
        slot.className='slot'+(idPlaced?' filled':'');
        slot.setAttribute('data-idx', i);

        if(idPlaced){
          var fr = frameById(idPlaced);
          if(fr){
            var tile = makeTile(fr, true); // in slot
            slot.appendChild(tile);
          }
        }
        // touch: tocar slot com peça selecionada
        slot.addEventListener('pointerdown', handleSlotTap);
        // desktop DnD
        slot.addEventListener('dragover', function(e){ e.preventDefault(); });
        slot.addEventListener('drop', function(e){
          e.preventDefault();
          var id = e.dataTransfer.getData('text/plain');
          if(id) placeIdIntoSlot(id, parseInt(this.getAttribute('data-idx'),10));
        });

        card.appendChild(slot);

        var txt = document.createElement('div');
        txt.className='slotText';
        if(state.showText){ txt.textContent = (state.storyTexts[i]||''); } else { txt.textContent=''; }
        card.appendChild(txt);

        list.appendChild(card);
      }

      var pool = qs('#poolList'); pool.innerHTML='';
      // desktop drop para devolver
      pool.addEventListener('dragover', function(e){ e.preventDefault(); });
      pool.addEventListener('drop', function(e){ e.preventDefault(); var id=e.dataTransfer.getData('text/plain'); if(id) returnToPool(id); });

      // toque no fundo do pool devolve a peça selecionada
      pool.addEventListener('pointerdown', function(e){
        if(!selectedId) return;
        if(e.target.closest('.poolTile') || e.target.closest('.tile')) return; // não interferir
        returnToPool(selectedId);
        clearSelection();
      });

      state.poolIds.forEach(function(id){
        var fr = frameById(id); if(!fr) return;
        var wrap = document.createElement('div');
        wrap.className='poolTile'; wrap.setAttribute('data-id', id);

        var tile = makeTile(fr, false);
        wrap.appendChild(tile);
        pool.appendChild(wrap);
      });
    }

    function makeTile(frame, inSlot){
      var t = document.createElement('div');
      t.className='tile'; t.setAttribute('data-id', frame.id);

      // DnD só em pointer:fine (desktop)
      var enableDrag = window.matchMedia && window.matchMedia('(pointer:fine)').matches;
      if(enableDrag){ t.draggable = true; t.addEventListener('dragstart', function(e){ e.dataTransfer.setData('text/plain', frame.id); }); }

      var img = document.createElement('img'); img.src = frame.image; img.alt = 'frame'; t.appendChild(img);

      // toque/cliquer para selecionar
      t.addEventListener('pointerdown', function(e){
        e.stopPropagation();
        selectTile(t);
      });

      // botão ↩ no slot
      if(inSlot){
        var ret = document.createElement('button');
        ret.className='ret-btn'; ret.type='button'; ret.title='Voltar ao embaralhado'; ret.textContent='↩';
        ret.addEventListener('pointerdown', function(ev){ ev.stopPropagation(); returnToPool(frame.id); });
        t.appendChild(ret);
      }
      return t;
    }

    // ===== Interação
    var selectedId = null;
    function selectTile(tile){
      var id = tile.getAttribute('data-id');
      if(selectedId === id){ clearSelection(); return; }
      selectedId = id;
      qsa('.tile').forEach(function(el){ el.classList.remove('selected'); });
      tile.classList.add('selected');
    }
    function clearSelection(){
      selectedId = null;
      qsa('.tile').forEach(function(el){ el.classList.remove('selected'); });
    }

    function handleSlotTap(e){
      var idx = parseInt(this.getAttribute('data-idx'),10);
      if(selectedId){ placeIdIntoSlot(selectedId, idx); clearSelection(); }
    }

    function placeIdIntoSlot(id, idx){
      var currentIdx = state.slots.findIndex(function(v){ return v===id; });
      if(currentIdx === idx) return;

      if(currentIdx !== -1){
        // mover entre slots (swap)
        var targetId = state.slots[idx];
        state.slots[idx] = id;
        state.slots[currentIdx] = targetId || null;
      } else {
        // pool -> slot (talvez swap)
        var occupant = state.slots[idx];
        state.slots[idx] = id;
        // remove id do pool
        state.poolIds = state.poolIds.filter(function(x){ return x!==id; });
        if(occupant){ state.poolIds.push(occupant); }
      }
      persistAndRender();
    }

    function returnToPool(id){
      var idx = state.slots.findIndex(function(v){ return v===id; });
      if(idx !== -1){
        state.slots[idx] = null;
        if(state.poolIds.indexOf(id)===-1) state.poolIds.push(id);
        persistAndRender();
      }
    }

    function persistAndRender(){
      saveState(storageKey(state.meta), {
        slots:state.slots, poolIds:state.poolIds, stats:state.stats, showText:state.showText
      });
      renderBoard();
    }

    // ===== Controles
    function checkSequence(){
      state.stats.checks++;
      var ok = true;
      var cards = qsa('.slot');
      for(var i=0;i<state.orderIds.length;i++){
        var id = state.slots[i];
        cards[i].classList.remove('correct','wrong');
        if(!id){ ok=false; continue; }
        if(id===state.orderIds[i]){ cards[i].classList.add('correct'); }
        else { cards[i].classList.add('wrong'); ok=false; }
      }
      setTimeout(function(){ cards.forEach(function(c){ c.classList.remove('correct','wrong'); }); }, 800);
      if(ok) onWin();
    }

    function doReset(){
      var ids = state.orderIds.slice();
      state.poolIds = shuffle(ids);
      state.slots = new Array(ids.length).fill(null);
      state.stats = { start: Date.now(), checks:0, hints:0 };
      persistAndRender();
    }

    function doHint(){
      var n = state.orderIds.length, targetIdx=-1;
      for(var i=0;i<n;i++){ if(state.slots[i] !== state.orderIds[i]){ targetIdx=i; break; } }
      if(targetIdx===-1) return;
      state.stats.hints++;
      var correctId = state.orderIds[targetIdx];
      var where = state.slots.findIndex(function(v){ return v===correctId; });
      if(where!==-1){
        var tmp = state.slots[targetIdx];
        state.slots[targetIdx]=correctId;
        state.slots[where]=tmp||null;
      } else {
        state.poolIds = state.poolIds.filter(function(x){ return x!==correctId; });
        var occ = state.slots[targetIdx]; if(occ) state.poolIds.push(occ);
        state.slots[targetIdx]=correctId;
      }
      // destaque visual
      var slot = qs('.slot[data-idx="'+targetIdx+'"]');
      if(slot){ slot.classList.add('correct'); setTimeout(function(){ slot.classList.remove('correct'); }, 900); }
      persistAndRender();
    }

    function toggleText(){
      state.showText = !state.showText;
      qs('#btnText').setAttribute('aria-pressed', String(state.showText));
      persistAndRender();
    }

    function toggleFullscreen(){
      var el = document.documentElement;
      var isFs = document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
      if(!isFs){
        (el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen || function(){}) .call(el);
      } else {
        (document.exitFullscreen || document.webkitExitFullscreen || document.msExitFullscreen || function(){}) .call(document);
      }
    }

    function onWin(){
      qs('#modalWin').classList.add('open');
      try{
        if(window.updateNextPhase && window.currentUserId){ window.updateNextPhase(window.currentUserId); }
        if(window.logActivity){ window.logActivity({ type:'story-sequencer-vertical', meta:state.meta, stats:state.stats }); }
      }catch(e){}
    }

    // ===== Storage
    function saveState(key, obj){ try{ localStorage.setItem(key, JSON.stringify(obj)); }catch(e){} }
    function loadState(key){ try{ return JSON.parse(localStorage.getItem(key) || 'null'); }catch(e){ return null; } }

    // ===== Data loading
    function imageExists(url){
      return new Promise(function(res){
        var img = new Image();
        img.onload = function(){ res(true); };
        img.onerror = function(){ res(false); };
        img.src = url + (url.indexOf('?')>-1?'&':'?') + 'v=' + Date.now();
      });
    }

    async function loadSequentialImages(base, start, max){
      var frames = [];
      for(var i=start;i<=max;i++){
        var url = base + 'imagem' + i + '.png';
        /* eslint-disable no-await-in-loop */
        var ok = await imageExists(url);
        if(!ok){
          if(i===start){ continue; } else { break; }
        }
        frames.push({ id:'f'+i, image:url });
      }
      return frames;
    }

    async function loadStoryText(base){
      var names = ['images.txt','imagens.txt'];
      for(var i=0;i<names.length;i++){
        try{
          var res = await fetch(base + names[i] + '?v=' + Date.now());
          if(!res.ok) continue;
          var raw = await res.text();
          return parseImagesTxt(raw);
        }catch(e){}
      }
      return null;
    }

    function parseImagesTxt(raw){
      var lines = raw.split(/\r?\n/);
      var title = null;
      var frames = [];
      var current = null;
      for(var i=0;i<lines.length;i++){
        var line = (lines[i]||'').trim();
        if(!line) continue;
        var mTitle = line.match(/^#title:\s*(.+)$/i);
        if(mTitle){ title = mTitle[1].trim(); continue; }
        var mImg = line.match(/^#(imagem|image)(\d+)$/i);
        if(mImg){
          var idx = parseInt(mImg[2],10) - 1;
          current = { idx:idx, text:[] };
          frames[idx] = current;
          continue;
        }
        if(current){ current.text.push(line.replace(/^"|"$/g, '')); }
      }
      var ordered = [];
      for(var j=0;j<frames.length;j++){
        ordered[j] = frames[j] ? frames[j].text.join(' ').trim() : '';
      }
      return { title:title, frames:ordered };
    }

    // ===== Bootstrap
    window.addEventListener('load', init);
    async function init(){
      state.meta = getParams();
      var key = storageKey(state.meta);

      var imgBase = '/' + state.meta.level + '/' + state.meta.unit + '/DataStory/images/';
      var txtBase = '/' + state.meta.level + '/' + state.meta.unit + '/DataStory/';
      qs('#crumbs').setAttribute('title', 'Imagens em: ' + imgBase);

      state.frames = await loadSequentialImages(imgBase, 1, 30);
      if(!state.frames.length){
        alert('Nenhuma imagem encontrada em ' + imgBase + ' (esperado: imagem1.png, imagem2.png, ...)');
        return;
      }
      state.orderIds = state.frames.map(function(f){ return f.id; });

      var story = await loadStoryText(txtBase);
      if(story){ state.storyTitle = story.title; state.storyTexts = story.frames; }

      var saved = loadState(key);
      if(saved && Array.isArray(saved.slots) && Array.isArray(saved.poolIds)){
        state.slots = saved.slots;
        state.poolIds = saved.poolIds;
        state.stats = saved.stats || state.stats;
        state.showText = (typeof saved.showText === 'boolean') ? saved.showText : true;
      } else {
        state.poolIds = shuffle(state.orderIds.slice());
        state.slots = new Array(state.orderIds.length).fill(null);
      }

      renderCrumbs();
      renderBoard();

      // Controles
      qs('#btnCheck').addEventListener('click', checkSequence);
      qs('#btnReset').addEventListener('click', doReset);
      qs('#btnHint').addEventListener('click', doHint);
      qs('#btnText').addEventListener('click', toggleText);
      qs('#btnFull').addEventListener('click', toggleFullscreen);
      qs('#btnCloseWin').addEventListener('click', function(){ qs('#modalWin').classList.remove('open'); });
    }
  </script>
</body>
</html>
