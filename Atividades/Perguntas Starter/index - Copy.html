<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Q&A Kids – Hannah Neurolearning</title>
<style>
  :root{
    --bg:#f7f9fc;
    --card:#ffffff;
    --text:#1f2937;
    --muted:#6b7280;
    --ok:#16a34a;
    --warn:#ef4444;
    --brand:#2563eb;
    --shadow:0 10px 25px rgba(0,0,0,.08);
    --radius:18px;
  }

  *{box-sizing:border-box}

 body{
  margin:0;
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,'Helvetica Neue',Arial;
  background: url('../../imagens/fundo.png') center/cover no-repeat, var(--bg);
  color:var(--text);
  display:flex;
  min-height:100dvh;
  align-items:center;
  justify-content:center;
  padding:16px;
}

  .app{
    width:min(980px,100%);
    background:var(--card);
    border-radius:var(--radius);
    box-shadow:var(--shadow);
    padding:20px;
    position:relative;
    overflow:hidden;
  }

  .header{
    display:flex;
    align-items:center;
    gap:12px;
    margin-bottom:14px;
  }

  .avatar{
  width:54px; height:54px; border-radius:50%;
  background:#e5f0ff; border:2px solid #cfe0ff;
  display:flex; align-items:center; justify-content:center;
  overflow:hidden;                /* importante para “clipar” a imagem no círculo */
}
.avatar img{
  width:100%; height:100%;
  object-fit:contain;             /* não corta o robô */
  border-radius:50%;
  display:block;
}

  .title-wrap{flex:1}
  .title{font-weight:700; font-size:20px}
  .subtitle{color:var(--muted); font-size:14px}

  .progress{
    height:8px;
    background:#eef2f7;
    border-radius:999px;
    overflow:hidden;
    margin-top:8px;
  }
  .progress > div{
    height:100%;
    width:0%;
    background:linear-gradient(90deg,#60a5fa,#34d399);
    transition:width .3s ease;
  }

  .stage{display:grid; gap:16px; grid-template-columns:1fr}

  .question-card{
    background:#f9fbff;
    border:1px solid #e5eaf5;
    border-radius:16px;
    padding:16px;
  }

  .q-top{
    display:grid;
    grid-template-columns: 1.2fr .8fr;
    gap:16px;
  }

  .q-prompt{
    font-size:22px;
    font-weight:700;
    line-height:1.25;
    display:flex;
    align-items:center;
    gap:10px;
  }

  /* === Media grande da pergunta (sem cortes) === */
  .q-media{
  width:100%;
  aspect-ratio:16/10;
  background:#eef4ff;
  border:1px dashed #cfe0ff;
  border-radius:14px;
  padding:8px;                 /* padding vai no container, não no <img> */
  overflow:hidden;
  display:block;               /* flex não é necessário aqui */
}
.q-media img{
  width:100%;                  /* define ambas as dimensões */
  height:100%;
  object-fit:contain;          /* agora o contain funciona em todo browser */
  display:block;
  /* nada de padding no <img> */
}

/* Fallback para Safari antigo/Android antigo que não tem aspect-ratio */
@supports not (aspect-ratio: 16/10){
  .q-media{ height: 220px; }   /* ajuste este valor se quiser mais/menos alto */
}

  .q-controls{display:flex; gap:8px; align-items:center; margin-top:8px}

  .icon-btn{
    border:none;
    background:#e6f0ff;
    color:#0f3ea8;
    padding:10px 12px;
    border-radius:12px;
    cursor:pointer;
    font-weight:700;
  }
  .icon-btn:active{transform:translateY(1px)}

  .options{
    display:grid;
    gap:12px;
    margin-top:4px;
    grid-template-columns:repeat(2,1fr);
  }
  @media (max-width:720px){
    .q-top{grid-template-columns:1fr}
    .options{grid-template-columns:1fr}
  }

  .option{
    display:flex;
    align-items:center;
    gap:12px;
    background:#ffffff;
    border:2px solid #e9eef7;
    border-radius:18px;
    padding:14px;
    cursor:pointer;
    user-select:none;
    min-height:84px;
    box-shadow:0 4px 12px rgba(0,0,0,.03);
    transition:transform .06s ease, border-color .15s ease, box-shadow .15s ease;
  }
  .option:hover{transform:translateY(-1px); box-shadow:0 8px 18px rgba(0,0,0,.06)}
  .option:active{transform:translateY(0)}

  /* Miniatura nas opções (sem cortar) */
  .option .thumb{
    width:68px; height:68px;
    border-radius:14px;
    background:#f3f6ff;
    border:1px solid #e6ecfb;
    overflow:hidden;
    display:flex;               /* centraliza melhor que grid */
    align-items:center;
    justify-content:center;
    font-size:30px;
    flex:0 0 68px;
  }
  .option .thumb img{
    width:100%; height:100%;
    object-fit:contain;         /* não corta mais ícones (ex.: apple) */
    padding:6px;
    display:block;
  }

  .option .label{font-size:20px; font-weight:800; letter-spacing:.2px}
  .option .sub{font-size:13px; color:var(--muted)}
  .option.ok{border-color:#86efac; animation:okPulse .4s ease}
  .option.err{border-color:#fecaca; animation:shake .22s ease}

  @keyframes okPulse{
    0%{box-shadow:0 0 0 0 rgba(34,197,94,.4)}
    100%{box-shadow:0 0 0 18px rgba(34,197,94,0)}
  }
  @keyframes shake{
    0%{transform:translateX(0)}
    25%{transform:translateX(-4px)}
    50%{transform:translateX(4px)}
    75%{transform:translateX(-3px)}
    100%{transform:translateX(0)}
  }

  .footer{
    margin-top:8px;
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:8px;
  }

  .pill{
    background:#eef2ff;
    color:#3949ab;
    padding:8px 12px;
    border-radius:999px;
    font-size:12px;
    border:1px solid #d7defc;
  }

  .next-btn{
    border:none;
    background:linear-gradient(90deg, #3b82f6, #22c55e);
    color:white;
    font-weight:800;
    padding:12px 16px;
    border-radius:14px;
    cursor:pointer;
    box-shadow:0 10px 18px rgba(34,197,94,.25);
    opacity:.3;
    pointer-events:none;
    transition:opacity .2s ease, transform .06s ease;
  }
  .next-btn.ready{opacity:1; pointer-events:auto}
  .next-btn:active{transform:translateY(1px)}

  /* Confete simples */
  .confetti{position:absolute; inset:0; pointer-events:none; overflow:hidden}
  .piece{
    position:absolute; width:10px; height:10px;
    background:hsl(var(--h) 80% 60%);
    top:-12px; border-radius:2px; animation:drop linear forwards;
  }
  @keyframes drop{to{transform:translateY(120vh) rotate(540deg)}}

  .toast{
    position:fixed; left:50%; bottom:24px; transform:translateX(-50%);
    background:#111827; color:white; padding:10px 14px;
    border-radius:12px; font-size:14px; box-shadow:var(--shadow); opacity:.96;
  }

  .sr-only{
    position:absolute; width:1px; height:1px; padding:0; margin:-1px;
    overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0;
  }

  /* ORDER (tap-to-build) */
  .build-wrap{margin-top:8px}
  .build-tray{
    min-height:56px;
    background:#eef4ff;
    border:2px dashed #cfe0ff;
    border-radius:14px;
    padding:10px;
    display:flex; flex-wrap:wrap; gap:8px; align-items:center;
  }
  .word-chip{
    background:#fff;
    border:2px solid #dbe5ff;
    border-radius:12px;
    padding:8px 12px;
    font-weight:800;
    box-shadow:0 2px 6px rgba(0,0,0,.05);
    user-select:none;
  }
  .build-actions{display:flex; gap:8px; margin-top:8px}
  .build-btn{
    border:none; background:#e6f0ff; color:#0f3ea8;
    padding:8px 12px; border-radius:10px; cursor:pointer; font-weight:700;
  }
  .build-btn:active{transform:translateY(1px)}

  /* MATCH */
  .match-grid{display:grid; grid-template-columns:1fr 1fr; gap:14px; margin-top:8px}
  .match-col{display:flex; flex-direction:column; gap:12px}
  .option.selected{outline:3px solid #60a5fa}
  .option.matched{border-color:#86efac; opacity:.65; pointer-events:none}

  /* Lacuna visual para fillblank (não lida pelo TTS) */
  .blank{
    display:inline-block; min-width:56px; height:1em;
    border-bottom:3px solid #cfe0ff;
    margin:0 6px -2px;
  }
/* Quadrado padrão (já deve existir; só acrescente/ajuste transições) */
.square-outline{
  width:42px; height:42px;
  border:6px solid var(--sq, #3b82f6);
  border-radius:10px;              /* tire se quiser cantos retos */
  background:transparent;
  display:inline-block;
  position:relative;
  transition: border-color .2s ease, background .2s ease, transform .15s ease;
}

/* Quando a resposta estiver correta (o botão ganha .ok), mostra o tique */
.option.ok .square-outline{
  border-color:#16a34a;            /* verde */
  background:#dcfce7;              /* verdinho suave */
}

.option.ok .square-outline::after{
  content:"✔";
  position:absolute;
  inset:0;
  display:flex; align-items:center; justify-content:center;
  color:#166534;                    /* verde escuro do tique */
  font-size:22px; font-weight:900;
  animation:pop-in .18s ease-out;
}

/* (Opcional) feedback para erro também no quadrado */
.option.err .square-outline{
  border-color:#ef4444;
  background:#fee2e2;
}

/* Animação do tique */
@keyframes pop-in{
  from{ transform:scale(.6); opacity:0 }
  to{   transform:scale(1);  opacity:1 }
}
/* para “desativado” */
.icon-btn[disabled]{ opacity:.4; pointer-events:none; }
/* para esconder completamente */
.is-hidden{ display:none !important; }
/* ====== ORDER (grade de palavras) ====== */
.build-grid{
  display:grid;
  gap:12px;
  grid-template-columns: repeat(2, minmax(0,1fr));
}

/* ====== Ajustes gerais de mobile ====== */
@media (max-width:540px){

  /* Quadro de mídia um pouco mais alto e com menos margem interna */
  .q-media{ aspect-ratio: 4/3; padding:6px; }

  /* Botões mais compactos */
  .option{ min-height:68px; padding:12px; }
  .option .thumb{ width:56px; height:56px; }
  .option .label{ font-size:18px; }

  /* ORDER: força 1 coluna quando a tela é estreita */
  .build-grid{
    grid-template-columns: 1fr;
  }

  /* MATCH: empilha colunas (esquerda em cima, direita embaixo) */
  .match-grid{
    grid-template-columns: 1fr;
    gap:10px;
  }
  .match-col{ gap:10px; }
}

/* Telas bem baixas (ex.: smartphones pequenos em landscape):
   limita a altura do bloco de opções e habilita scroll interno */
@media (max-height:700px) and (max-width:540px){
  .options{
    max-height: 44vh;
    overflow:auto;
    padding-right: 2px; /* evita o conteúdo colar na borda com a barra de rolagem */
  }
}

/* Evita rótulos quebrarem layout em telas estreitas */
.option .label{ word-break: break-word; }
@media (max-width:540px){
  .q-prompt{ font-size:20px; }
}
</style>
</head>
<body>
  <div class="app" id="app">
    <div class="confetti" id="confetti"></div>

    <div class="header">
      <div class="avatar" id="avatar" aria-hidden="true">🤖</div>
      <div class="title-wrap">
        <div class="title">Hannah Questions</div>
        <div class="subtitle" id="subtitle">Carregando conteúdo…</div>
        <div class="progress"><div id="bar"></div></div>
      </div>
      <div class="pill" id="pill">Unit —</div>
    </div>

    <div class="stage">
      <div class="question-card">
        <div class="q-top">
          <div>
            <div class="q-prompt" id="prompt">—</div>
            <div class="q-controls">
              <button class="icon-btn" id="btnPlayPrompt" title="Listen to question">🔊 Listen</button>
              <button class="icon-btn" id="btnRepeat" title="Repeat aloud (optional)">🎤 Repeat</button>
            </div>
          </div>
          <div class="q-media" id="mediaBox" aria-label="Imagem da pergunta"></div>
        </div>

        <div class="options" id="options"></div>

        <div class="footer">
          <span class="pill" id="statusPill">Question —/—</span>
          <button class="next-btn" id="btnNext" disabled>Next</button>
        </div>
      </div>
    </div>
  </div>

  <div class="sr-only" aria-live="polite" id="live"></div>

<script>
(function(){
  // ====== Util: query params (level & unit) ======
  const params = new URLSearchParams(location.search);
  const level = params.get('level') || 'starter';
  const unit  = params.get('unit')  || '1';

  // Base para assets e arquivo:
  // Ex.: ../../starter/1/QA/questions.txt
   const BASE = `../../Level${level}/Unit${unit}/QA`;
   const QFILE = `${BASE}/questions.txt`;


  // ====== Estado ======
  let questions = [];
// --- controle global de fala/áudio ---
let isReading = false;   // indica se está lendo/tocando um item agora
let currentAudio = null; // referência do <audio> em reprodução (se houver)

function stopAllAudio(){
  // cancela qualquer TTS em andamento
  try { speechSynthesis.cancel(); } catch(e){}
  // para áudio de arquivo, se estiver tocando
  if (currentAudio){
    try { currentAudio.pause(); currentAudio.currentTime = 0; } catch(e){}
    currentAudio = null;
  }
}

  let idx = 0;
  let answered = false;   
  
  // ====== Elementos ======
  const subtitle = document.getElementById('subtitle');
  const pill = document.getElementById('pill');
  const bar = document.getElementById('bar');
  const promptEl = document.getElementById('prompt');
  const mediaBox = document.getElementById('mediaBox');
  const optionsEl = document.getElementById('options');
  const btnPlayPrompt = document.getElementById('btnPlayPrompt');
  const btnRepeat = document.getElementById('btnRepeat');
  const btnNext = document.getElementById('btnNext');
  const statusPill = document.getElementById('statusPill');
  const confettiEl = document.getElementById('confetti');
  const liveEl = document.getElementById('live');

(function(){
  const avatarEl = document.getElementById('avatar');
  const img = new Image();
  img.src = '../../imagens/robo1_static.png';  // ou '/imagens/robo1_static.png'
  img.alt = 'Mascote do app';
  img.onload = () => { avatarEl.textContent = ''; avatarEl.appendChild(img); };
  img.onerror = () => { avatarEl.textContent = '🤖'; }; // fallback
})();

  pill.textContent = `Level ${level} • Unit ${unit}`;

  // ====== Sons de feedback (padrões; você pode trocar pelos seus) ======
  const sCorrect = new Audio(`${BASE}/sounds/correct.mp3`); // opcional
  const sWrong   = new Audio(`${BASE}/sounds/wrong.mp3`);   // opcional
  const sTap     = new Audio(`${BASE}/sounds/tap.mp3`);     // opcional
  const sNext    = new Audio(`${BASE}/sounds/next.mp3`);    // opcional

  // Previne atraso em iOS
  [sCorrect,sWrong,sTap,sNext].forEach(a=>{a.preload='auto'});

  // ====== Carrega arquivo TXT (JSON) ======
  fetch(QFILE, {cache:'no-store'})
    .then(r => {
      if(!r.ok) throw new Error(`Não foi possível carregar ${QFILE}`);
      return r.text();
    })
    .then(text => {
      // O arquivo é .txt, mas o conteúdo é JSON válido (ver modelo abaixo)
      const data = JSON.parse(text);
      if(!data || !Array.isArray(data.questions)) throw new Error('Formato inválido em questions.txt');
      questions = data.questions;
      subtitle.textContent = data.title || 'Pratique respondendo rápido e com atenção!';      
      idx = 0;
      renderQuestion();
    })
    .catch(err=>{
      console.error(err);
      toast('Erro ao carregar questões. Verifique caminho/JSON.');
      subtitle.textContent = 'Falha ao carregar conteúdo';
    });

  // ====== Renderização de questão ======
  function renderQuestion(){
    answered = false;
    btnNext.disabled = true;
    btnNext.classList.remove('ready');
// garantir que os botões voltem quando for uma nova pergunta
btnPlayPrompt.disabled = false;
btnRepeat.disabled = false;
btnPlayPrompt.classList.remove('is-hidden');
btnRepeat.classList.remove('is-hidden');

    const q = questions[idx];
    if(!q){ finish(); return; }

    // Barra de progresso e status
    const pct = Math.round(((idx)/questions.length)*100);
    bar.style.width = pct + '%';
    statusPill.textContent = `Question ${idx+1}/${questions.length}`;

    // Prompt + áudio
    promptEl.textContent = q.prompt || '—';
// Mostra linha em vez de "___" (sem atrapalhar o TTS)
if (q.type === 'fillblank' && !/\_\_+/.test(q.prompt || '')) {
  const line = document.createElement('span');
  line.className = 'blank';
  promptEl.appendChild(document.createTextNode(' '));
  promptEl.appendChild(line);
}
    btnPlayPrompt.onclick = () => {
  if (isReading) return;     // não toca se já estiver lendo algo
  playPrompt(q);             // usa o mp3 se existir, senão TTS (já tratado em playPrompt)
};

btnRepeat.onclick = () => {
  if (isReading) return;     // evita “tilt” com cliques seguidos
  stopAllAudio();            // para qualquer áudio/voz atual
  const t = q.targetWord || q.tts || q.prompt || '';
  speak(t);                  // fala apenas o texto (TTS)
};

    // Mídia principal (imagem da pergunta opcional)
    mediaBox.innerHTML = '';
    if(q.image){
      const img = new Image();
      img.alt = 'Imagem da pergunta';
      img.src = absPath(q.image);
      mediaBox.appendChild(img);
    } else {
  const img = new Image();
  img.src = './hannah_pensando.png';   // como está na mesma pasta do index.html
  img.alt = 'Hannah pensando';
  mediaBox.appendChild(img);
}

    // Opções
    optionsEl.innerHTML = '';

if (q.type === 'order') {
  renderOrderQuestion(q);
} else if (q.type === 'match') {
  renderMatchQuestion(q);
} else {
  const opts = (q.shuffleOptions===false) ? q.options : shuffle([...q.options]);
  opts.forEach(opt => {
    const node = makeOption(q, opt);
    optionsEl.appendChild(node);
  });
}

// Avançar
btnNext.onclick = () => {
  sNext.play().catch(()=>{});
  idx++;
  if (idx >= questions.length) { finish(); return; }
  renderQuestion();
};
}

  // ====== Cria um botão de opção (imagem + texto + áudio opcionais) ======
  function makeOption(q, opt){
  // Normaliza: permite ["dog","cat"] ou [{label:"Dog", value:"dog"}, ...]
  const o = (typeof opt === 'string') ? { label: opt, value: opt } : { ...opt };

  const btn = document.createElement('button');
  btn.type = 'button';
  btn.className = 'option';
  btn.setAttribute('aria-label', o.aria || o.label || 'opção');

  const thumb = document.createElement('div');
  thumb.className = 'thumb';
 if (o.image){
  const img = new Image();
  img.src = absPath(o.image);
  img.alt = o.label || '';
  thumb.appendChild(img);
} else if (o.emoji){
  // se a opção tiver emoji no JSON, usa o emoji
  thumb.textContent = o.emoji;
} else {
  // fallback: quadrado sem preenchimento com borda grossa
  const box = document.createElement('span');
  box.className = 'square-outline';
  // cor da borda (opcional): azul = #3b82f6 | roxo = #7c3aed/#8b5cf6
  box.style.setProperty('--sq', '#7c3aed'); // roxo grosso
  thumb.textContent = '';
  thumb.appendChild(box);
}

  const textWrap = document.createElement('div');
  const label = document.createElement('div');
  label.className = 'label';
  label.textContent = o.label || '';
  textWrap.appendChild(label);

  if (typeof o.sub === 'string' && o.sub.trim()) {
    const sub = document.createElement('div');
    sub.className = 'sub';
    sub.textContent = o.sub;
    textWrap.appendChild(sub);
  }

  btn.appendChild(thumb);
  btn.appendChild(textWrap);

  btn.onclick = () => {
  sTap.play().catch(()=>{});
  speakSelectedThenCheck(q, o, btn);
};

  // Clique no thumb: falar a opção e contar a tentativa (igual ao botão)
thumb.style.cursor = 'pointer';
thumb.title = 'Play & choose';
thumb.onclick = (e) => {
  e.preventDefault();
  e.stopPropagation();
  sTap.play().catch(()=>{});
  speakSelectedThenCheck(q, o, btn);
};

  return btn;
}

  // ====== Lógica de resposta ======
  function handleAnswer(q, opt, btn){
    if(answered) return; // evita múltiplos cliques
    const isCorrect = normalize(opt.value) === normalize(q.answer);

    if(isCorrect){
      btn.classList.add('ok');
      confetti(18);
      sCorrect.play().catch(()=>{});
      speakFriendly(['Yes! Great job!','Awesome!','You did it!']);
try {
  mediaBox.innerHTML = '';
  const gif = new Image();
  gif.src = './hannah_feliz.gif';
  gif.alt = 'Hannah comemorando';
  gif.setAttribute('draggable','false');   // evita arrastar a imagem
  gif.style.pointerEvents = 'none';        // evita clique “pegar” foco
  mediaBox.appendChild(gif);
} catch(e){}
      liveEl.textContent = 'Resposta correta';
      answered = true;
      btnNext.disabled = false;
      btnNext.classList.add('ready');
      // Desabilita outras opções
      disableOthers(btn);
    } else {
      btn.classList.add('err');
      sWrong.play().catch(()=>{});
      speakFriendly(['Hmm… try again!','Not this one!','Almost!']);
      liveEl.textContent = 'Resposta incorreta, tente novamente';
      // Não trava: criança pode tentar outra
    }
  }

  function disableOthers(keepBtn){
    Array.from(optionsEl.children).forEach(el=>{
      if(el!==keepBtn){ el.disabled = true; el.style.opacity = .5; }
    });
  }

  // ====== Áudio do prompt ======
  function playPrompt(q){
  stopAllAudio();

  const ttsText = q.targetWord || q.tts || q.prompt || '';

  if (q.promptAudio){
    const a = new Audio(absPath(q.promptAudio));
    currentAudio = a;
    a.onended = () => { currentAudio = null; };
    a.onerror  = () => { currentAudio = null; speak(ttsText); };
    a.play().catch(() => { currentAudio = null; speak(ttsText); });
  } else {
    speak(ttsText);
  }
}

  // ====== Fim ======
  function finish(){
  // para qualquer áudio/TTS que ainda esteja rodando
  try { stopAllAudio(); } catch(e){}
  try { speechSynthesis.cancel(); } catch(e){}
  isReading = false;

  bar.style.width = '100%';
  promptEl.textContent = "🎉 Congratulations! You've completed all the questions!";
  mediaBox.innerHTML = '<div style="font-size:44px">🏅</div>';
  optionsEl.innerHTML = '';
  btnNext.disabled = true;
  btnNext.classList.remove('ready');
  statusPill.textContent = `Concluído • ${questions.length}/${questions.length}`;
  confetti(30);
  speakFriendly(['Great! You finished!','Amazing work!']);

  // >>> esconder e desativar os botões de áudio na tela final
  btnPlayPrompt.disabled = true;
  btnRepeat.disabled = true;
  btnPlayPrompt.classList.add('is-hidden');
  btnRepeat.classList.add('is-hidden');
}

  // ====== Helpers ======
  function toast(msg){
    const t=document.createElement('div');
    t.className='toast';
    t.textContent=msg;
    document.body.appendChild(t);
    setTimeout(()=>t.remove(),2500);
  }
  function confetti(n=16){
    for(let i=0;i<n;i++){
      const p=document.createElement('div');
      p.className='piece';
      const left = Math.random()*100;
      const dur = 1200 + Math.random()*1400;
      const delay = Math.random()*100;
      p.style.left = left+'%';
      p.style.setProperty('--h', Math.floor(Math.random()*360));
      p.style.animationDuration = dur+'ms';
      p.style.animationDelay = delay+'ms';
      confettiEl.appendChild(p);
      setTimeout(()=>p.remove(), dur+delay+200);
    }
  }
  function speak(text){
    if(!text) return;
    try{
      const u = new SpeechSynthesisUtterance(text);
      u.lang = 'en-US';
      u.rate = 0.95; u.pitch = 1.0;
      speechSynthesis.cancel();
      speechSynthesis.speak(u);
    }catch(e){/* ok sem TTS */}
  }
  function speakFriendly(pool){
    const pick = pool[(Math.random()*pool.length)|0];
    speak(pick);
  }
  function shuffle(arr){
    for(let i=arr.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]]=[arr[j],arr[i]];
    }
    return arr;
  }
  function normalize(v){
    return String(v ?? '').trim().toLowerCase();
  }
  function absPath(p){
    // se começar com '/', mantém; senão, resolve relativo à BASE
    if(!p) return p;
    if(p.startsWith('http')) return p;
    if(p.startsWith('/')) return p;
    return `${BASE}/${p}`.replace(/\/+/g,'/');
  }
function renderOrderQuestion(q){
  // Normaliza inputs
  const words = q.options.map(w => String(w));
  const answerSeq = (q.answer || []).map(w => String(w));
  let built = [];

  // Bandeja de construção
  const wrap = document.createElement('div');
  wrap.className = 'build-wrap';

  const tray = document.createElement('div');
  tray.className = 'build-tray';
  tray.id = 'buildTray';
  tray.setAttribute('aria-label','Sentence tray');

  const actions = document.createElement('div');
  actions.className = 'build-actions';
  const undoBtn = document.createElement('button');
  undoBtn.className = 'build-btn'; undoBtn.textContent = 'Undo';
  const clearBtn = document.createElement('button');
  clearBtn.className = 'build-btn'; clearBtn.textContent = 'Clear';

  actions.appendChild(undoBtn); actions.appendChild(clearBtn);
  wrap.appendChild(tray); wrap.appendChild(actions);
  optionsEl.appendChild(wrap);

  // Cria grade responsiva (classe controla as colunas via CSS)
const grid = document.createElement('div');
grid.className = 'build-grid';
optionsEl.appendChild(grid);

  words.forEach(w=>{
    const b = document.createElement('button');
    b.type='button';
    b.className='option';
    b.innerHTML = `<div class="thumb">🔤</div><div class="label">${w}</div>`;
    b.onclick = ()=>{
      sTap.play().catch(()=>{});
      // evita exceder contagem da resposta (opcional)
      if (built.length >= answerSeq.length) return;
      built.push(w);
      drawTray();
      checkBuilt();
    };
    grid.appendChild(b);
  });

  undoBtn.onclick = ()=>{
    built.pop();
    drawTray();
    btnNext.disabled = true;
    btnNext.classList.remove('ready');
  };
  clearBtn.onclick = ()=>{
    built = [];
    drawTray();
    btnNext.disabled = true;
    btnNext.classList.remove('ready');
  };

  function drawTray(){
    tray.innerHTML = '';
    built.forEach(word=>{
      const chip = document.createElement('span');
      chip.className='word-chip';
      chip.textContent = word;
      tray.appendChild(chip);
    });
  }

  function checkBuilt(){
  const sameLen = built.length === answerSeq.length;
  if (!sameLen) return;

  const ok = built.every((w,i)=> normalize(w) === normalize(answerSeq[i]));
  if (ok){
    // troca o quadro grande por um GIF de comemoração
    try {
      mediaBox.innerHTML = '';
      const gif = new Image();
      gif.src = './hannah_feliz.gif';     // arquivo na MESMA pasta do index.html
      gif.alt = 'Hannah comemorando';
      gif.setAttribute('draggable','false');
      gif.style.pointerEvents = 'none';
      mediaBox.appendChild(gif);
    } catch(e){}

    confetti(18);
    sCorrect.play().catch(()=>{});
    speakFriendly(['Great!','Awesome!']);
    liveEl.textContent = 'Ordem correta';
    btnNext.disabled = false;
    btnNext.classList.add('ready');
    answered = true; // marca como respondido

    // Bloqueia toques adicionais
    Array.from(optionsEl.querySelectorAll('.option')).forEach(el=> el.disabled = true);
  } else {
    sWrong.play().catch(()=>{});
    speakFriendly(['Try again!']);
    liveEl.textContent = 'Ordem incorreta, tente novamente';
  }
}
} 

function renderMatchQuestion(q){
  const sourcePairs = Array.isArray(q.pairs) ? q.pairs : [];

  // Normaliza itens (aceita string, {label}, {image}, {label,image,value})
  const normItem = (side, it) => {
    if (typeof it === 'string') return { label: it, value: it };
    const o = {...it};
    if (!o.value) o.value = o.label || o.image || String(Math.random());
    return o;
  };

  const leftItems  = sourcePairs.map(p => normItem('left',  p.left));
  const rightItems = sourcePairs.map(p => normItem('right', p.right));

  const leftShuf  = shuffle([...leftItems]);
  const rightShuf = shuffle([...rightItems]);

  // Layout
  const grid = document.createElement('div');
  grid.className = 'match-grid';
  const colL = document.createElement('div'); colL.className = 'match-col';
  const colR = document.createElement('div'); colR.className = 'match-col';
  grid.appendChild(colL); grid.appendChild(colR);
  optionsEl.appendChild(grid);

  let selectedLeftBtn = null;
  let selectedLeftVal = null;
  let matched = new Set(); // valores já casados

  // Cria um card (texto/ícone à esquerda; imagem ou texto à direita)
  const makeLeftBtn = (item) => {
    const b = document.createElement('button');
    b.type = 'button';
    b.className = 'option';
    b.dataset.value = item.value;

    const thumb = document.createElement('div'); thumb.className='thumb'; thumb.textContent='🔤';
    const label = document.createElement('div'); label.className='label'; label.textContent=item.label || item.value;
    b.appendChild(thumb); b.appendChild(label);

    b.onclick = ()=>{
      if (b.classList.contains('matched')) return;
      sTap.play().catch(()=>{});
      // limpa seleção anterior
      Array.from(colL.children).forEach(el=>el.classList.remove('selected'));
      b.classList.add('selected');
      selectedLeftBtn = b;
      selectedLeftVal = item.value;
    };
    return b;
  };

  const makeRightBtn = (item) => {
    const b = document.createElement('button');
    b.type = 'button';
    b.className = 'option';
    b.dataset.value = item.value;

    const thumb = document.createElement('div'); thumb.className='thumb';
    if (item.image){
      const img = new Image(); img.src = absPath(item.image); img.alt = item.label || '';
      thumb.appendChild(img);
    } else {
      thumb.textContent = item.label ? '🔤' : '❔';
    }
    const label = document.createElement('div'); label.className='label';
    label.textContent = item.label || '';
    b.appendChild(thumb); b.appendChild(label);

    b.onclick = ()=>{
      if (b.classList.contains('matched')) return;
      if (!selectedLeftBtn){
        toast('Choose a word first 🙂');
        return;
      }
      // tentativa de match
      const leftVal = selectedLeftVal;
      const rightVal = item.value;
      const ok = normalize(leftVal) === normalize(rightVal);

      if (ok){
        sCorrect.play().catch(()=>{});
        confetti(10);
        speakFriendly(['Great!','Nice!']);

        b.classList.add('matched');
        selectedLeftBtn.classList.add('matched');
        selectedLeftBtn.classList.remove('selected');
        matched.add(leftVal);

        // reset seleção
        selectedLeftBtn = null;
        selectedLeftVal = null;

        // terminou?
if (matched.size === sourcePairs.length){
  // troca o quadro grande por o GIF de comemoração
  try {
    mediaBox.innerHTML = '';
    const gif = new Image();
    gif.src = './hannah_feliz.gif';   // o arquivo deve estar na MESMA pasta do index.html
    gif.alt = 'Hannah comemorando';
    gif.setAttribute('draggable','false');
    gif.style.pointerEvents = 'none';
    mediaBox.appendChild(gif);
  } catch(e){}

  confetti(18);
  sCorrect.play().catch(()=>{});
  speakFriendly(['Great!','Awesome!']);
  liveEl.textContent = 'All pairs matched';

  // finaliza questão
  answered = true;
  btnNext.disabled = false;
  btnNext.classList.add('ready');

  // trava os botões restantes
  Array.from(optionsEl.querySelectorAll('.option')).forEach(el => el.disabled = true);
}
      } else {
        sWrong.play().catch(()=>{});
        speakFriendly(['Try again!']);
        // feedback visual (shake no botão da direita)
        b.classList.add('err');
        setTimeout(()=>b.classList.remove('err'), 250);
      }
    };
    return b;
  };

  leftShuf.forEach(item => colL.appendChild(makeLeftBtn(item)));
  rightShuf.forEach(item => colR.appendChild(makeRightBtn(item)));
}

function speakSelectedThenCheck(q, o, btn){
  if (answered || isReading) return;
  isReading = true;

  // desabilita opções e o "Next" durante a leitura
  const allBtns = Array.from(document.querySelectorAll('.option'));
  allBtns.forEach(el => el.disabled = true);
  btnNext.disabled = true;
  btnNext.classList.remove('ready');

  const finish = () => {
    isReading = false;
    if (!answered) allBtns.forEach(el => el.disabled = false);
    handleAnswer(q, o, btn); // feedback só depois de ouvir
  };

  // texto a falar se não houver áudio próprio
  const say = (o.tts || o.label || o.value || '').toString().trim();

  // para qualquer coisa tocando antes de iniciar outra
  stopAllAudio();

  if (o.audio){
    try{
      const a = new Audio(absPath(o.audio));
      currentAudio = a;

      let done = false;
      const safeFinish = () => { if (!done){ done = true; currentAudio = null; finish(); } };

      a.onended = safeFinish;
      a.onerror = () => { currentAudio = null; speak(say); setTimeout(safeFinish, 600); };
      a.play().catch(() => { currentAudio = null; speak(say); setTimeout(safeFinish, 600); });

      // guarda-chuva caso eventos não disparem (autoplay bloqueado, etc.)
      setTimeout(safeFinish, 3500);
    }catch{
      speak(say);
      setTimeout(finish, 600);
    }
  } else {
    try{
      const u = new SpeechSynthesisUtterance(say || ' ');
      u.lang = 'en-US'; u.rate = 0.95; u.pitch = 1.0;
      u.onend   = finish;
      u.onerror = () => setTimeout(finish, 300);
      speechSynthesis.cancel();
      speechSynthesis.speak(u);
      // fallback se onend não vier
      setTimeout(() => { if (isReading) finish(); }, 2500);
    }catch{
      setTimeout(finish, 300);
    }
  }
}
})();
</script>
</body>
</html>
