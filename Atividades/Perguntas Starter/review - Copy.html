<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Hannah Questions ‚Äî Review</title>
<style>
  :root{
    --bg:#f7f9fc; --card:#ffffff; --text:#1f2937; --muted:#6b7280;
    --ok:#16a34a; --warn:#ef4444; --brand:#2563eb;
    --shadow:0 10px 25px rgba(0,0,0,.08); --radius:18px;
  }
  *{box-sizing:border-box}
  html,body{margin:0}
  body{
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,'Helvetica Neue',Arial;
    background:url('../../imagens/fundo.png') center/cover no-repeat, var(--bg);
    color:var(--text);
  }

  /* ===== App container ===== */
  .app{
    width:100%;
    max-width:1140px;
    margin: 12px auto 24px auto;
    background:var(--card);
    border-radius:var(--radius);
    box-shadow:var(--shadow);
    padding:16px;
    position:relative;
    overflow:visible;
  }

  /* ===== Back separado (acima do header) ===== */
  #back-button{
    display:inline-flex;
    align-items:center;
    gap:.5rem;
    width:auto !important;
    max-width:none;
    margin-bottom:8px;
    border:none; background:#eef2ff; color:#0f3ea8;
    padding:8px 12px; border-radius:10px; font-weight:700; cursor:pointer;
    box-shadow:0 6px 14px rgba(0,0,0,.06);
  }
  #back-button:active{ transform: translateY(1px); }

  /* ===== Header ===== */
  .header{
    display:grid;
    grid-template-columns:auto 1fr auto;
    align-items:center;
    gap:12px;
    margin-bottom:12px;
  }
  .avatar{
    width:48px;height:48px;border-radius:50%;
    background:#e5f0ff;border:2px solid #cfe0ff;
    display:flex;align-items:center;justify-content:center;overflow:hidden;
  }
  .avatar img{width:100%;height:100%;object-fit:contain;border-radius:50%;display:block}
  .title-wrap{min-width:0}
  .title{font-weight:800;font-size:20px;line-height:1.2;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .subtitle{color:var(--muted);font-size:14px;line-height:1.2;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .progress{height:8px;background:#eef2f7;border-radius:999px;overflow:hidden;margin-top:8px}
  .progress > div{height:100%;width:0%;background:linear-gradient(90deg,#60a5fa,#34d399);transition:width .3s ease}

  .badge{
    max-width: 42ch;
    background:#eef2ff;border:1px solid #d7defc;color:#3949ab;
    padding:8px 10px;border-radius:999px;font-size:12px;line-height:1;
    white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
  }

  /* ===== Question ===== */
  .stage{display:grid;gap:16px}
  .question-card{
    background:#f9fbff;border:1px solid #e5eaf5;border-radius:16px;padding:14px;
    margin: 0 auto;
  }

  .q-top{display:flex;flex-direction:column;gap:14px}

  /* Linha com prompt + √≠cone de √°udio do prompt */
  .q-prompt-row{
    display:flex;
    align-items:flex-start;
    gap:8px;
  }

  .q-prompt{
    font-size:22px;font-weight:800;line-height:1.3;word-break:break-word;
    flex:1 1 auto;
  }

  /* √çcone de √°udio do PROMPT (sempre l√™ o prompt) */
  .prompt-audio-btn{
    flex:0 0 auto;
    border:none;
    background:transparent;
    cursor:pointer;
    font-size:22px;
    line-height:1;
    padding:6px;
    border-radius:999px;
    display:inline-flex;
    align-items:center;
    justify-content:center;
    transition:background .15s ease, transform .1s ease, opacity .15s ease;
    opacity:0.85;
  }
  .prompt-audio-btn:hover{
    background:rgba(37,99,235,.08);
    opacity:1;
  }
  .prompt-audio-btn:active{
    transform:scale(.92);
  }

  .q-media{width:100%;aspect-ratio:16/10;background:#eef4ff;border:1px dashed #cfe0ff;border-radius:14px;padding:8px;overflow:hidden;display:block}
  .q-media img{width:100%;height:100%;object-fit:contain;display:block}
  @supports not (aspect-ratio:16/10){.q-media{height:220px}}

  .q-controls{display:flex;gap:8px;align-items:center;margin-top:8px;flex-wrap:wrap}

  /* Bot√£o LISTEN especial para audio_mcq (resposta) */
  .listen-audio-btn{
    border:none;
    display:inline-flex;
    align-items:center;
    justify-content:center;
    gap:10px;
    padding:12px 20px;
    border-radius:999px;
    background:linear-gradient(90deg,#3b82f6,#22c55e);
    color:#fff;
    font-weight:900;
    font-size:16px;
    cursor:pointer;
    box-shadow:0 10px 18px rgba(34,197,94,.35);
  }
  .listen-audio-btn .listen-icon{
    font-size:22px;
  }
  .listen-audio-btn .listen-label{
    letter-spacing:.08em;
  }
  .listen-audio-btn:active{
    transform:translateY(1px);
  }

  .icon-btn{border:none;background:#e6f0ff;color:#0f3ea8;padding:10px 12px;border-radius:12px;cursor:pointer;font-weight:700}
  .icon-btn:active{transform:translateY(1px)}

  .options{display:grid;gap:10px;margin-top:6px;grid-template-columns:repeat(2,minmax(0,1fr))}
  .option{
    display:flex;align-items:center;gap:12px;background:#fff;border:2px solid #e9eef7;border-radius:18px;
    padding:12px;cursor:pointer;user-select:none;min-height:78px;
    box-shadow:0 4px 12px rgba(0,0,0,.03);
    transition:transform .06s ease,border-color .15s ease,box-shadow .15s ease
  }
  .option:hover{transform:translateY(-1px);box-shadow:0 8px 18px rgba(0,0,0,.06)}
  .option:active{transform:translateY(0)}
  .option .thumb{width:60px;height:60px;border-radius:14px;background:#f3f6ff;border:1px solid #e6ecfb;overflow:hidden;display:flex;align-items:center;justify-content:center;font-size:30px;flex:0 0 60px}
  .option .thumb img{width:100%;height:100%;object-fit:contain;padding:6px;display:block}
  .option.img-only{justify-content:center;gap:0}.option.img-only .thumb{margin:0 auto}.option.img-only .label{display:none}
  .option .label{font-size:19px;font-weight:800;letter-spacing:.2px;word-break:break-word}
  .option .sub{font-size:13px;color:var(--muted)}

  .square-outline{width:38px;height:38px;border:6px solid var(--sq,#7c3aed);border-radius:10px;background:transparent;display:inline-block;position:relative;transition:border-color .2s ease,background .2s ease,transform .15s ease}
  .option.ok .square-outline{border-color:#16a34a;background:#dcfce7}
  .option.ok .square-outline::after{content:"‚úî";position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:#166534;font-size:20px;font-weight:900;animation:pop-in .18s ease-out}
  .option.err .square-outline{border-color:#ef4444;background:#fee2e2}
  @keyframes pop-in{from{transform:scale(.6);opacity:0}to{transform:scale(1);opacity:1}}
  .option.ok{border-color:#86efac;animation:okPulse .4s ease}
  .option.err{border-color:#fecaca;animation:shake .22s ease}
  @keyframes okPulse{0%{box-shadow:0 0 0 0 rgba(34,197,94,.4)}100%{box-shadow:0 0 0 18px rgba(34,197,94,0)}}
  @keyframes shake{0%{transform:translateX(0)}25%{transform:translateX(-4px)}50%{transform:translateX(4px)}75%{transform:translateX(-3px)}100%{transform:translateX(0)}}

  .footer{margin-top:12px;display:flex;justify-content:space-between;align-items:center;gap:8px;flex-wrap:wrap}
  .pill{background:#eef2ff;color:#3949ab;padding:8px 12px;border-radius:999px;font-size:12px;border:1px solid #d7defc}
  .next-btn{
    border:none;background:linear-gradient(90deg,#3b82f6,#22c55e);
    color:#fff;font-weight:800;padding:12px 16px;border-radius:14px;
    cursor:pointer;box-shadow:0 10px 18px rgba(34,197,94,.25);
    opacity:.3;pointer-events:none;transition:opacity .2s ease,transform .06s ease
  }
  .next-btn.ready{opacity:1;pointer-events:auto}
  .next-btn:active{transform:translateY(1px)}

  .secondary-btn{
    border:none;background:#eef2ff;color:#0f3ea8;font-weight:800;
    padding:12px 16px;border-radius:14px;cursor:pointer;
    box-shadow:0 10px 18px rgba(15,62,168,.12);
  }
  .secondary-btn:active{transform:translateY(1px)}

  .confetti{position:absolute;inset:0;pointer-events:none;overflow:hidden}
  .piece{position:absolute;width:10px;height:10px;background:hsl(var(--h) 80% 60%);top:-12px;border-radius:2px;animation:drop linear forwards}
  @keyframes drop{to{transform:translateY(120vh) rotate(540deg)}}

  .toast{position:fixed;left:50%;bottom:24px;transform:translateX(-50%);background:#111827;color:#fff;padding:10px 14px;border-radius:12px;font-size:14px;box-shadow:var(--shadow);opacity:.96}
  .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}

  .build-wrap{margin-top:8px;position:sticky;top:0;z-index:3;background:#f9fbff;padding-bottom:8px;box-shadow:0 6px 10px -8px rgba(0,0,0,.15)}
  .build-tray{min-height:56px;background:#eef4ff;border:2px dashed #cfe0ff;border-radius:14px;padding:10px;display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  .word-chip{background:#fff;border:2px solid #dbe5ff;border-radius:12px;padding:8px 12px;font-weight:800;box-shadow:0 2px 6px rgba(0,0,0,.05);user-select:none}
  .build-actions{display:flex;gap:8px;margin-top:8px}
  .build-btn{border:none;background:#e6f0ff;color:#0f3ea8;padding:8px 12px;border-radius:10px;cursor:pointer;font-weight:700}
  .build-btn:active{transform:translateY(1px)}
  .match-grid{display:grid;grid-template-columns:1fr 1fr;gap:14px;margin-top:8px}
  .match-col{display:flex;flex-direction:column;gap:12px}
  .option.selected{outline:3px solid #60a5fa}
  .option.matched{border-color:#86efac;opacity:.65;pointer-events:none}
  .build-grid{display:grid;gap:12px;grid-template-columns:repeat(2,minmax(0,1fr))}
  .option.word-only{gap:0;justify-content:center}
  .option.word-only .label{width:100%;text-align:center;font-size:22px;font-weight:800}

  .blank{
    display:inline-block;
    vertical-align:baseline;
    width:clamp(2ch, 6ch, 11ch);
    height:1.05em;
    border-bottom:3px solid #cfe0ff;
    margin:0 .3em;
  }

  .loading{position:fixed;inset:0;background:rgba(255,255,255,.75);display:flex;align-items:center;justify-content:center;z-index:9999;backdrop-filter:blur(2px);font-weight:700;color:#334155}
  .spinner{width:42px;height:42px;border-radius:50%;border:4px solid #c7d2fe;border-top-color:#3b82f6;animation:spin 1s linear infinite;margin-right:10px}
  @keyframes spin{to{transform:rotate(360deg)}}

  .icon-btn[disabled]{opacity:.4;pointer-events:none}
  .is-hidden{display:none!important}

  @media (max-width:720px){
    .options{grid-template-columns:1fr}
    .q-prompt{font-size:20px}
    .badge{grid-column:1/-1;max-width:100%}
  }

  @media (min-width: 1024px){
    .question-card{ padding:12px; }

    .q-top{
      display:grid;
      grid-template-columns: minmax(300px, 40%) 1fr;
      align-items:start;
      gap:16px;
    }

    .q-media{
      aspect-ratio:auto;
      height: clamp(160px, 24vh, 260px);
      max-width:100%;
    }

    .options{
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap:12px;
      margin-top:10px;
    }

    .option{ min-height:68px; padding:10px 12px; }
    .option .thumb{ width:54px; height:54px; flex-basis:54px; }
    .option .label{ font-size:18px; }

    .q-prompt{ font-size:20px; }
  }

  @media (min-width: 900px) and (max-height: 820px){
    .q-top{ grid-template-columns: minmax(280px, 38%) 1fr; gap:12px; }
    .q-media{ height: clamp(150px, 22vh, 240px); }
    .options{ gap:10px; }
    .option{ min-height:64px; }
    .option .thumb{ width:50px; height:50px; flex-basis:50px; }
    .option .label{ font-size:17px; }
  }
</style>
</head>
<body>
  <div class="app" id="app">
    <button id="back-button" onclick="goBack()">Back</button>

    <div class="confetti" id="confetti"></div>

    <div class="header">
      <div class="avatar" id="avatar" aria-hidden="true">ü§ñ</div>
      <div class="title-wrap">
        <div class="title">Hannah Questions ‚Äî Review</div>
        <div class="subtitle" id="subtitle">Loading content‚Ä¶</div>
        <div class="progress"><div id="bar"></div></div>
      </div>
      <div class="badge" id="pill">Unit ‚Äî</div>
    </div>

    <div class="stage">
      <div class="question-card">
        <div class="q-top">
          <div>
            <!-- Prompt + √≠cone de √°udio do prompt -->
            <div class="q-prompt-row">
              <div class="q-prompt" id="prompt">‚Äî</div>
              <button
                class="prompt-audio-btn"
                id="btnPlayPrompt"
                type="button"
                title="Listen to question"
                aria-label="Listen to the question"
              >
                üîä
              </button>
            </div>

            <!-- Bot√£o LISTEN especial (apenas para audio_mcq) -->
            <div class="q-controls">
              <button
                class="listen-audio-btn is-hidden"
                id="btnListenAnswer"
                type="button"
                title="Listen to the answer"
              >
                <span class="listen-icon">üéß</span>
                <span class="listen-label">LISTEN</span>
              </button>
            </div>
          </div>

          <div class="q-media" id="mediaBox" aria-label="Question image"></div>
        </div>

        <div class="options" id="options"></div>

        <div class="footer" id="footerBar">
          <span class="pill" id="statusPill">Question ‚Äî/‚Äî</span>

          <div style="display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; align-items:center;">
            <button class="secondary-btn is-hidden" id="btnAlt1" type="button">Review Oldest</button>
            <button class="secondary-btn is-hidden" id="btnAlt2" type="button">Mixed Quiz</button>
            <button class="next-btn" id="btnNext" disabled>Next</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="loading" id="loading" aria-live="polite" style="display:none">
    <div class="spinner" aria-hidden="true"></div>
    <span>Loading‚Ä¶</span>
  </div>

  <div class="sr-only" aria-live="polite" id="live"></div>

  <!-- Firebase SDK v8 -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

<script>
/* =========================
   Firebase init (v8)
========================= */
const firebaseConfig = {
  apiKey: "AIzaSyDGgo2H_hDKXF88xN7XnLFNUj8ikMY7Xdc",
  authDomain: "hannahenglishcourse.firebaseapp.com",
  databaseURL: "https://hannahenglishcourse-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "hannahenglishcourse",
  storageBucket: "hannahenglishcourse.appspot.com",
  messagingSenderId: "449818788486",
  appId: "1:449818788486:web:8a49d3f68591e6fb3f0707"
};
firebase.initializeApp(firebaseConfig);

// Keep user uid
let currentUserId = null;
firebase.auth().onAuthStateChanged(function(user){
  currentUserId = user ? user.uid : null;
});
</script>

<script>
(function(){
  /* ============================================================
     REVIEW MODE (UPDATED to "FINAL LIST")
     - Entry/pool comes from activity history (userAnswers) and activities list
     - Review is binary:
        correct in review => remove from review queue
        wrong in review   => stays in review queue
     - No multiple attempts in review (MCQ/order/match):
        first decision counts, then Next is enabled
     - Historical attempts are used ONLY for:
        (1) who enters review
        (2) priority ordering
     - Review queue is stored in Firebase under:
        reviewState/{uid}/{LevelX}/{UnitY}/pending/{questionId}: true
     - Up to 15 per round: hardest 15 (priority), presented easier->harder
     - Round counter: sessionStorage, after 3 rounds => Take a break (no unlock)
  ============================================================ */

  /* =========================
     Helpers essenciais
  ========================= */
  function getParams(){
    const url = new URL(location.href);
    const level = url.searchParams.get('level');
    const unit  = url.searchParams.get('unit');
    const fase  = url.searchParams.get('fase'); // used for progress unlock/back check
    return { level, unit, fase };
  }
  function normalizeDir(prefix, value, fallbackNum){
    if (!value) return prefix + fallbackNum;
    const lower = value.toLowerCase();
    if (lower.startsWith(prefix.toLowerCase())) return value.trim();
    const onlyNum = (value.match(/\d+/)||[''])[0];
    return prefix + (onlyNum || fallbackNum);
  }

  function escapeHtml(str){
    return String(str ?? '')
      .replace(/&/g,'&amp;')
      .replace(/</g,'&lt;')
      .replace(/>/g,'&gt;')
      .replace(/"/g,'&quot;')
      .replace(/'/g,'&#039;');
  }

  function normalize(v){
    return String(v ?? '')
      .trim()
      .toLowerCase()
      .replace(/\s+/g,' ')
      .replace(/[‚Äú‚Äù"]/g,'"');
  }

  function shuffle(arr){
    const a = Array.isArray(arr) ? arr : [];
    for (let i = a.length - 1; i > 0; i--){
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  function absPath(p){
    const s = String(p ?? '').trim();
    if (!s) return s;
    if (/^https?:\/\//i.test(s)) return s;
    if (s.startsWith('/')) return s;
    return s;
  }

  function showLoader(show){
    const el = document.getElementById('loading');
    if (!el) return;
    el.style.display = show ? 'flex' : 'none';
  }

  /* WebAudio SFX */
  let audioCtx = null;
  function ensureAudio(){
    if(!audioCtx){
      try{ audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }catch(e){}
    }
    return !!audioCtx;
  }
  function tone(freq, durMs, type){
    if(!ensureAudio()) return;
    const o = audioCtx.createOscillator(), g = audioCtx.createGain();
    o.type = type || 'sine'; o.frequency.value = freq;
    o.connect(g); g.connect(audioCtx.destination);
    const t0 = audioCtx.currentTime;
    g.gain.setValueAtTime(0.001, t0);
    g.gain.exponentialRampToValueAtTime(0.16, t0+0.01);
    g.gain.exponentialRampToValueAtTime(0.001, t0 + (durMs/1000));
    o.start(t0); o.stop(t0 + (durMs/1000));
  }
  function sfxTick(){ tone(520, 70, 'square'); if(navigator.vibrate) navigator.vibrate(12); }
  function sfxCorrect(){ tone(880,120,'triangle'); setTimeout(()=>tone(1320,90,'triangle'),110); if(navigator.vibrate) navigator.vibrate(25); }
  function sfxWrong(){ tone(240,140,'sawtooth'); if(navigator.vibrate) navigator.vibrate(15); }
  function sfxWin(){ tone(660,120,'triangle'); setTimeout(()=>tone(990,120,'triangle'),120); setTimeout(()=>tone(1320,150,'triangle'),240); if(navigator.vibrate) navigator.vibrate([30,30,50]); }

  function toast(msg){
    const t=document.createElement('div');
    t.className='toast';
    t.textContent=msg;
    document.body.appendChild(t);
    setTimeout(()=>t.remove(),2500);
  }

  /* =========================
     Progress√£o de fase
  ========================= */
  function ensureUserIsAuthenticated(callback){
    if(currentUserId){ callback(currentUserId); return; }
    firebase.auth().onAuthStateChanged(function(user){
      if(user){ currentUserId = user.uid; callback(user.uid); }
      else { console.error("[Auth] User not authenticated"); }
    });
  }

  async function updateNextPhase(userId){
    const { level, unit, fase } = getParams();
    if(!level || !unit || !fase){ console.warn("[Progress] Missing URL params."); return; }

    const levelKey = normalizeDir('Level', level || '0', '0');
    const unitKey  = normalizeDir('Unit',  unit  || '1', '1');

    const dbRef = firebase.database().ref(`usuarios/${userId}/progresso/${levelKey}/${unitKey}`);
    try{
      if(fase === "last"){
        const nextUnit = `Unit${parseInt((unitKey||'').replace(/\D/g,''),10) + 1}`;
        await firebase.database().ref(`usuarios/${userId}/progresso/${levelKey}/${nextUnit}`).set({ fase1: true });
      } else if(fase === "end"){
        const nextLevel = `Level${parseInt((levelKey||'').replace(/\D/g,''),10) + 1}`;
        await firebase.database().ref(`usuarios/${userId}/progresso/${nextLevel}/Unit1`).set({ fase1: true });
      } else {
        const cur = parseInt(fase,10);
        const nextPhase = cur + 1;
        await dbRef.update({ [`fase${cur}`]: true, [`fase${nextPhase}`]: true });
      }
      console.log("[Progress] Update successful.");
    } catch(err){
      console.error("[Progress] Error updating next phase:", err);
    }
  }

  function markPhaseCompleted(){
    ensureUserIsAuthenticated(function(uid){
      if (uid) updateNextPhase(uid);
    });
  }

  /* Back button rule:
     - If activityCompleted => always back
     - Else, check if next phase is unlocked; if not, confirm in English
  */
  window.activityCompleted = false;
  window.goBack = async function goBack(){
    try{
      if (window.activityCompleted){
        history.back();
        return;
      }

      await new Promise((resolve)=>ensureUserIsAuthenticated(()=>resolve()));
      if (!currentUserId){
        const ok = confirm("You are not logged in. Do you want to go back anyway?");
        if (ok) history.back();
        return;
      }

      const { level, unit, fase } = getParams();
      const levelKey = normalizeDir('Level', level || '0', '0');
      const unitKey  = normalizeDir('Unit',  unit  || '1', '1');

      const cur = parseInt(fase, 10);
      if (!Number.isFinite(cur)){
        const ok = confirm("Next phase status cannot be checked here. Do you want to go back anyway?");
        if (ok) history.back();
        return;
      }

      const nextPhase = cur + 1;
      const ref = firebase.database().ref(`usuarios/${currentUserId}/progresso/${levelKey}/${unitKey}/fase${nextPhase}`);
      const snap = await ref.once('value');
      const unlocked = snap.val() === true;

      if (unlocked){
        history.back();
      } else {
        const ok = confirm("Next phase is not unlocked yet. Do you want to go back anyway?");
        if (ok) history.back();
      }
    }catch(err){
      console.warn("[Back] Fallback due to error:", err);
      const ok = confirm("Could not verify next phase. Do you want to go back anyway?");
      if (ok) history.back();
    }
  };

  /* =========================
     Avatar + paths
  ========================= */
  (function(){
    const avatarEl = document.getElementById('avatar');
    const img = new Image();
    img.src = '../../imagens/robo1_static.png';
    img.alt = 'App mascot';
    img.onload = () => { avatarEl.textContent = ''; avatarEl.appendChild(img); };
    img.onerror = () => { avatarEl.textContent = 'ü§ñ'; };
  })();

  const { level, unit, fase } = getParams();
  const levelDir = normalizeDir('Level', level || '0', '0');
  const unitDir  = normalizeDir('Unit',  unit  || '1', '1');
  const BASE  = `../../${levelDir}/${unitDir}/QA`;
  const QFILE = `${BASE}/questions.txt`;

  const pill = document.getElementById('pill');
  pill.textContent = `${levelDir} ‚Ä¢ ${unitDir}${fase ? ' ‚Ä¢ Phase '+fase : ''}`;

  /* =========================
     Activity state/els
  ========================= */
  let questions = [];
  let isReading = false;
  let currentAudio = null;
  let idx = 0;
  let answered = false;

  const MAX_PER_ROUND = 15;
  const MAX_ROUNDS = 3;

  const subtitle   = document.getElementById('subtitle');
  const bar        = document.getElementById('bar');
  const promptEl   = document.getElementById('prompt');
  const mediaBox   = document.getElementById('mediaBox');
  const optionsEl  = document.getElementById('options');
  const btnPlayPrompt = document.getElementById('btnPlayPrompt');
  const btnListenAnswer = document.getElementById('btnListenAnswer');
  const btnNext    = document.getElementById('btnNext');
  const btnAlt1    = document.getElementById('btnAlt1');
  const btnAlt2    = document.getElementById('btnAlt2');
  const statusPill = document.getElementById('statusPill');
  const confettiEl = document.getElementById('confetti');
  const liveEl     = document.getElementById('live');

  const sCorrect = new Audio(`${BASE}/sounds/correct.mp3`);
  const sWrong   = new Audio(`${BASE}/sounds/wrong.mp3`);
  const sTap     = new Audio(`${BASE}/sounds/tap.mp3`);
  const sNext    = new Audio(`${BASE}/sounds/next.mp3`);
  [sCorrect,sWrong,sTap,sNext].forEach(a=>{a.preload='auto'});

  /* =========================
     Confetti
  ========================= */
  function confetti(n){
    const count = Math.max(0, Math.min(80, Number(n || 18)));
    confettiEl.innerHTML = '';
    const w = confettiEl.clientWidth || 600;
    for(let i=0;i<count;i++){
      const p = document.createElement('div');
      p.className = 'piece';
      p.style.left = Math.round(Math.random()*w) + 'px';
      p.style.setProperty('--h', String(Math.round(Math.random()*360)));
      p.style.animationDuration = (900 + Math.random()*900) + 'ms';
      p.style.opacity = String(0.85 + Math.random()*0.15);
      confettiEl.appendChild(p);
      setTimeout(()=>{ try{ p.remove(); }catch(e){} }, 2200);
    }
  }

  /* =========================
     Firebase: t√≠tulo (de questions.txt)
  ========================= */
  async function loadTitleFromFile(){
    try{
      const resp = await fetch(QFILE, { cache:'no-store' });
      if (!resp.ok) return null;
      const text = await resp.text();
      const data = JSON.parse(text);
      if (data && typeof data.title === 'string' && data.title.trim()){
        return data.title.trim();
      }
    }catch(err){
      console.warn('[Q&A] Could not load title from questions.txt:', err);
    }
    return null;
  }

  /* =========================
     REVIEW: activities -> questionIds for unit (all phases)
  ========================= */
  async function getAllQuestionIdsForUnit(levelKey, unitKey){
    const prefix = `${levelKey}_${unitKey}_Fase`;
    const snap = await firebase.database()
      .ref("activities")
      .orderByKey()
      .startAt(prefix)
      .endAt(prefix + "\uf8ff")
      .once("value");

    const obj = snap.val() || {};
    const set = new Set();

    Object.keys(obj).forEach(k => {
      const a = obj[k];
      if (!a || !Array.isArray(a.questionIds)) return;
      a.questionIds.forEach(id => { if (id) set.add(id); });
    });

    return Array.from(set);
  }

  /* =========================
     REVIEW STATE (Firebase)
     reviewState/{uid}/{levelKey}/{unitKey}/pending/{qid}: true
  ========================= */
  function reviewRootRef(uid, levelKey, unitKey){
    return firebase.database().ref(`reviewState/${uid}/${levelKey}/${unitKey}`);
  }
  async function getPendingMap(uid, levelKey, unitKey){
    const snap = await reviewRootRef(uid, levelKey, unitKey).child('pending').once('value');
    return snap.val() || {};
  }
  async function setPendingFromList(uid, levelKey, unitKey, ids){
    const root = reviewRootRef(uid, levelKey, unitKey);
    const pending = {};
    (ids || []).forEach(id => { if (id) pending[id] = true; });
    await root.update({
      createdAt: firebase.database.ServerValue.TIMESTAMP,
      updatedAt: firebase.database.ServerValue.TIMESTAMP,
      pending
    });
  }
  async function removeFromPending(uid, levelKey, unitKey, qid){
    const root = reviewRootRef(uid, levelKey, unitKey);
    const pRef = root.child('pending').child(String(qid));
    await pRef.remove();
    await root.update({ updatedAt: firebase.database.ServerValue.TIMESTAMP });
  }

  /* =========================
     ENTRY CRITERIA + PRIORITY (HISTORY ONLY)
     Criteria (conservative):
       - at least 1 wrong (wrongAttempts >= 1)
       - AND (totalAttempts < 3 OR wrongAttempts >= correctAttempts)
  ========================= */
  function statsToCounts(stats){
    const total = Math.max(0, Number(stats && stats.totalAttempts || 0));
    const correct = Math.max(0, Number(stats && stats.correctAttempts || 0));
    const wrong = Math.max(0, total - correct);
    const accuracy = total > 0 ? (correct / total) : 0;
    const lastIsCorrect = (stats && typeof stats.lastIsCorrect === 'boolean') ? stats.lastIsCorrect : null;
    const firstAttemptResult = (stats && stats.firstAttemptResult) ? String(stats.firstAttemptResult) : null;
    return { total, correct, wrong, accuracy, lastIsCorrect, firstAttemptResult };
  }

  function eligibleForReview(stats){
    const c = statsToCounts(stats);
    if (c.total <= 0) return false; // not attempted
    if (c.wrong < 1) return false;  // never wrong => not in review
    if (c.total < 3) return true;   // conservative rule for early attempts
    return (c.wrong >= c.correct);  // conservative tie/greater wrong
  }

  // Priority: higher means harder (history only)
  function priorityScoreFromHistory(stats){
    const c = statsToCounts(stats);
    // Weighted: wrong count matters most, then low accuracy, then recent wrong
    let score = 0;
    score += c.wrong * 30;                 // wrong weight
    score += Math.round((1 - c.accuracy) * 100); // accuracy penalty
    if (c.lastIsCorrect === false) score += 15;  // recent difficulty
    if (c.firstAttemptResult === "wrong") score += 10; // early struggle
    score += Math.min(c.total, 10) * 2;   // small weight for more exposure
    return score;
  }

  /* =========================
     BUILD / LOAD REVIEW QUEUE
     - If pending exists -> use it
     - Else create pending using eligibility from userAnswers for unit questionIds
  ========================= */
  async function ensureReviewQueue({ uid, levelKey, unitKey }){
    const existing = await getPendingMap(uid, levelKey, unitKey);
    const existingIds = Object.keys(existing || {});
    if (existingIds.length) return { pendingIds: existingIds, created: false };

    const allIds = await getAllQuestionIdsForUnit(levelKey, unitKey);
    if (!allIds.length){
      await setPendingFromList(uid, levelKey, unitKey, []);
      return { pendingIds: [], created: true };
    }

    const userAnsSnap = await firebase.database().ref(`userAnswers/${uid}`).once('value');
    const userAnsAll = userAnsSnap.val() || {};

    const attempted = allIds.filter(id => !!userAnsAll[id]);
    if (!attempted.length){
      await setPendingFromList(uid, levelKey, unitKey, []);
      return { pendingIds: [], created: true };
    }

    const eligible = attempted.filter(id => eligibleForReview(userAnsAll[id]));
    await setPendingFromList(uid, levelKey, unitKey, eligible);

    return { pendingIds: eligible, created: true };
  }

  /* =========================
     SELECT ROUND (up to 15)
     - choose hardest 15 by history priority (from userAnswers snapshot)
     - present easier->harder
  ========================= */
  async function buildRoundFromPending({ uid, levelKey, unitKey }){
    const pendingMap = await getPendingMap(uid, levelKey, unitKey);
    const pendingIds = Object.keys(pendingMap || {});
    if (!pendingIds.length){
      return { status: "complete", remainingCount: 0, selected: [] };
    }

    const uaSnap = await firebase.database().ref(`userAnswers/${uid}`).once('value');
    const uaAll = uaSnap.val() || {};

    const scored = pendingIds.map(id => {
      const stats = uaAll[id] || {};
      const pr = priorityScoreFromHistory(stats);
      return { id, pr, stats };
    });

    const topHardest = scored
      .sort((a,b)=> b.pr - a.pr)
      .slice(0, MAX_PER_ROUND);

    const orderedForStudent = [...topHardest].sort((a,b)=> a.pr - b.pr);

    const qSnaps = await Promise.all(
      orderedForStudent.map(x => firebase.database().ref(`questions/${x.id}`).once("value"))
    );

    const selectedQuestions = [];
    qSnaps.forEach((snap, i) => {
      const val = snap.val();
      if (!val) return;

      const id = orderedForStudent[i].id;
      const q = { ...val };

      q.id = q.id || id;
      q.level = q.level || levelKey;
      q.unit  = q.unit  || unitKey;
      q.fase  = q.fase || null;

      if (!q.type) q.type = "mcq";
      if (!Array.isArray(q.options)) q.options = [];

      q._priority = orderedForStudent[i].pr;
      selectedQuestions.push(q);
    });

    return {
      status: "needs_review",
      remainingCount: pendingIds.length,
      selected: selectedQuestions
    };
  }

  /* =========================
     REVIEW: round counter (3 rounds break)
  ========================= */
  function roundKey(levelKey, unitKey, uid){
    return `reviewRounds_${uid}_${levelKey}_${unitKey}`;
  }
  function getReviewRoundCounter(levelKey, unitKey, uid){
    try{
      const v = Number(sessionStorage.getItem(roundKey(levelKey, unitKey, uid)) || "0");
      return Number.isFinite(v) ? v : 0;
    }catch{ return 0; }
  }
  function incrementReviewRoundCounter(levelKey, unitKey, uid){
    const cur = getReviewRoundCounter(levelKey, unitKey, uid);
    try{ sessionStorage.setItem(roundKey(levelKey, unitKey, uid), String(cur + 1)); }catch{}
  }
  function resetReviewRoundCounter(levelKey, unitKey, uid){
    try{ sessionStorage.removeItem(roundKey(levelKey, unitKey, uid)); }catch{}
  }

  /* =========================
     Log de respostas do aluno (kept for analytics/history)
     - This continues updating userAnswers normally.
  ========================= */
  function logAnswer(question, isCorrect){
    if (!question || !question.id) return;

    ensureUserIsAuthenticated(function(uid){
      if (!uid) return;

      const ref = firebase.database().ref(`userAnswers/${uid}/${question.id}`);

      ref.transaction(prev => {
        const now = Date.now();

        const meta = {
          level:      question.level || levelDir,
          unit:       question.unit  || unitDir,
          fase:       question.fase  || (fase || null),
          grammarTag: question.grammarTag || null,
          skillType:  question.skillType  || null,
          difficulty: question.difficulty || null
        };

        const prevStreak = Number(prev && prev.correctStreak ? prev.correctStreak : 0);
        const prevLastAttempt = (prev && prev.lastAttemptResult) ? String(prev.lastAttemptResult) : null;

        const nextStreak = isCorrect
          ? (prevLastAttempt === 'correct' ? (prevStreak + 1) : 1)
          : 0;

        if (!prev){
          return {
            ...meta,
            totalAttempts: 1,
            correctAttempts: isCorrect ? 1 : 0,
            firstAttemptResult: isCorrect ? 'correct' : 'wrong',
            lastIsCorrect: isCorrect,
            lastAttemptResult: isCorrect ? 'correct' : 'wrong',
            correctStreak: nextStreak,
            lastTimestamp: now,
            lastCorrectTimestamp: isCorrect ? now : null,
            lastWrongTimestamp: isCorrect ? null : now
          };
        }

        const totalAttempts   = (prev.totalAttempts   || 0) + 1;
        const correctAttempts = (prev.correctAttempts || 0) + (isCorrect ? 1 : 0);
        const firstAttemptResult = prev.firstAttemptResult || (isCorrect ? 'correct' : 'wrong');

        return {
          ...prev,
          ...meta,
          totalAttempts,
          correctAttempts,
          firstAttemptResult,
          lastIsCorrect: isCorrect,
          lastAttemptResult: isCorrect ? 'correct' : 'wrong',
          correctStreak: nextStreak,
          lastTimestamp: now,
          lastCorrectTimestamp: isCorrect ? now : (prev.lastCorrectTimestamp || null),
          lastWrongTimestamp: isCorrect ? (prev.lastWrongTimestamp || null) : now
        };
      });
    });
  }

  /* =========================
     Prompt/blank utils + TTS builder
  ========================= */
  function renderPromptWithBlanks(str){
    const s = String(str ?? '');
    return s
      .replace(/\{blank\}/g, '<span class="blank" aria-hidden="true"></span>')
      .replace(/\{b\d+\}/gi, '<span class="blank" aria-hidden="true"></span>')
      .replace(/_{3,}/g,     '<span class="blank" aria-hidden="true"></span>');
  }
  function ttsSanitize(str){
    return String(str ?? '')
      .replace(/\{blank\}/g, '')
      .replace(/\{b\d+\}/gi, '')
      .replace(/_{3,}/g, '');
  }
  function stripQuotesForTTS(str){
    return String(str ?? '').replace(/[‚Äú‚Äù"]/g,'').replace(/\s{2,}/g,' ').trim();
  }

  function buildSpokenPrompt(q){
    if (!q) return '';

    if (q.type === 'audio_mcq'){
      const raw = typeof q.prompt === 'string' ? q.prompt : '';
      return stripQuotesForTTS(ttsSanitize(raw));
    }

    if (q.tts && String(q.tts).trim()) return stripQuotesForTTS(q.tts);

    let text = String(q.prompt || '');
    if (q.type !== 'fillblank'){
      return stripQuotesForTTS(ttsSanitize(text));
    }

    const optMap = new Map();
    (Array.isArray(q.options) ? q.options : []).forEach(op=>{
      const o = (typeof op === 'string') ? {label:op, value:op} : {...op};
      optMap.set(normalize(o.value), o);
    });
    const speakValue = (val)=>{
      const key = normalize(val);
      const o = optMap.get(key);
      return stripQuotesForTTS((o && (o.tts || o.label || o.value)) || String(val||''));
    };

    text = text.replace(/\{b(\d+)\}/gi, (_m, nStr)=>{
      const n = parseInt(nStr,10);
      let ans = null;
      if (Array.isArray(q.answer)) ans = q.answer[n-1];
      else if (q.answer && typeof q.answer==='object') ans = q.answer['b'+n] ?? q.answer[n] ?? q.answer[nStr];
      else ans = q.answer;
      return speakValue(ans);
    });

    const seqAnswers = (()=>{
      if (Array.isArray(q.answer)) return q.answer.slice();
      if (q.answer && typeof q.answer==='object'){
        const keys = Object.keys(q.answer).sort((a,b)=>{
          const na = parseInt(String(a).replace(/\D/g,'')) || 0;
          const nb = parseInt(String(b).replace(/\D/g,'')) || 0;
          return na-nb;
        });
        return keys.map(k=>q.answer[k]);
      }
      return [q.answer];
    })();

    let seqIdx = 0;
    text = text.replace(/\{blank\}|_{3,}/g, ()=>{
      const val = seqAnswers[Math.min(seqIdx, seqAnswers.length-1)];
      seqIdx++;
      return speakValue(val);
    });

    return stripQuotesForTTS(text);
  }

  /* =========================
     Audio helpers
  ========================= */
  function stopAllAudio(){
    try { speechSynthesis.cancel(); } catch(e){}
    if (currentAudio){
      try { currentAudio.pause(); currentAudio.currentTime = 0; } catch(e){}
      currentAudio = null;
    }
  }
  function speak(text){
    const t = String(text || '').trim();
    if(!t) return;
    try{
      const u = new SpeechSynthesisUtterance(t);
      u.lang = 'en-US'; u.rate = 0.95; u.pitch = 1.0;
      speechSynthesis.cancel(); speechSynthesis.speak(u);
    }catch(e){}
  }
  function speakFriendly(pool){
    const list = Array.isArray(pool) && pool.length ? pool : ['Great job!'];
    const pick = list[(Math.random()*list.length)|0];
    speak(pick);
  }

  /* =========================
     Audio da RESPOSTA (apenas audio_mcq)
  ========================= */
  function playAnswerAudio(q){
    stopAllAudio();

    if (!q || !Array.isArray(q.options)) return;

    const correctOpt = q.options.find(opt => normalize(opt.value) === normalize(q.answer));
    if (!correctOpt){
      const fallback = (q.options[0] && (q.options[0].tts || q.options[0].label || q.options[0].value)) || '';
      if (fallback) speak(fallback);
      return;
    }

    const phrase = (correctOpt.tts || correctOpt.label || correctOpt.value || '').toString().trim();

    if (correctOpt.audio){
      try{
        const a = new Audio(absPath(correctOpt.audio));
        currentAudio = a;
        a.onended = () => { currentAudio = null; };
        a.onerror  = () => { currentAudio = null; if (phrase) speak(phrase); };
        a.play().catch(() => { currentAudio = null; if (phrase) speak(phrase); });
      }catch(e){
        if (phrase) speak(phrase);
      }
    } else {
      if (phrase) speak(phrase);
    }
  }

  /* =========================
     Fallback buttons (optional tools)
  ========================= */
  function showFallbackButtons(){
    btnAlt1.classList.remove('is-hidden');
    btnAlt2.classList.remove('is-hidden');
  }
  function hideFallbackButtons(){
    btnAlt1.classList.add('is-hidden');
    btnAlt2.classList.add('is-hidden');
    btnAlt1.onclick = null;
    btnAlt2.onclick = null;
  }

  function wireFallbackButtons(){
    btnAlt1.onclick = async ()=>{
      showLoader(true);
      try{
        await new Promise((resolve) => ensureUserIsAuthenticated(()=>resolve()));
        if (!currentUserId) return;

        const allIds = await getAllQuestionIdsForUnit(levelDir, unitDir);
        const uaSnap = await firebase.database().ref(`userAnswers/${currentUserId}`).once('value');
        const uaAll = uaSnap.val() || {};

        const attempted = [];
        allIds.forEach(id=>{
          const ua = uaAll[id];
          if (!ua) return;
          attempted.push({ id, lastTimestamp: Number(ua.lastTimestamp || 0) });
        });

        if (!attempted.length){
          toast("No attempted questions found.");
          return;
        }

        attempted.sort((a,b)=>(a.lastTimestamp||0)-(b.lastTimestamp||0));
        const pick = attempted.slice(0, MAX_PER_ROUND).map(x=>x.id);

        const snaps = await Promise.all(pick.map(id=>firebase.database().ref(`questions/${id}`).once('value')));
        const list = [];
        snaps.forEach((s,i)=>{
          const v = s.val();
          if(!v) return;
          const q = {...v};
          q.id = q.id || pick[i];
          q.level = q.level || levelDir;
          q.unit  = q.unit  || unitDir;
          if (!q.type) q.type = "mcq";
          if (!Array.isArray(q.options)) q.options = [];
          list.push(q);
        });

        if (!list.length){
          toast("Could not load questions.");
          return;
        }

        resetReviewRoundCounter(levelDir, unitDir, currentUserId);
        questions = list;
        idx = 0;
        window.activityCompleted = false;

        hideFallbackButtons();
        btnPlayPrompt.disabled = false;
        renderQuestion();
      }catch(err){
        console.error("[Fallback] Review Oldest failed:", err);
        toast("Could not load oldest review.");
      }finally{
        showLoader(false);
      }
    };

    btnAlt2.onclick = async ()=>{
      showLoader(true);
      try{
        const allIds = await getAllQuestionIdsForUnit(levelDir, unitDir);
        if (!allIds.length){
          toast("No questions found for this unit.");
          return;
        }
        const pick = shuffle([...allIds]).slice(0, MAX_PER_ROUND);

        const snaps = await Promise.all(pick.map(id=>firebase.database().ref(`questions/${id}`).once('value')));
        const list = [];
        snaps.forEach((s,i)=>{
          const v = s.val();
          if(!v) return;
          const q = {...v};
          q.id = q.id || pick[i];
          q.level = q.level || levelDir;
          q.unit  = q.unit  || unitDir;
          if (!q.type) q.type = "mcq";
          if (!Array.isArray(q.options)) q.options = [];
          list.push(q);
        });

        if (!list.length){
          toast("Could not load questions.");
          return;
        }

        ensureUserIsAuthenticated(function(uid){
          if (uid) resetReviewRoundCounter(levelDir, unitDir, uid);
        });

        questions = list;
        idx = 0;
        window.activityCompleted = false;

        hideFallbackButtons();
        btnPlayPrompt.disabled = false;
        renderQuestion();
      }catch(err){
        console.error("[Fallback] Mixed Quiz failed:", err);
        toast("Could not load mixed quiz.");
      }finally{
        showLoader(false);
      }
    };
  }

  /* =========================
     REVIEW: UI states
  ========================= */
  function renderReviewCompleteState(){
    stopAllAudio();
    isReading = false;
    answered = true;

    bar.style.width = "100%";
    optionsEl.innerHTML = "";
    btnPlayPrompt.disabled = true;
    btnListenAnswer.classList.add("is-hidden");
    btnListenAnswer.disabled = true;
    btnNext.disabled = true;
    btnNext.classList.remove("ready");

    statusPill.textContent = "Review completed";

    promptEl.textContent =
      "üéâ Great job!\n" +
      "You completed the review.\n" +
      "You are ready for the evaluation.";

    mediaBox.innerHTML = '<div style="font-size:44px">üèÖ</div>';
    confetti(30);
    speakFriendly(["Great job!", "Awesome!", "You did it!"]);

    showFallbackButtons();
    wireFallbackButtons();

    window.activityCompleted = true;
  }

  function renderTakeABreakState(){
    stopAllAudio();
    isReading = false;
    answered = true;

    bar.style.width = "100%";
    optionsEl.innerHTML = "";
    btnPlayPrompt.disabled = true;
    btnListenAnswer.classList.add("is-hidden");
    btnListenAnswer.disabled = true;
    btnNext.disabled = true;
    btnNext.classList.remove("ready");

    statusPill.textContent = "Take a break";

    promptEl.textContent =
      "You worked hard!\n" +
      "Take a break and try again later.";

    mediaBox.innerHTML = `
      <div style="display:flex;flex-direction:column;gap:10px;align-items:center;justify-content:center;height:100%">
        <div style="font-size:44px">üß†</div>
        <button id="btnRetryLater"
          style="border:none;background:#eef2ff;color:#0f3ea8;font-weight:900;padding:12px 16px;border-radius:14px;cursor:pointer;box-shadow:0 6px 14px rgba(0,0,0,.06);">
          Try Again
        </button>
      </div>
    `;

    const b = document.getElementById("btnRetryLater");
    if (b){
      b.onclick = () => {
        resetReviewRoundCounter(levelDir, unitDir, currentUserId);
        location.reload();
      };
    }

    hideFallbackButtons();
    window.activityCompleted = false;
  }

  function renderContinueReviewState(remainingCount){
    stopAllAudio();
    isReading = false;
    answered = true;

    bar.style.width = "100%";
    optionsEl.innerHTML = "";
    btnPlayPrompt.disabled = true;
    btnListenAnswer.classList.add("is-hidden");
    btnListenAnswer.disabled = true;
    btnNext.disabled = true;
    btnNext.classList.remove("ready");

    statusPill.textContent = "Review round completed";

    const msg =
      `Good job!\n` +
      `You are getting better.\n\n` +
      `Questions that still need review: ${remainingCount}`;

    promptEl.textContent = msg;

    mediaBox.innerHTML = `
      <div style="display:flex;flex-direction:column;gap:10px;align-items:center;justify-content:center;height:100%">
        <div style="font-size:44px">üí™</div>
        <button id="btnContinueReview"
          style="border:none;background:linear-gradient(90deg,#3b82f6,#22c55e);color:#fff;font-weight:900;padding:12px 16px;border-radius:14px;cursor:pointer;box-shadow:0 10px 18px rgba(34,197,94,.25);">
          Continue Review
        </button>
      </div>
    `;

    hideFallbackButtons();

    const b = document.getElementById("btnContinueReview");
    if (b){
      b.onclick = async () => {
        showLoader(true);
        try{
          const plan = await buildRoundFromPending({ uid: currentUserId, levelKey: levelDir, unitKey: unitDir });

          if (plan.status === "complete" || !plan.selected.length){
            resetReviewRoundCounter(levelDir, unitDir, currentUserId);
            renderReviewCompleteState();
            markPhaseCompleted();
            return;
          }

          questions = plan.selected;
          idx = 0;
          answered = false;
          btnPlayPrompt.disabled = false;
          renderQuestion();
        }catch(err){
          console.error("[Review] Continue failed:", err);
          toast("Could not continue review.");
        }finally{
          showLoader(false);
        }
      };
    }

    window.activityCompleted = false;
  }

  function renderNoContentState(title, subtitleText){
    stopAllAudio();
    isReading = false;
    answered = true;

    bar.style.width = "0%";
    optionsEl.innerHTML = "";
    btnPlayPrompt.disabled = true;
    btnListenAnswer.classList.add("is-hidden");
    btnListenAnswer.disabled = true;
    btnNext.disabled = true;
    btnNext.classList.remove("ready");

    statusPill.textContent = "Review";

    promptEl.textContent = String(title || "No content.");
    mediaBox.innerHTML = `<div style="padding:10px;text-align:center;color:#334155">
      ${escapeHtml(String(subtitleText || ""))}
    </div>`;

    hideFallbackButtons();
    window.activityCompleted = false;
  }

  /* =========================
     Render current question
  ========================= */
  function renderQuestion(){
    answered = false;
    btnNext.disabled = true; btnNext.classList.remove('ready');
    btnNext.textContent = "Next";
    btnPlayPrompt.disabled = false;

    btnListenAnswer.classList.add('is-hidden');
    btnListenAnswer.disabled = true;
    btnListenAnswer.onclick = null;

    hideFallbackButtons();

    const q = questions[idx];
    if(!q){ finishRound(); return; }

    const pct = Math.round(((idx + 1)/questions.length)*100);
    bar.style.width = pct + '%';

    const roundsDone = getReviewRoundCounter(levelDir, unitDir, currentUserId);
    const roundDisplay = Math.min(roundsDone + 1, MAX_ROUNDS);
    statusPill.textContent = `Round ${roundDisplay} ‚Ä¢ Question ${idx+1}/${questions.length}`;

    const rawPrompt = q.prompt || '‚Äî';
    promptEl.innerHTML = renderPromptWithBlanks(rawPrompt);
    if (q.type === 'fillblank' && !/\{blank\}|\{b\d+\}|_{3,}/i.test(rawPrompt)) {
      const span = document.createElement('span');
      span.className = 'blank'; span.setAttribute('aria-hidden','true');
      promptEl.appendChild(document.createTextNode(' '));
      promptEl.appendChild(span);
    }

    btnPlayPrompt.onclick = () => { if (!isReading) playPrompt(q); };

    if (q.type === 'audio_mcq'){
      btnListenAnswer.classList.remove('is-hidden');
      btnListenAnswer.disabled = false;
      btnListenAnswer.onclick = () => {
        if (isReading) return;
        playAnswerAudio(q);
      };
    }

    mediaBox.innerHTML = '';
    if(q.image){
      const img = new Image(); img.alt = 'Question image';
      img.src = absPath(q.image); mediaBox.appendChild(img);
    } else {
      const img = new Image(); img.src = './hannah_pensando.png'; img.alt = 'Hannah thinking';
      mediaBox.appendChild(img);
    }

    optionsEl.innerHTML = '';
    optionsEl.classList.remove('is-order');

    if (q.type === 'order') {
      renderOrderQuestion(q);
    } else if (q.type === 'match') {
      renderMatchQuestion(q);
    } else {
      const opts = (q.shuffleOptions===false) ? q.options : shuffle([...q.options]);
      opts.forEach(opt => optionsEl.appendChild(makeOption(q, opt)));
    }

    btnNext.onclick = () => {
      (ensureAudio()? sfxTick() : sNext.play().catch(()=>{}));
      idx++;
      if (idx >= questions.length) { finishRound(); return; }
      renderQuestion();
    };
  }

  /* =========================
     Multiple-choice option
  ========================= */
  function makeOption(q, opt){
    const o = (typeof opt === 'string') ? { label: opt, value: opt } : { ...opt };

    const btn = document.createElement('button');
    btn.type = 'button'; btn.className = 'option';
    btn.setAttribute('aria-label', o.aria || o.label || 'option');

    const thumb = document.createElement('div'); thumb.className = 'thumb';
    if (o.image){
      const img = new Image(); img.src = absPath(o.image); img.alt = o.label || '';
      thumb.appendChild(img);
    } else if (o.emoji){
      thumb.textContent = o.emoji;
    } else {
      const box = document.createElement('span');
      box.className = 'square-outline';
      box.style.setProperty('--sq', '#7c3aed');
      thumb.textContent = ''; thumb.appendChild(box);
    }

    const textWrap = document.createElement('div');
    const label = document.createElement('div'); label.className = 'label'; label.textContent = o.label || '';
    textWrap.appendChild(label);
    if (typeof o.sub === 'string' && o.sub.trim()){
      const sub = document.createElement('div'); sub.className = 'sub'; sub.textContent = o.sub;
      textWrap.appendChild(sub);
    }

    btn.appendChild(thumb); btn.appendChild(textWrap);

    btn.onclick = () => {
      (ensureAudio()? sfxTick() : sTap.play().catch(()=>{}));
      speakSelectedThenCheck(q, o, btn);
    };
    thumb.style.cursor = 'pointer'; thumb.title = 'Play & choose';
    thumb.onclick = (e) => {
      e.preventDefault(); e.stopPropagation();
      (ensureAudio()? sfxTick() : sTap.play().catch(()=>{}));
      speakSelectedThenCheck(q, o, btn);
    };

    return btn;
  }

  /* =========================
     REVIEW RULE: no retries
     - After first decision:
         correct -> remove from pending, enable Next
         wrong   -> keep in pending, enable Next
  ========================= */
  async function applyReviewResult(q, isCorrect){
    try{
      if (!currentUserId || !q || !q.id) return;
      if (isCorrect){
        await removeFromPending(currentUserId, levelDir, unitDir, q.id);
      }
    }catch(err){
      console.warn("[Review] Could not update pending:", err);
    }
  }

  function lockAndEnableNext(){
    answered = true;
    btnNext.disabled = false;
    btnNext.classList.add('ready');
    Array.from(optionsEl.querySelectorAll('.option')).forEach(el => {
      try{ el.disabled = true; }catch(e){}
    });
  }

  /* =========================
     ORDER type (no retries)
  ========================= */
  function renderOrderQuestion(q){
    optionsEl.classList.add('is-order');

    const words = (q.options || []).map(w => String(w));
    const answerSeq = Array.isArray(q.answer) ? q.answer.map(String) : [];
    let built = [];
    let decided = false; // lock after first full attempt

    const wrap = document.createElement('div'); wrap.className = 'build-wrap';
    const tray = document.createElement('div'); tray.className = 'build-tray'; tray.id = 'buildTray';
    tray.setAttribute('aria-label','Sentence tray');
    const actions = document.createElement('div'); actions.className = 'build-actions';
    const undoBtn = document.createElement('button'); undoBtn.className = 'build-btn'; undoBtn.textContent = 'Undo';
    const clearBtn = document.createElement('button'); clearBtn.className = 'build-btn'; clearBtn.textContent = 'Clear';
    actions.appendChild(undoBtn); actions.appendChild(clearBtn);
    wrap.appendChild(tray); wrap.appendChild(actions);
    optionsEl.appendChild(wrap);

    const grid = document.createElement('div'); grid.className = 'build-grid';
    optionsEl.appendChild(grid);

    words.forEach(w=>{
      const b = document.createElement('button');
      b.type='button'; b.className='option word-only';
      b.innerHTML = `<div class="label">${escapeHtml(w)}</div>`;
      b.onclick = ()=>{
        if (decided) return;
        (ensureAudio()? sfxTick() : sTap.play().catch(()=>{}));
        if (built.length >= answerSeq.length) return;
        built.push(w);
        drawTray();
        checkBuilt();
      };
      grid.appendChild(b);
    });

    undoBtn.onclick = ()=>{
      if (decided) return;
      built.pop(); drawTray();
      btnNext.disabled = true; btnNext.classList.remove('ready');
    };
    clearBtn.onclick = ()=>{
      if (decided) return;
      built = []; drawTray();
      btnNext.disabled = true; btnNext.classList.remove('ready');
    };

    function drawTray(){
      tray.innerHTML = '';
      built.forEach(word=>{
        const chip = document.createElement('span');
        chip.className='word-chip';
        chip.textContent = word;
        tray.appendChild(chip);
      });
    }

    async function checkBuilt(){
      const sameLen = built.length === answerSeq.length;
      if (!sameLen || decided) return;

      decided = true;

      const ok = built.every((w,i)=> normalize(w) === normalize(answerSeq[i]));

      // Log attempt (kept)
      logAnswer(q, ok);

      if (ok){
        try{
          mediaBox.innerHTML = '';
          const gif = new Image(); gif.src = './hannah_feliz.gif'; gif.alt = 'Hannah celebrating';
          gif.setAttribute('draggable','false'); gif.style.pointerEvents = 'none';
          mediaBox.appendChild(gif);
        }catch(e){}
        confetti(18);
        (ensureAudio()? sfxCorrect() : sCorrect.play().catch(()=>{}));
        speakFriendly(['Great!','Awesome!']);
        liveEl.textContent = 'Correct order';

        await applyReviewResult(q, true);
      } else {
        (ensureAudio()? sfxWrong() : sWrong.play().catch(()=>{}));
        speakFriendly(['Try again next time!']);
        liveEl.textContent = 'Incorrect order';
        await applyReviewResult(q, false);
      }

      // lock UI & enable next (no retries)
      Array.from(optionsEl.querySelectorAll('.option')).forEach(el => { try{ el.disabled = true; }catch(e){} });
      undoBtn.disabled = true; clearBtn.disabled = true;

      btnNext.disabled = false; btnNext.classList.add('ready');
      answered = true;
    }
  }

  /* =========================
     MATCH type (no retries)
     - first wrong attempt ends (keeps in pending)
     - only if completes all pairs correctly without a wrong attempt -> correct
  ========================= */
  function renderMatchQuestion(q){
    const sourcePairs = Array.isArray(q.pairs) ? q.pairs : [];

    const normItem = (_side, it) => {
      if (typeof it === 'string') return { label: it, value: it };
      const o = {...it};
      if (!o.value) o.value = o.label || o.image || String(Math.random());
      return o;
    };

    const leftItems  = sourcePairs.map(p => normItem('left',  p.left));
    const rightItems = sourcePairs.map(p => normItem('right', p.right));

    const leftShuf  = shuffle([...leftItems]);
    const rightShuf = shuffle([...rightItems]);

    const grid = document.createElement('div'); grid.className = 'match-grid';
    const colL = document.createElement('div'); colL.className = 'match-col';
    const colR = document.createElement('div'); colR.className = 'match-col';
    grid.appendChild(colL); grid.appendChild(colR);
    optionsEl.appendChild(grid);

    let selectedLeftBtn = null;
    let selectedLeftVal = null;
    let matched = new Set();
    let decided = false;
    let anyWrong = false;

    const lockAll = ()=>{
      Array.from(optionsEl.querySelectorAll('.option')).forEach(el => { try{ el.disabled = true; }catch(e){} });
      answered = true;
      btnNext.disabled = false; btnNext.classList.add('ready');
    };

    const makeLeftBtn = (item) => {
      const b = document.createElement('button');
      b.type = 'button';
      b.className = 'option word-only';
      b.dataset.value = item.value;

      const label = document.createElement('div'); label.className = 'label'; label.textContent = item.label || item.value;
      b.appendChild(label);

      b.onclick = () => {
        if (decided) return;
        if (b.classList.contains('matched')) return;
        (ensureAudio()? sfxTick() : sTap.play().catch(()=>{}));
        Array.from(colL.children).forEach(el => el.classList.remove('selected'));
        b.classList.add('selected');
        selectedLeftBtn = b;
        selectedLeftVal = item.value;
      };
      return b;
    };

    const makeRightBtn = (item) => {
      const b = document.createElement('button');
      b.type = 'button';
      b.className = 'option';
      b.dataset.value = item.value;

      const thumb = document.createElement('div'); thumb.className = 'thumb';
      if (item.image){
        const img = new Image(); img.src = absPath(item.image); img.alt = item.label || '';
        thumb.appendChild(img);
      } else {
        thumb.textContent = item.label ? 'üî§' : '‚ùî';
      }

      const hasLabel = !!(item.label && String(item.label).trim());
      if (hasLabel){
        const label = document.createElement('div'); label.className = 'label'; label.textContent = item.label;
        b.appendChild(thumb); b.appendChild(label);
      } else {
        b.classList.add('img-only'); b.appendChild(thumb);
      }

      b.onclick = async ()=>{
        if (decided) return;
        if (b.classList.contains('matched')) return;
        if (!selectedLeftBtn){ toast('Choose a word first.'); return; }

        const leftVal  = selectedLeftVal;
        const rightVal = item.value;
        const ok = normalize(leftVal) === normalize(rightVal);

        if (ok){
          (ensureAudio()? sfxCorrect() : sCorrect.play().catch(()=>{}));
          confetti(10);
          speakFriendly(['Great!','Nice!']);

          b.classList.add('matched');
          selectedLeftBtn.classList.add('matched');
          selectedLeftBtn.classList.remove('selected');
          matched.add(leftVal);

          selectedLeftBtn = null;
          selectedLeftVal = null;

          if (matched.size === sourcePairs.length){
            decided = true;

            const finalCorrect = !anyWrong;
            logAnswer(q, finalCorrect);

            if (finalCorrect){
              try{
                mediaBox.innerHTML = '';
                const gif = new Image(); gif.src = './hannah_feliz.gif'; gif.alt = 'Hannah celebrating';
                gif.setAttribute('draggable','false'); gif.style.pointerEvents = 'none';
                mediaBox.appendChild(gif);
              }catch(e){}
              confetti(18);
              (ensureAudio()? sfxCorrect() : sCorrect.play().catch(()=>{}));
              speakFriendly(['Great!','Awesome!']);
              liveEl.textContent = 'All pairs matched';

              await applyReviewResult(q, true);
            } else {
              (ensureAudio()? sfxWrong() : sWrong.play().catch(()=>{}));
              speakFriendly(['Try again next time!']);
              liveEl.textContent = 'Match had an error';
              await applyReviewResult(q, false);
            }

            lockAll();
          }
        } else {
          anyWrong = true;
          decided = true;

          (ensureAudio()? sfxWrong() : sWrong.play().catch(()=>{}));
          speakFriendly(['Try again next time!']);
          b.classList.add('err');
          setTimeout(()=>b.classList.remove('err'), 250);
          liveEl.textContent = 'Incorrect match';

          logAnswer(q, false);
          await applyReviewResult(q, false);

          lockAll();
        }
      };
      return b;
    };

    leftShuf.forEach(item => colL.appendChild(makeLeftBtn(item)));
    rightShuf.forEach(item => colR.appendChild(makeRightBtn(item)));
  }

  /* =========================
     Selection flow for MCQ
     - NO retries in review
  ========================= */
  function disableOthers(keepBtn){
    Array.from(optionsEl.children).forEach(el=>{
      if(el!==keepBtn){ el.disabled = true; el.style.opacity = .5; }
    });
  }

  async function handleAnswer(q, opt, btn){
    if(answered) return;

    const isCorrect = normalize(opt.value) === normalize(q.answer);

    // Log attempt (kept)
    logAnswer(q, isCorrect);

    if(isCorrect){
      btn.classList.add('ok');
      (ensureAudio()? sfxCorrect() : sCorrect.play().catch(()=>{}));
      confetti(18);
      speakFriendly(['Yes! Great job!','Awesome!','You did it!']);
      try{
        mediaBox.innerHTML = '';
        const gif = new Image(); gif.src = './hannah_feliz.gif'; gif.alt = 'Hannah celebrating';
        gif.setAttribute('draggable','false'); gif.style.pointerEvents = 'none';
        mediaBox.appendChild(gif);
      }catch(e){}
      liveEl.textContent = 'Correct answer';

      disableOthers(btn);

      await applyReviewResult(q, true);
      lockAndEnableNext();
    } else {
      btn.classList.add('err');
      (ensureAudio()? sfxWrong() : sWrong.play().catch(()=>{}));
      speakFriendly(['Not this one!','Almost!']);
      liveEl.textContent = 'Incorrect answer';

      disableOthers(btn);

      await applyReviewResult(q, false);
      lockAndEnableNext();
    }
  }

  function playPrompt(q){
    stopAllAudio();
    const spoken = buildSpokenPrompt(q);
    if (q.promptAudio){
      const a = new Audio(absPath(q.promptAudio));
      currentAudio = a;
      a.onended = () => { currentAudio = null; };
      a.onerror  = () => { currentAudio = null; speak(spoken); };
      a.play().catch(() => { currentAudio = null; speak(spoken); });
    } else {
      speak(spoken);
    }
  }

  function speakSelectedThenCheck(q, o, btn){
    if (answered || isReading) return;
    isReading = true;

    const allBtns = Array.from(document.querySelectorAll('.option'));
    allBtns.forEach(el => el.disabled = true);
    btnNext.disabled = true; btnNext.classList.remove('ready');

    const finish = () => {
      isReading = false;
      // We do NOT re-enable all options after a selection; the selection itself decides and locks.
      handleAnswer(q, o, btn);
    };

    const say = (o.tts || o.label || o.value || '').toString().trim();
    stopAllAudio();

    if (o.audio){
      try{
        const a = new Audio(absPath(o.audio));
        currentAudio = a;
        let done = false;
        const safeFinish = () => { if (!done){ done = true; currentAudio = null; finish(); } };
        a.onended = safeFinish;
        a.onerror = safeFinish;
        a.onloadedmetadata = () => {
          const guard = Math.max(1500, Math.round((a.duration||0)*1000) + 1500);
          setTimeout(safeFinish, guard + 500);
        };
        a.play().catch(safeFinish);
      }catch{
        setTimeout(finish, 800);
      }
    } else {
      try{
        const u = new SpeechSynthesisUtterance(say || ' ');
        u.lang = 'en-US'; u.rate = 0.95; u.pitch = 1.0;
        u.onend   = finish;
        u.onerror = finish;
        speechSynthesis.cancel(); speechSynthesis.speak(u);
        setTimeout(()=>{ if(isReading) finish(); }, 15000);
      }catch{
        setTimeout(finish, 800);
      }
    }
  }

  /* =========================
     Finish of a ROUND
     - Round ends after answering current batch (<=15)
     - Then we check pending:
        if empty => complete + unlock
        else => increment round counter and show Continue (or Take a break)
  ========================= */
  async function finishRound(){
    try { stopAllAudio(); } catch(e){} try { speechSynthesis.cancel(); } catch(e){}
    isReading = false;

    bar.style.width = '100%';
    optionsEl.innerHTML = '';

    btnPlayPrompt.disabled = true;
    btnListenAnswer.classList.add('is-hidden');
    btnListenAnswer.disabled = true;

    showLoader(true);
    try{
      await new Promise((resolve)=>ensureUserIsAuthenticated(()=>resolve()));
      if (!currentUserId){
        renderNoContentState("User not authenticated.", "Please login again.");
        return;
      }

      const pendingMap = await getPendingMap(currentUserId, levelDir, unitDir);
      const remainingCount = Object.keys(pendingMap || {}).length;

      if (remainingCount === 0){
        resetReviewRoundCounter(levelDir, unitDir, currentUserId);
        renderReviewCompleteState();
        markPhaseCompleted();
        return;
      }

      incrementReviewRoundCounter(levelDir, unitDir, currentUserId);
      const rounds = getReviewRoundCounter(levelDir, unitDir, currentUserId);

      if (rounds >= MAX_ROUNDS){
        renderTakeABreakState();
        return;
      }

      renderContinueReviewState(remainingCount);

    }catch(err){
      console.error("[Review] Finish failed:", err);
      renderNoContentState("Could not load review data.", "Please try again.");
    }finally{
      showLoader(false);
    }
  }

  /* =========================
     Init review
     - ensure queue exists (build from history if empty)
     - then build current round from pending
  ========================= */
  async function initReview(){
    showLoader(true);
    try{
      await new Promise((resolve)=>ensureUserIsAuthenticated(()=>resolve()));
      if (!currentUserId){
        renderNoContentState("User not authenticated.", "Please login again.");
        return;
      }

      const title = await loadTitleFromFile();
      subtitle.textContent = title ? `${title} ‚Äî Review` : "Review mode";

      const rounds = getReviewRoundCounter(levelDir, unitDir, currentUserId);
      if (rounds >= MAX_ROUNDS){
        renderTakeABreakState();
        return;
      }

      await ensureReviewQueue({ uid: currentUserId, levelKey: levelDir, unitKey: unitDir });

      const plan = await buildRoundFromPending({ uid: currentUserId, levelKey: levelDir, unitKey: unitDir });
      if (plan.status === "complete" || !plan.selected.length){
        resetReviewRoundCounter(levelDir, unitDir, currentUserId);
        renderReviewCompleteState();
        markPhaseCompleted();
        return;
      }

      questions = plan.selected;
      idx = 0;
      hideFallbackButtons();
      renderQuestion();

    }catch(err){
      console.error("[Review] Init failed:", err);
      renderNoContentState("Could not load review.", "Please try again.");
    }finally{
      showLoader(false);
    }
  }

  /* =========================
     Boot
  ========================= */
  window.addEventListener('load', function(){
    window.activityCompleted = false;
    initReview();
  });

})();
</script>

</body>
</html>
