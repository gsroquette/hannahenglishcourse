<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hannah Test</title>
    <style>
        /* Estilos existentes mantidos */
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-image: url('../../../imagens/fundo.png');
            background-repeat: repeat;
            background-size: auto;
            background-color: white;
        }

        h1 {
            text-align: center;
            font-size: 2.5em;
            color: #333;
            margin-bottom: 20px;
        }
 
.back-btn {
    background-color: #4CAF50; /* Cor verde consistente com outros botões */
    color: white;
    padding: 10px 20px;
    font-size: 1em;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.3s ease;
}

.back-btn:hover {
    background-color: #45a049; /* Efeito hover consistente */
}

/* Estilos de nota simplificados */
    .grade-style, .grade-style-red {
        text-align: center;
        font-size: 1.4em;
        color: #FF0000; /* Cor vermelha para nota baixa */
        font-weight: bold;
        margin-bottom: 20px;
    }

    /* Cor verde para notas altas */
    .grade-style {
        color: #4CAF50;
    }

    /* Mensagem do professor */
    .grade-style span {
        color: red;
        font-size: 0.9em;
        display: block;
        margin-top: 5px;
    }
      
        .question-container {
            display: flex;
            justify-content: center;
        }

        .question {
            margin-bottom: 10px;
            font-size: 1.2em;
            padding: 20px;
            text-align: left;
            border: none;
        }

        label {
            display: block;
            font-size: 1em;
            margin-bottom: 10px;
        }

        .btn-group {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 5px;
        }

        button {
            padding: 10px 20px;
            font-size: 1em;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .prev-btn, .next-btn {
            background-color: #4CAF50;
            color: white;
        }

        .prev-btn:hover, .next-btn:hover {
            background-color: #45a049;
        }

        .read-btn {
            background-color: #FF9800;
            color: white;
        }

        .read-btn:hover {
            background-color: #FB8C00;
        }

        .pdf-btn {
            background-color: #03A9F4;
            color: white;
        }

        .pdf-btn:hover {
            background-color: #0288D1;
        }
      
        /* Modal de conclusão */
  #completion-modal {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: white;
    padding: 20px;
    border: 2px solid #333;
    box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1);
    z-index: 1000;
    text-align: center;
    visibility: visible; /* Adicionado */
    opacity: 1; /* Adicionado */
}

#completion-modal button {
    margin-top: 20px;
    padding: 10px 20px;
    background-color: #333;
    color: white;
    border: none;
    cursor: pointer;
}

#completion-modal button:hover {
    background-color: #555;
}

        #overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }
    </style>
</head>
<body>
<div class="btn-group">
    <button class="back-btn" onclick="goBack()">Back</button>
</div>

<h1>Hannah Test</h1>

<div id="grade-display" class="grade-style" style="display: none;"></div>

<div class="btn-group">
    <button class="read-btn" id="read-btn" onclick="readQuestion()">Read</button>
 <button class="prev-btn" id="prev-btn" onclick="stopReading(); showPreviousQuestion()">Previous</button>
<button class="next-btn" id="next-btn" onclick="stopReading(); showNextQuestion()">Next</button>
</div>

<div id="quiz-container" class="question-container"></div>

<!-- Modal de conclusão -->
<div id="overlay"></div>
<div id="completion-modal">
    <h2>Phase Completed!</h2>
    <p>Congratulations! You have completed this phase.</p>
    <button onclick="closeModal()">Close</button>
</div>

<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

<script>
// Configuração do Firebase
const firebaseConfig = {
    apiKey: "AIzaSyDGgo2H_hDKXF88xN7XnLFNUj8ikMY7Xdc",
    authDomain: "hannahenglishcourse.firebaseapp.com",
    projectId: "hannahenglishcourse",
    storageBucket: "hannahenglishcourse.appspot.com",
    messagingSenderId: "449818788486",
    appId: "1:449818788486:web:8a49d3f68591e6fb3f0707",
    measurementId: "G-07VVJG9LRS",
    databaseURL: "https://hannahenglishcourse-default-rtdb.asia-southeast1.firebasedatabase.app"
};

// Inicializa o Firebase
firebase.initializeApp(firebaseConfig);

// Variáveis globais
let gradeRef;
let correctAnswers = 0;
let totalQuestions = 0;
let currentQuestionIndex = 0;
let questions = [];
let answeredQuestions = [];
let selectedAnswers = [];
let speechSynthesisUtterance = null;

function goBack() {
    const { level, unit, fase } = getParamsFromURL();

    ensureUserIsAuthenticated((userId) => {
        const dbRef = firebase.database().ref(`usuarios/${userId}/progresso/${level}/${unit}`);

        dbRef.get()
            .then((snapshot) => {
                if (snapshot.exists()) {
                    const progress = snapshot.val();

                    if (fase === "last") {
                        // Verificar próxima unidade
                        const nextUnit = `Unit${parseInt(unit.replace("Unit", "")) + 1}`;
                        const nextPhaseKey = `${nextUnit}/fase1`;

                        firebase.database().ref(`usuarios/${userId}/progresso/${level}/${nextUnit}`)
                            .get()
                            .then((unitSnapshot) => {
                                if (unitSnapshot.exists() && unitSnapshot.val().fase1) {
                                    window.history.back(); // Navegação permitida
                                } else {
                                    // Unidade bloqueada
                                    confirmBackNavigation("The next unit is locked. Do you still want to go back?");
                                }
                            });
                    } else if (fase === "end") {
                        // Verificar próximo nível
                        const nextLevel = `Level${parseInt(level.replace("Level", "")) + 1}`;
                        const nextPhaseKey = `${nextLevel}/Unit1/fase1`;

                        firebase.database().ref(`usuarios/${userId}/progresso/${nextLevel}/Unit1`)
                            .get()
                            .then((levelSnapshot) => {
                                if (levelSnapshot.exists() && levelSnapshot.val().fase1) {
                                    window.history.back(); // Navegação permitida
                                } else {
                                    // Nível bloqueado
                                    confirmBackNavigation("The next level is locked. Do you still want to go back?");
                                }
                            });
                    } else {
                        // Lógica padrão para fases numéricas
                        const nextFaseKey = `fase${parseInt(fase, 10) + 1}`;

                        if (progress[nextFaseKey]) {
                            // Próxima fase desbloqueada, permite navegação
                            window.history.back();
                        } else {
                            // Próxima fase bloqueada, solicita confirmação
                            confirmBackNavigation("The next phase is locked. Do you still want to go back?");
                        }
                    }
                } else {
                    alert("Progress could not be verified. Please try again later.");
                }
            })
            .catch((error) => {
                console.error("Error checking progress:", error);
                alert("An error occurred while verifying progress. Please try again.");
            });
    });
}

function confirmBackNavigation(message) {
    const confirmNavigation = confirm(message);
    if (confirmNavigation) {
        window.history.back();
    }
}

// Função para exibir erros ao usuário
function handleError(message) {
    const modal = document.getElementById("completion-modal");
    modal.innerHTML = `<p style="color: red;">${message}</p>`;
    modal.style.display = "block";
    console.error(message);
}

// Função para carregar as perguntas
async function loadQuestions() {
    try {
        const { level, unit } = getParamsFromURL();
        const questionFilePath = `../../../../${level}/${unit}/DataTestQuizLeVeAB/questions.txt`;

        console.log("Loading questions from:", questionFilePath); // Log para depuração

        const response = await fetch(questionFilePath);
        if (!response.ok) throw new Error("Failed to load questions");

        const text = await response.text();
        if (!text.trim()) throw new Error("Questions file is empty");

        const lines = text.split("\n");
        let currentQuestion = null;

        lines.forEach((line) => {
            line = line.trim();
            if (line.startsWith("Q:")) {
                if (currentQuestion) questions.push(currentQuestion);
                currentQuestion = { question: line.substring(2).trim(), answers: [], correct: "" };
            } else if (/^[A-D]\./.test(line)) {
                currentQuestion.answers.push(line);
            } else if (line.startsWith("Correct:")) {
                if (currentQuestion) currentQuestion.correct = line.split(":")[1].trim();
            }
        });

        if (currentQuestion) questions.push(currentQuestion);

        if (questions.length === 0) throw new Error("No valid questions found");

        console.log("Questions loaded successfully:", questions); // Verifica o carregamento
        answeredQuestions = new Array(questions.length).fill(false);
        totalQuestions = questions.length;
        displayQuestion();
    } catch (error) {
        handleError(error.message);
    }
}

function readQuestion() {
    if (!questions.length) {
        alert("No questions loaded to read.");
        return;
    }

    const questionText = questions[currentQuestionIndex].question;
    const utterance = new SpeechSynthesisUtterance(questionText);
    utterance.lang = "en-US"; // Definir o idioma para inglês
    speechSynthesis.speak(utterance);
}

// Função para exibir a questão atual
function displayQuestion() {
    const container = document.getElementById("quiz-container");
    container.innerHTML = "";

    if (!questions || questions.length === 0) {
        console.error("No questions available to display.");
        container.innerHTML = "<p>No questions loaded.</p>";
        return;
    }

    const q = questions[currentQuestionIndex];

    const questionDiv = document.createElement("div");
    questionDiv.classList.add("question");

    // Adiciona a imagem
    const { level, unit } = getParamsFromURL();
    const questionImagePath = `../../../../${level}/${unit}/DataTestQuizLeVeAB/images/imagem${currentQuestionIndex + 1}.png`;
    console.log("Image path:", questionImagePath); // Log para depuração

    const questionImage = document.createElement("img");
questionImage.src = questionImagePath;
questionImage.alt = `Image not found for question ${currentQuestionIndex + 1}`;
questionImage.onerror = function () {
    console.error(`Image not found: ${questionImagePath}`);
    questionImage.src = "../../../imagens/placeholder.png"; // Imagem padrão
};
questionImage.style.width = "100%";
questionImage.style.maxHeight = "300px";
questionDiv.appendChild(questionImage);

    // Adiciona o texto da questão
    const questionText = document.createElement("p");
    questionText.id = "question-text";
    questionText.innerText = `${currentQuestionIndex + 1}. ${q.question}`;
    questionDiv.appendChild(questionText);

    // Adiciona as opções de resposta
    q.answers.forEach((answer) => {
        const answerLabel = document.createElement("label");
        const isChecked = selectedAnswers[currentQuestionIndex] === answer[0];
        answerLabel.innerHTML = `<input type="radio" name="question${currentQuestionIndex}" value="${answer[0]}" onclick="selectAnswer('${answer[0]}')" ${isChecked ? "checked" : ""}> ${answer}`;
        questionDiv.appendChild(answerLabel);
    });

    container.appendChild(questionDiv);
    updateNavigationButtons();
}

function stopReading() {
    if (speechSynthesis.speaking || speechSynthesis.pending) {
        speechSynthesis.cancel();
        console.log("Speech synthesis stopped.");
    }
}

// Navegação entre perguntas
function showNextQuestion() {
    if (questions.length === 0) {
        alert("No questions loaded.");
        return;
    }

    if (currentQuestionIndex < questions.length - 1) {
        // Avança para a próxima questão
        currentQuestionIndex++;
        console.log("Next Question Index:", currentQuestionIndex);
        displayQuestion();
    } else if (allQuestionsAnswered()) {
        // Última questão e todas respondidas: verifica a conclusão
        console.log("End of phase reached.");
        checkCompletion();
    } else {
        alert("Please answer all questions before completing the quiz.");
    }
}

function showPreviousQuestion() {
    if (questions.length === 0) {
        alert("No questions loaded.");
        return;
    }
    if (currentQuestionIndex > 0) {
        currentQuestionIndex--;
        console.log("Previous Question Index:", currentQuestionIndex);
        displayQuestion();
    } else {
        alert("This is the first question.");
    }
}

function updateNavigationButtons() {
    const prevBtn = document.getElementById("prev-btn");
    const nextBtn = document.getElementById("next-btn");

    prevBtn.disabled = currentQuestionIndex === 0;
    nextBtn.disabled = currentQuestionIndex === questions.length - 1;

    console.log("Previous button disabled:", prevBtn.disabled);
    console.log("Next button disabled:", nextBtn.disabled);
}

// Verificação de respostas
function selectAnswer(answer) {
    selectedAnswers[currentQuestionIndex] = answer;
    checkAnswer(answer);

    // Marca a questão como respondida
    answeredQuestions[currentQuestionIndex] = true;

    // Verifica automaticamente a conclusão se todas as questões foram respondidas
    if (allQuestionsAnswered() && currentQuestionIndex === questions.length - 1) {
        checkCompletion();
    }
}

function checkAnswer(selectedAnswer) {
    const q = questions[currentQuestionIndex];

    if (selectedAnswer === q.correct && !answeredQuestions[currentQuestionIndex]) {
        answeredQuestions[currentQuestionIndex] = true;
        correctAnswers++;
    } else if (selectedAnswer !== q.correct && answeredQuestions[currentQuestionIndex]) {
        answeredQuestions[currentQuestionIndex] = false;
        correctAnswers--;
    }
}

function allQuestionsAnswered() {
    return answeredQuestions.every((answered) => answered); // Verifica se todas foram respondidas
}

// Verifica se o quiz foi concluído
function checkCompletion() {
    if (!allQuestionsAnswered()) {
        alert("Please answer all questions before completing the quiz.");
        return;
    }

    const grade = Math.round((correctAnswers / totalQuestions) * 100);
    console.log("Grade calculated:", grade, "Correct Answers:", correctAnswers, "Total Questions:", totalQuestions);

    ensureUserIsAuthenticated(async (userId) => {
        try {
            await saveGrade(userId, grade); // Salva a nota no banco de dados
            await updateProgressInDatabase(userId, grade); // Atualiza o progresso
        } catch (error) {
            console.error("Error saving grade or updating progress:", error);
            showModal("An error occurred while saving your progress. Please try again.");
            return;
        }

        // Exibe o modal baseado na nota
        const message = grade >= 70 
            ? "Congratulations! You passed!" 
            : "You did not pass. Try again!";
        showModal(message);
    });
}

// Atualiza o progresso no banco de dados
async function updateProgressInDatabase(userId, grade) {
    const { level, unit } = getParamsFromURL();
    console.log("Updating progress for:", { level, unit, grade });

    try {
        if (grade >= 70) {
            const currentPhase = getPhaseFromURL();
            const dbRef = firebase.database().ref(`usuarios/${userId}/progresso/${level}/${unit}`);

            if (currentPhase === "last") {
                // Desbloqueia a próxima unidade
                const nextUnit = `Unit${parseInt(unit.replace("Unit", "")) + 1}`;
                await dbRef.parent.child(nextUnit).set({ fase1: true });
                console.log(`Next unit unlocked: ${nextUnit}`);
            } else if (currentPhase === "end") {
                // Desbloqueia o próximo nível
                const nextLevel = `Level${parseInt(level.replace("Level", "")) + 1}`;
                await firebase.database()
                    .ref(`usuarios/${userId}/progresso/${nextLevel}/Unit1`)
                    .set({ fase1: true });
                console.log(`Next level unlocked: ${nextLevel}`);
            } else {
                // Desbloqueia a próxima fase
                const nextPhase = `fase${parseInt(currentPhase) + 1}`;
                await dbRef.update({ [nextPhase]: true });
                console.log(`Next phase unlocked: ${nextPhase}`);
            }
        } else {
            console.log("Grade below passing threshold; no progress updated.");
        }
    } catch (error) {
        console.error("Error updating progress:", error);
        handleError("Failed to update progress. Please try again.");
    }
}

async function loadGrade(userId) {
    const { level, unit } = getParamsFromURL();
    const dbRef = firebase.database().ref(`usuarios/${userId}/progresso/${level}/${unit}/Quiz test - question and image`);
    const gradeDisplay = document.getElementById("grade-display");

    try {
        const snapshot = await dbRef.once("value");
        const grade = snapshot.val();

        if (grade !== null) {
            gradeDisplay.style.display = "block"; 
            gradeDisplay.innerHTML = `Your Grade: ${grade}%`;

            // Estilo da nota
            if (grade < 70) {
                gradeDisplay.classList.add("grade-style-red");
                gradeDisplay.classList.remove("grade-style");
            } else {
                gradeDisplay.classList.add("grade-style");
                gradeDisplay.classList.remove("grade-style-red");
            }

            // Verifica se o aluno está vinculado a um professor
            const isLinked = await isStudentLinkedToProfessor(userId);
            if (isLinked) {
                gradeDisplay.innerHTML += "<br><span style='color: red;'>Only your teacher can modify this grade</span>";
            }
        } else {
            gradeDisplay.style.display = "none"; // Oculta se não houver nota
        }
    } catch (error) {
        console.error("Error loading grade:", error);
    }
}

// Salva a nota do usuário
async function saveGrade(userId, grade) {
    const { level, unit } = getParamsFromURL();
    const dbRef = firebase.database().ref(`usuarios/${userId}/progresso/${level}/${unit}/Quiz test - question and image`);

    try {
        const snapshot = await dbRef.once("value");
        const existingGrade = snapshot.val();

        if (!existingGrade || existingGrade === 0) {
            // Se a nota não existir ou for 0, permite salvar
            await dbRef.set(grade);
            console.log("Grade saved successfully:", grade);
        } else {
            // Nota já existe, exibe mensagem no console
            console.log("Grade already exists and cannot be changed by the student.");
        }
    } catch (error) {
        console.error("Error saving grade:", error);
    }
}

async function isStudentLinkedToProfessor(userId) {
    const dbRef = firebase.database().ref(`usuarios/${userId}/professor`);
    try {
        const snapshot = await dbRef.once("value");
        return snapshot.exists(); // Retorna true se o nó professor existir
    } catch (error) {
        console.error("Error checking professor linkage:", error);
        return false;
    }
}

function generatePDF() {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF();

    // Adiciona o logo
    const logo = new Image();
    logo.src = 'Logo.png';

    logo.onload = () => {
        // Adiciona o logo no topo
        doc.addImage(logo, 'PNG', 90, 10, 30, 30);

        // Adiciona o título
        doc.setFontSize(20);
        doc.text('Hannah Quiz', 105, 50, null, null, 'center');

        // Adiciona campos para nome e data
        doc.setFontSize(12);
        doc.text('Name: ____________________________________', 20, 70);
        doc.text('Date: _______________', 150, 70);

        let yPosition = 90;

        // Adiciona as perguntas e respostas
        questions.forEach((q, index) => {
            doc.setFontSize(14);
            let questionText = `${index + 1}. ${q.question}`;
            let textLines = doc.splitTextToSize(questionText, 180);
            let questionHeight = textLines.length * 10;

            // Verifica se a página está cheia e adiciona uma nova página, se necessário
            if (yPosition + questionHeight > 280) {
                doc.addPage();
                yPosition = 20;
            }

            doc.text(textLines, 20, yPosition);
            yPosition += questionHeight;

            q.answers.forEach(answer => {
                doc.setFontSize(12);
                let answerText = answer;
                let answerLines = doc.splitTextToSize(answerText, 180);
                let answerHeight = answerLines.length * 10;

                if (yPosition + answerHeight > 280) {
                    doc.addPage();
                    yPosition = 20;
                }

                doc.text(answerLines, 30, yPosition);
                yPosition += answerHeight;
            });

            yPosition += 10; // Espaçamento entre perguntas
        });

        // Salva o PDF
        doc.save('QuizQuestionsWithLogo.pdf');
    };

    // Verifica se o logo já foi carregado
    if (logo.complete) logo.onload();
}

// Exibição de modais
function showModal(message) {
    console.log("Displaying modal with message:", message);
    const modal = document.getElementById("completion-modal");
    const overlay = document.getElementById("overlay");
    if (!modal || !overlay) {
        console.error("Modal or overlay element not found!");
        return;
    }
    modal.innerHTML = `
        <h2>${message}</h2>
        <p>Your score: ${Math.round((correctAnswers / totalQuestions) * 100)}%</p>
        <p>Total Questions: ${totalQuestions}</p>
        <p>Correct Answers: ${correctAnswers}</p>
        <button onclick="closeModal()">Close</button>
    `;
    modal.style.display = "block";
    overlay.style.display = "block";
}

function closeModal() {
    const modal = document.getElementById("completion-modal");
    const overlay = document.getElementById("overlay");
    if (modal) modal.style.display = "none";
    if (overlay) overlay.style.display = "none";
}

// Obter parâmetros da URL
function getParamsFromURL() {
    const params = new URLSearchParams(window.location.search);
    return {
        level: params.get("level") || "Level1",
        unit: params.get("unit") || "Unit1",
        fase: params.get("fase") || "fase1",
    };
}

function getPhaseFromURL() {
    const params = new URLSearchParams(window.location.search);
    return params.get("fase");
}

function ensureUserIsAuthenticated(callback) {
    firebase.auth().onAuthStateChanged((user) => {
        if (user) {
            const userId = user.uid;
            // Verificar o role do usuário
            const roleRef = firebase.database().ref(`usuarios/${userId}/role`);
            
            roleRef.once('value')
                .then((snapshot) => {
                    const role = snapshot.val();
                    console.log("User role:", role); // Log para depuração
                    if (role === 'professor' || role === 'proprietario') {
                        displayPDFButton(); // Exibe o botão PDF
                    }
                    // Chama o callback com o userId
                    callback(userId);
                })
                .catch((error) => {
                    console.error("Error fetching role:", error);
                    handleError("An error occurred while verifying your access.");
                });
        } else {
            handleError("You need to be logged in to continue.");
            // Redireciona para a página de login ou recarrega a página
            setTimeout(() => {
                window.location.href = "/login.html"; // Substitua pelo caminho da página de login
            }, 3000);
        }
    });
}

function displayPDFButton() {
    const btnGroup = document.querySelector('.btn-group'); // Encontre o grupo de botões
    if (!btnGroup) {
        console.error("Button group not found!");
        return;
    }

    // Verifica se o botão já existe
    if (document.querySelector('.pdf-btn')) {
        console.log("PDF button already exists.");
        return;
    }

    const pdfButton = document.createElement('button'); // Crie o botão dinamicamente
    pdfButton.className = 'pdf-btn';
    pdfButton.textContent = 'Generate PDF';
    pdfButton.onclick = generatePDF; // Conecte à função de gerar PDF
    btnGroup.appendChild(pdfButton); // Adicione ao DOM
}

window.onload = () => {
    ensureUserIsAuthenticated((userId) => {
        loadGrade(userId); // Carrega a nota do banco de dados
        loadQuestions();   // Carrega as perguntas do quiz
    });
};

</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
</body>
</html>
