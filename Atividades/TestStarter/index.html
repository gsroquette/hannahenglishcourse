<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Hannah Questions ‚Äî Grammar Test</title>
<style>
  :root{
    --bg:#f7f9fc; --card:#ffffff; --text:#1f2937; --muted:#6b7280;
    --ok:#16a34a; --warn:#ef4444; --brand:#2563eb;
    --shadow:0 10px 25px rgba(0,0,0,.08); --radius:18px;
  }
  *{box-sizing:border-box}
  html,body{margin:0}
  body{
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,'Helvetica Neue',Arial;
    background:url('../../imagens/fundo.png') center/cover no-repeat, var(--bg);
    color:var(--text);
  }

  .app{
    width:100%;
    max-width:1140px;
    margin: 12px auto 24px auto;
    background:var(--card);
    border-radius:var(--radius);
    box-shadow:var(--shadow);
    padding:16px;
    position:relative;
    overflow:visible;
  }

  #back-button{
    display:inline-flex; align-items:center; gap:.5rem;
    width:auto !important; max-width:none; margin-bottom:8px;
    border:none; background:#eef2ff; color:#0f3ea8;
    padding:8px 12px; border-radius:10px; font-weight:700; cursor:pointer;
    box-shadow:0 6px 14px rgba(0,0,0,.06);
  }
  #back-button:active{ transform: translateY(1px); }

  .header{
    display:grid; grid-template-columns:auto 1fr auto; align-items:center; gap:12px; margin-bottom:12px;
  }
  .avatar{ width:48px;height:48px;border-radius:50%; background:#e5f0ff;border:2px solid #cfe0ff; display:flex;align-items:center;justify-content:center;overflow:hidden; }
  .avatar img{width:100%;height:100%;object-fit:contain;border-radius:50%;display:block}
  .title-wrap{min-width:0}
  .title{font-weight:800;font-size:20px;line-height:1.2;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .subtitle{color:var(--muted);font-size:14px;line-height:1.2;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .progress{height:8px;background:#eef2f7;border-radius:999px;overflow:hidden;margin-top:8px}
  .progress > div{height:100%;width:0%;background:linear-gradient(90deg,#60a5fa,#34d399);transition:width .3s ease}
  .badge{max-width:42ch;background:#eef2ff;border:1px solid #d7defc;color:#3949ab;padding:8px 10px;border-radius:999px;font-size:12px;line-height:1;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}

  .stage{display:grid;gap:16px}
  .question-card{ background:#f9fbff;border:1px solid #e5eaf5;border-radius:16px;padding:14px; margin: 0 auto; }

  .q-top{display:flex;flex-direction:column;gap:14px}

  .prompt-row{
    display:flex; align-items:flex-start; gap:10px;
  }
  .prompt-audio-icon{
    border:none;
    background:#e6f0ff;
    color:#0f3ea8;
    width:38px; height:38px;
    border-radius:12px;
    cursor:pointer;
    font-weight:900;
    display:inline-flex; align-items:center; justify-content:center;
    box-shadow:0 4px 12px rgba(0,0,0,.03);
    flex:0 0 38px;
    user-select:none;
  }
  .prompt-audio-icon:active{transform:translateY(1px)}
  .prompt-audio-icon[disabled]{opacity:.4;pointer-events:none}

  .q-prompt{font-size:22px;font-weight:800;line-height:1.3;word-break:break-word}

  .q-controls{display:flex;gap:8px;align-items:center;margin-top:8px;flex-wrap:wrap}
  .icon-btn{border:none;background:#e6f0ff;color:#0f3ea8;padding:10px 12px;border-radius:12px;cursor:pointer;font-weight:700}
  .icon-btn:active{transform:translateY(1px)}
  .icon-btn[disabled]{opacity:.4;pointer-events:none}
  .is-hidden{display:none!important}

  .q-media{width:100%;aspect-ratio:16/10;background:#eef4ff;border:1px dashed #cfe0ff;border-radius:14px;padding:8px;overflow:hidden;display:block}
  .q-media img{width:100%;height:100%;object-fit:contain;display:block}
  @supports not (aspect-ratio:16/10){.q-media{height:220px}}

  .options{display:grid;gap:10px;margin-top:6px;grid-template-columns:repeat(2,minmax(0,1fr))}
  .option{
    display:flex;align-items:center;gap:12px;background:#fff;border:2px solid #e9eef7;border-radius:18px;
    padding:12px;cursor:pointer;user-select:none;min-height:78px;
    box-shadow:0 4px 12px rgba(0,0,0,.03);
    transition:transform .06s ease,border-color .15s ease,box-shadow .15s ease
  }
  .option:hover{transform:translateY(-1px);box-shadow:0 8px 18px rgba(0,0,0,.06)}
  .option:active{transform:translateY(0)}
  .option .thumb{width:60px;height:60px;border-radius:14px;background:#f3f6ff;border:1px solid #e6ecfb;overflow:hidden;display:flex;align-items:center;justify-content:center;font-size:30px;flex:0 0 60px}
  .option .thumb img{width:100%;height:100%;object-fit:contain;padding:6px;display:block}
  .option.img-only{justify-content:center;gap:0}
  .option .label{font-size:19px;font-weight:800;letter-spacing:.2px;word-break:break-word}
  .option .sub{font-size:13px;color:var(--muted)}

  .square-outline{width:38px;height:38px;border:6px solid var(--sq,#7c3aed);border-radius:10px;background:transparent;display:inline-block;position:relative;transition:border-color .2s ease,background .2s ease,transform .15s ease}
  .option.ok .square-outline{border-color:#16a34a;background:#dcfce7}
  .option.ok .square-outline::after{content:"‚úî";position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:#166534;font-size:20px;font-weight:900;animation:pop-in .18s ease-out}
  .option.err .square-outline{border-color:#ef4444;background:#fee2e2}
  @keyframes pop-in{from{transform:scale(.6);opacity:0}to{transform:scale(1);opacity:1}}
  .option.ok{border-color:#86efac;animation:okPulse .4s ease}
  .option.err{border-color:#fecaca;animation:shake .22s ease}
  @keyframes okPulse{0%{box-shadow:0 0 0 0 rgba(34,197,94,.4)}100%{box-shadow:0 0 0 18px rgba(34,197,94,0)}}
  @keyframes shake{0%{transform:translateX(0)}25%{transform:translateX(-4px)}50%{transform:translateX(4px)}75%{transform:translateX(-3px)}100%{transform:translateX(0)}}

  .footer{margin-top:12px;display:flex;justify-content:space-between;align-items:center;gap:8px;flex-wrap:wrap}
  .pill{background:#eef2ff;color:#3949ab;padding:8px 12px;border-radius:999px;font-size:12px;border:1px solid #d7defc}
  .next-btn{border:none;background:linear-gradient(90deg,#3b82f6,#22c55e);color:#fff;font-weight:800;padding:12px 16px;border-radius:14px;cursor:pointer;box-shadow:0 10px 18px rgba(34,197,94,.25);opacity:.3;pointer-events:none;transition:opacity .2s ease,transform .06s ease}
  .next-btn.ready{opacity:1;pointer-events:auto}
  .next-btn:active{transform:translateY(1px)}

  .confetti{position:absolute;inset:0;pointer-events:none;overflow:hidden}
  .piece{position:absolute;width:10px;height:10px;background:hsl(var(--h) 80% 60%);top:-12px;border-radius:2px;animation:drop linear forwards}
  @keyframes drop{to{transform:translateY(120vh) rotate(540deg)}}

  .toast{position:fixed;left:50%;bottom:24px;transform:translateX(-50%);background:#111827;color:#fff;padding:10px 14px;border-radius:12px;font-size:14px;box-shadow:var(--shadow);opacity:.96}
  .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}

  .build-wrap{margin-top:8px;position:sticky;top:0;z-index:3;background:#f9fbff;padding-bottom:8px;box-shadow:0 6px 10px -8px rgba(0,0,0,.15)}
  .build-tray{min-height:56px;background:#eef4ff;border:2px dashed #cfe0ff;border-radius:14px;padding:10px;display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  .word-chip{background:#fff;border:2px solid #dbe5ff;border-radius:12px;padding:8px 12px;font-weight:800;box-shadow:0 2px 6px rgba(0,0,0,.05);user-select:none}
  .build-actions{display:flex;gap:8px;margin-top:8px}
  .build-btn{border:none;background:#e6f0ff;color:#0f3ea8;padding:8px 12px;border-radius:10px;cursor:pointer;font-weight:700}
  .build-btn:active{transform:translateY(1px)}
  .match-grid{display:grid;grid-template-columns:1fr 1fr;gap:14px;margin-top:8px}
  .match-col{display:flex;flex-direction:column;gap:12px}
  .option.selected{outline:3px solid #60a5fa}
  .option.matched{border-color:#86efac;opacity:.65;pointer-events:none}
  .build-grid{display:grid;gap:12px;grid-template-columns:repeat(2,minmax(0,1fr))}
  .option.word-only{gap:0;justify-content:center}
  .option.word-only .label{width:100%;text-align:center;font-size:22px;font-weight:800}

  .blank{ display:inline-block; vertical-align:baseline; width:clamp(2ch, 6ch, 11ch); height:1.05em; border-bottom:3px solid #cfe0ff; margin:0 .3em; }

  .loading{position:fixed;inset:0;background:rgba(255,255,255,.75);display:flex;align-items:center;justify-content:center;z-index:9999;backdrop-filter:blur(2px);font-weight:700;color:#334155}
  .spinner{width:42px;height:42px;border-radius:50%;border:4px solid #c7d2fe;border-top-color:#3b82f6;animation:spin 1s linear infinite;margin-right:10px}
  @keyframes spin{to{transform:rotate(360deg)}}

  @media (max-width:720px){
    .options{grid-template-columns:1fr}
    .q-prompt{font-size:20px}
    .badge{grid-column:1/-1;max-width:100%}
  }
  @media (min-width: 1024px){
    .question-card{ padding:12px; }
    .q-top{ display:grid; grid-template-columns: minmax(300px, 40%) 1fr; align-items:start; gap:16px; }
    .q-media{ aspect-ratio:auto; height: clamp(160px, 24vh, 260px); max-width:100%; }
    .options{ grid-template-columns: repeat(3, minmax(0, 1fr)); gap:12px; margin-top:10px; }
    .option{ min-height:68px; padding:10px 12px; }
    .option .thumb{ width:54px; height:54px; flex-basis:54px; }
    .option .label{ font-size:18px; }
    .q-prompt{ font-size:20px; }
  }
  @media (min-width: 900px) and (max-height: 820px){
    .q-top{ grid-template-columns: minmax(280px, 38%) 1fr; gap:12px; }
    .q-media{ height: clamp(150px, 22vh, 240px); }
    .options{ gap:10px; }
    .option{ min-height:64px; }
    .option .thumb{ width:50px; height:50px; flex-basis:50px; }
    .option .label{ font-size:17px; }
  }

  #grade-display{
    display:none; text-align:center; font-size:1.1rem; font-weight:700; margin: 0 auto 8px auto;
    max-width:1140px;
  }
  #restartWrap{ display:block; margin: 8px auto 24px auto; text-align:center; }
  #restartButton{
    display:inline-block; padding: 12px 18px; background:#ef4444; color:#fff; border:none; border-radius:12px; font-weight:800; cursor:pointer;
    box-shadow:0 8px 16px rgba(0,0,0,.25);
  }
  #restartButton:disabled{ opacity:.5; cursor:not-allowed }
  #restartNote{ margin-top:8px; font-size:.95rem; color:#374151; }

  #overlay{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;z-index:2000}
  #completion-modal{
    position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);
    background:#fff;border-radius:14px;box-shadow:0 20px 50px rgba(0,0,0,.25);
    padding:24px;display:none;z-index:2001;max-width:520px;width:92%; text-align:center;
  }
  #completion-modal h2{margin:0 0 8px 0;color:#16a34a}
  #completion-modal p{margin:0 0 12px 0}
  #completion-modal button{border:none;background:#2563eb;color:#fff;border-radius:10px;padding:10px 14px;font-weight:800;cursor:pointer}
</style>
</head>
<body>
  <div class="app" id="app">
    <button id="back-button" onclick="goBack()">Back</button>

    <div class="confetti" id="confetti"></div>

    <div class="header">
      <div class="avatar" id="avatar" aria-hidden="true">ü§ñ</div>
      <div class="title-wrap">
        <div class="title">Hannah Questions</div>
        <div class="subtitle" id="subtitle">Loading content‚Ä¶</div>
        <div class="progress"><div id="bar"></div></div>
      </div>
      <div class="badge" id="pill">Unit ‚Äî</div>
    </div>

    <div class="stage">
      <div class="question-card">
        <div class="q-top">
          <div>
            <div class="prompt-row">
              <button class="prompt-audio-icon" id="promptAudioIcon" title="Listen to prompt" aria-label="Listen to prompt">üîä</button>
              <div class="q-prompt" id="prompt">‚Äî</div>
            </div>

            <div class="q-controls">
              <button class="icon-btn is-hidden" id="btnListenCorrect" title="Listen to the correct answer">üîä Listen</button>
            </div>
          </div>

          <div class="q-media" id="mediaBox" aria-label="Question image"></div>
        </div>

        <div class="options" id="options"></div>

        <div class="footer">
          <span class="pill" id="statusPill">Question ‚Äî/‚Äî</span>
          <button class="next-btn" id="btnNext" disabled>Next</button>
        </div>
      </div>
    </div>
  </div>

  <div id="grade-display"></div>
  <div id="restartWrap">
    <button id="restartButton">Restart Test</button>
    <div id="restartNote"></div>
  </div>

  <div id="overlay"></div>
  <div id="completion-modal">
    <h2>Test Completed!</h2>
    <p></p>
    <button onclick="closeModal()">Close</button>
  </div>

  <div class="loading" id="loading" aria-live="polite" style="display:none">
    <div class="spinner" aria-hidden="true"></div>
    <span>Loading‚Ä¶</span>
  </div>

  <div class="sr-only" aria-live="polite" id="live"></div>

  <!-- Firebase SDK v8 -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

  <!-- SINGLE APP SCRIPT -->
  <script>
/* =========================
   Firebase init (v8)
========================= */
const firebaseConfig = {
  apiKey: "AIzaSyDGgo2H_hDKXF88xN7XnLFNUj8ikMY7Xdc",
  authDomain: "hannahenglishcourse.firebaseapp.com",
  databaseURL: "https://hannahenglishcourse-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "hannahenglishcourse",
  storageBucket: "hannahenglishcourse.appspot.com",
  messagingSenderId: "449818788486",
  appId: "1:449818788486:web:8a49d3f68591e6fb3f0707"
};
firebase.initializeApp(firebaseConfig);

// Keep user uid
let currentUserId = null;
firebase.auth().onAuthStateChanged(function(user){
  currentUserId = user ? user.uid : null;
});

(function(){
  /* =========================
     TEST MODE CONFIG
  ========================= */
  const TEST_MODE = true;
  const PASSING_GRADE = 70;
  const TEST_DB_KEY = "test"; // N√ÉO alterar a chave
  const TEST_DISPLAY_NAME = "Grammar Test";

  const MAX_TOTAL_TEST = 40;
  const MIN_TOTAL_TEST = 10; // informational; do not fill artificially

  let userAnswers = [];
  let correctAnswers = [];
  let lockedQuestion = [];
  let wrongTapCount = [];
  let canOverwrite = true;
  let isLinked = false;

  function getParams(){
    const url = new URL(location.href);
    const level = url.searchParams.get('level');
    const unit  = url.searchParams.get('unit');
    const fase  = url.searchParams.get('fase');
    return { level, unit, fase };
  }
  function normalizeDir(prefix, value, fallbackNum){
    if (!value) return prefix + fallbackNum;
    const lower = value.toLowerCase();
    if (lower.startsWith(prefix.toLowerCase())) return value.trim();
    const onlyNum = (value.match(/\d+/)||[''])[0];
    return prefix + (onlyNum || fallbackNum);
  }
  function showLoader(v){ if (loadingEl) loadingEl.style.display = v ? 'flex' : 'none'; }
  function normalize(v){
    return String(v ?? '')
      .trim()
      .toLowerCase()
      .replace(/\s+/g,' ')
      .replace(/[‚Äú‚Äù"]/g,'"');
  }
  function arraysEqual(a,b){
    if(!Array.isArray(a) || !Array.isArray(b) || a.length!==b.length) return false;
    for(let i=0;i<a.length;i++){ if(normalize(a[i])!==normalize(b[i])) return false; }
    return true;
  }
  function shuffle(arr){
    const a = Array.isArray(arr) ? arr : [];
    for(let i=a.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      const tmp = a[i]; a[i]=a[j]; a[j]=tmp;
    }
    return a;
  }

  /* WebAudio SFX */
  let audioCtx = null;
  function ensureAudio(){
    if(!audioCtx){
      try{ audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }catch(e){}
    }
    return !!audioCtx;
  }
  function tone(freq, durMs, type){
    if(!ensureAudio()) return;
    const o = audioCtx.createOscillator(), g = audioCtx.createGain();
    o.type = type || 'sine'; o.frequency.value = freq;
    o.connect(g); g.connect(audioCtx.destination);
    const t0 = audioCtx.currentTime;
    g.gain.setValueAtTime(0.001, t0);
    g.gain.exponentialRampToValueAtTime(0.16, t0+0.01);
    g.gain.exponentialRampToValueAtTime(0.001, t0 + (durMs/1000));
    o.start(t0); o.stop(t0 + (durMs/1000));
  }
  function sfxTick(){ tone(520, 70, 'square'); if(navigator.vibrate) navigator.vibrate(12); }
  function sfxCorrect(){ tone(880,120,'triangle'); setTimeout(()=>tone(1320,90,'triangle'),110); if(navigator.vibrate) navigator.vibrate(25); }
  function sfxWrong(){ tone(240,140,'sawtooth'); if(navigator.vibrate) navigator.vibrate(15); }
  function sfxWin(){ tone(660,120,'triangle'); setTimeout(()=>tone(990,120,'triangle'),120); setTimeout(()=>tone(1320,150,'triangle'),240); if(navigator.vibrate) navigator.vibrate([30,30,50]); }

  function toast(msg){
    const t=document.createElement('div');
    t.className='toast';
    t.textContent=msg;
    document.body.appendChild(t);
    setTimeout(()=>t.remove(),2500);
  }

  /* =========================
     Progress√£o de fase
  ========================= */
  function ensureUserIsAuthenticated(callback){
    if(currentUserId){ callback(currentUserId); return; }
    firebase.auth().onAuthStateChanged(function(user){
      if(user){ currentUserId = user.uid; callback(user.uid); }
      else { console.error("[Auth] User not authenticated"); }
    });
  }
  async function updateNextPhase(userId){
    const { level, unit, fase } = getParams();
    if(!level || !unit || !fase){ console.warn("[Progress] Missing URL params."); return; }
    const dbRef = firebase.database().ref(`usuarios/${userId}/progresso/${level}/${unit}`);
    try{
      if(fase === "last"){
        const nextUnit = `Unit${parseInt((unit||'').replace(/\D/g,''),10) + 1}`;
        await firebase.database().ref(`usuarios/${userId}/progresso/${level}/${nextUnit}`).update({ fase1: true });
      } else if(fase === "end"){
        const nextLevel = `Level${parseInt((level||'').replace(/\D/g,''),10) + 1}`;
        await firebase.database().ref(`usuarios/${userId}/progresso/${nextLevel}/Unit1`).update({ fase1: true });
      } else {
        const nextPhase = parseInt(fase,10) + 1;
        await dbRef.update({ [`fase${nextPhase}`]: true });
      }
      console.log("[Progress] Update successful.");
    } catch(err){
      console.error("[Progress] Error updating next phase:", err);
    }
  }

  /* =========================
     Avatar + paths
  ========================= */
  (function(){
    const avatarEl = document.getElementById('avatar');
    const img = new Image();
    img.src = '../../imagens/robo1_static.png';
    img.alt = 'App mascot';
    img.onload = () => { avatarEl.textContent = ''; avatarEl.appendChild(img); };
    img.onerror = () => { avatarEl.textContent = 'ü§ñ'; };
  })();

  const { level, unit, fase } = getParams();
  const levelDir = normalizeDir('Level', level || '0', '0');
  const unitDir  = normalizeDir('Unit',  unit  || '1', '1');

  const BASE_TEST_SFX = `../../${levelDir}/${unitDir}/DataTest`;

  const pill = document.getElementById('pill');
  pill.textContent = `${levelDir} ‚Ä¢ ${unitDir}${fase ? ' ‚Ä¢ Phase '+fase : ''}`;

  /* =========================
     Activity state/els
  ========================= */
  let questions = [];
  let isReading = false;
  let currentAudio = null;
  let idx = 0;
  let answered = false;

  const subtitle   = document.getElementById('subtitle');
  const bar        = document.getElementById('bar');
  const promptEl   = document.getElementById('prompt');
  const mediaBox   = document.getElementById('mediaBox');
  const optionsEl  = document.getElementById('options');
  const btnNext    = document.getElementById('btnNext');
  const statusPill = document.getElementById('statusPill');
  const confettiEl = document.getElementById('confetti');
  const liveEl     = document.getElementById('live');
  const loadingEl  = document.getElementById('loading');

  const promptAudioIcon = document.getElementById('promptAudioIcon');
  const btnListenCorrect = document.getElementById('btnListenCorrect');

  const gradeEl    = document.getElementById('grade-display');
  const restartBtn = document.getElementById('restartButton');
  const restartNote= document.getElementById('restartNote');
  const overlayEl  = document.getElementById('overlay');
  const modalEl    = document.getElementById('completion-modal');

  const sCorrect = new Audio(`${BASE_TEST_SFX}/sounds/correct.mp3`);
  const sWrong   = new Audio(`${BASE_TEST_SFX}/sounds/wrong.mp3`);
  const sTap     = new Audio(`${BASE_TEST_SFX}/sounds/tap.mp3`);
  const sNext    = new Audio(`${BASE_TEST_SFX}/sounds/next.mp3`);
  [sCorrect,sWrong,sTap,sNext].forEach(a=>{a.preload='auto'});

  restartBtn.onclick = () => resetTest();

  /* ============================================================
     FIREBASE FETCH (UPDATED TO NEW OFFICIAL RULES)
  ============================================================ */

  function normalizeDifficulty(d){
    const raw = String(d || '').trim().toLowerCase();
    if (raw === 'easy' || raw === 'e') return 'easy';
    if (raw === 'medium' || raw === 'med' || raw === 'm') return 'medium';
    if (raw === 'hard' || raw === 'difficult' || raw === 'h') return 'hard';
    return 'easy';
  }

  function absPathQ(p){
    const s = String(p ?? '').trim();
    if (!s) return s;
    if (/^https?:\/\//i.test(s)) return s;
    if (s.startsWith('/')) return s;
    if (s.startsWith('../')) return s;
    return s;
  }

  /* ‚úÖ FIX: extract ONLY phase number (avoids mixing Level/Unit digits) */
  function extractPhaseNumber(key){
    const s = String(key || '');
    const m = s.match(/_Fase(\d+)\b/i);
    if (m) return parseInt(m[1], 10) || 0;
    // fallback: last number in string
    const all = s.match(/(\d+)/g);
    if (!all || !all.length) return 0;
    return parseInt(all[all.length - 1], 10) || 0;
  }

  async function getQuestionIdsByPhaseForUnit(levelKey, unitKey){
    const prefix = `${levelKey}_${unitKey}_Fase`;
    const snap = await firebase.database()
      .ref("activities")
      .orderByKey()
      .startAt(prefix)
      .endAt(prefix + "\uf8ff")
      .once("value");

    const obj = snap.val() || {};
    const phaseKeys = Object.keys(obj).sort(function(a,b){
      return extractPhaseNumber(a) - extractPhaseNumber(b);
    });

    const phaseToIds = {};
    phaseKeys.forEach(function(k){
      const a = obj[k];
      const ids = (a && Array.isArray(a.questionIds)) ? a.questionIds.filter(Boolean) : [];
      phaseToIds[k] = ids.slice();
    });

    return { phaseKeys, phaseToIds };
  }

  function pickDistinctRandomFromArray(arr, n, excludeSet){
    const out = [];
    const pool = shuffle((arr || []).slice());
    for (let i=0; i<pool.length && out.length<n; i++){
      const id = pool[i];
      if (!id) continue;
      if (excludeSet && excludeSet.has(id)) continue;
      out.push(id);
      if (excludeSet) excludeSet.add(id);
    }
    return out;
  }

  function buildInitialSelectionByPhase(phaseKeys, phaseToIds){
    const selected = [];
    const selectedSet = new Set();
    const modePhasesOver40 = phaseKeys.length > 40;

    if (modePhasesOver40){
      const chosenPhases = shuffle(phaseKeys.slice()).slice(0, 40);
      chosenPhases.forEach(function(phaseKey){
        const ids = phaseToIds[phaseKey] || [];
        const picked = pickDistinctRandomFromArray(ids, 1, selectedSet);
        if (picked.length) selected.push(picked[0]);
      });
      return { selectedIds: selected.slice(0, MAX_TOTAL_TEST), phaseLimit: 1, modePhasesOver40: true, chosenPhases };
    }

    phaseKeys.forEach(function(phaseKey){
      const ids = phaseToIds[phaseKey] || [];
      const picked = pickDistinctRandomFromArray(ids, 2, selectedSet);
      for (let i=0;i<picked.length;i++) selected.push(picked[i]);
    });

    if (selected.length > MAX_TOTAL_TEST){
      const chosenPhases = shuffle(phaseKeys.slice()).slice(0, 40);
      const reset = [];
      const resetSet = new Set();
      chosenPhases.forEach(function(phaseKey){
        const ids = phaseToIds[phaseKey] || [];
        const picked = pickDistinctRandomFromArray(ids, 1, resetSet);
        if (picked.length) reset.push(picked[0]);
      });
      return { selectedIds: reset.slice(0, MAX_TOTAL_TEST), phaseLimit: 1, modePhasesOver40: true, chosenPhases };
    }

    return { selectedIds: selected, phaseLimit: 2, modePhasesOver40: false, chosenPhases: phaseKeys.slice() };
  }

  function computeDifficultyTargets(total){
    const easy = Math.ceil(total * 0.50);
    const hard = Math.floor(total * 0.10);
    const medium = Math.max(0, total - easy - hard);
    return { easy, medium, hard };
  }

  function countDifficulties(selectedIds, questionById){
    const c = { easy:0, medium:0, hard:0 };
    for (let i=0;i<selectedIds.length;i++){
      const id = selectedIds[i];
      const q = questionById[id];
      const d = normalizeDifficulty(q && q.difficulty);
      if (d === 'hard') c.hard++;
      else if (d === 'medium') c.medium++;
      else c.easy++;
    }
    return c;
  }

  function buildSelectedByPhase(selectedIds, phaseOfId){
    const map = {};
    for (let i=0;i<selectedIds.length;i++){
      const id = selectedIds[i];
      const phase = phaseOfId[id] || '_unknown';
      if (!map[phase]) map[phase] = [];
      map[phase].push(id);
    }
    return map;
  }

  function buildAvailableByPhaseDifficulty(allIdsByPhase, questionById){
    const map = {};
    const phases = Object.keys(allIdsByPhase);
    for (let i=0;i<phases.length;i++){
      const phase = phases[i];
      const ids = allIdsByPhase[phase] || [];
      if (!map[phase]) map[phase] = { easy:[], medium:[], hard:[] };
      for (let j=0;j<ids.length;j++){
        const id = ids[j];
        const q = questionById[id];
        const d = normalizeDifficulty(q && q.difficulty);
        if (d === 'hard') map[phase].hard.push(id);
        else if (d === 'medium') map[phase].medium.push(id);
        else map[phase].easy.push(id);
      }
      shuffle(map[phase].easy);
      shuffle(map[phase].medium);
      shuffle(map[phase].hard);
    }
    return map;
  }

  function pickCandidateInSamePhase(phase, needDiff, availableByPhaseDiff, selectedSet){
    const bucket = (availableByPhaseDiff[phase] && availableByPhaseDiff[phase][needDiff]) ? availableByPhaseDiff[phase][needDiff] : [];
    for (let i=0;i<bucket.length;i++){
      const id = bucket[i];
      if (!selectedSet.has(id)) return id;
    }
    return null;
  }

  function findRemovableInPhase(phaseSelectedIds, questionById, priorityDiffs){
    for (let p=0;p<priorityDiffs.length;p++){
      const want = priorityDiffs[p];
      for (let i=0;i<phaseSelectedIds.length;i++){
        const id = phaseSelectedIds[i];
        const q = questionById[id];
        const d = normalizeDifficulty(q && q.difficulty);
        if (d === want) return id;
      }
    }
    return null;
  }

  function adjustDifficultyBySwaps(selectedIds, phaseOfId, questionById, availableByPhaseDiff, phaseLimit){
    const selectedSet = new Set(selectedIds);
    const selectedByPhase = buildSelectedByPhase(selectedIds, phaseOfId);
    const phasesInTest = Object.keys(selectedByPhase);

    const total = selectedIds.length;
    const target = computeDifficultyTargets(total);
    let counts = countDifficulties(selectedIds, questionById);

    function deficitOf(diff){ return Math.max(0, (target[diff]||0) - (counts[diff]||0)); }

    function trySwapForNeed(needDiff){
      const phaseOrder = shuffle(phasesInTest.slice());

      for (let k=0;k<phaseOrder.length;k++){
        const phase = phaseOrder[k];
        const phaseSelected = selectedByPhase[phase] || [];
        if (!phaseSelected.length) continue;

        const candidate = pickCandidateInSamePhase(phase, needDiff, availableByPhaseDiff, selectedSet);
        if (!candidate) continue;

        let removePriority = null;
        if (needDiff === 'hard') removePriority = ['medium','easy'];
        else if (needDiff === 'medium') removePriority = ['easy'];
        else if (needDiff === 'easy') removePriority = ['medium','hard'];
        else continue;

        const removable = findRemovableInPhase(phaseSelected, questionById, removePriority);
        if (!removable) continue;

        if (phaseSelected.length > phaseLimit) continue;

        const idxRemove = selectedIds.indexOf(removable);
        if (idxRemove === -1) continue;

        selectedIds[idxRemove] = candidate;

        selectedSet.delete(removable);
        selectedSet.add(candidate);

        const pArr = selectedByPhase[phase];
        for (let i=0;i<pArr.length;i++){
          if (pArr[i] === removable){ pArr[i] = candidate; break; }
        }

        const dRemove = normalizeDifficulty(questionById[removable] && questionById[removable].difficulty);
        const dAdd = normalizeDifficulty(questionById[candidate] && questionById[candidate].difficulty);
        if (dRemove === 'hard') counts.hard--; else if (dRemove === 'medium') counts.medium--; else counts.easy--;
        if (dAdd === 'hard') counts.hard++; else if (dAdd === 'medium') counts.medium++; else counts.easy++;

        return true;
      }
      return false;
    }

    const maxIterations = Math.max(20, selectedIds.length * 4);
    let iterations = 0;

    while (iterations < maxIterations){
      iterations++;

      const hardDef = deficitOf('hard');
      const medDef  = deficitOf('medium');
      const easyDef = deficitOf('easy');

      if (hardDef<=0 && medDef<=0 && easyDef<=0) break;

      let progressed = false;

      if (hardDef > 0){
        progressed = trySwapForNeed('hard');
        if (progressed) continue;
      }
      if (medDef > 0){
        progressed = trySwapForNeed('medium');
        if (progressed) continue;
      }
      if (easyDef > 0){
        progressed = trySwapForNeed('easy');
        if (progressed) continue;
      }

      break;
    }

    return selectedIds;
  }

  async function buildTestForUnitFromFirebase(){
    const fetched = await getQuestionIdsByPhaseForUnit(levelDir, unitDir);
    const phaseKeys = fetched.phaseKeys || [];
    const phaseToIds = fetched.phaseToIds || {};

    if (!phaseKeys.length) return [];

    const phaseOfId = {};
    const allUniqueIdsSet = new Set();
    for (let p=0;p<phaseKeys.length;p++){
      const phaseKey = phaseKeys[p];
      const ids = phaseToIds[phaseKey] || [];
      for (let i=0;i<ids.length;i++){
        const id = ids[i];
        if (!id) continue;
        if (!phaseOfId[id]) phaseOfId[id] = phaseKey;
        allUniqueIdsSet.add(id);
      }
    }
    const allUniqueIds = Array.from(allUniqueIdsSet);
    if (!allUniqueIds.length) return [];

    const snaps = await Promise.all(
      allUniqueIds.map(function(id){
        return firebase.database().ref(`questions/${id}`).once('value');
      })
    );

    const questionById = {};
    for (let i=0;i<snaps.length;i++){
      const s = snaps[i];
      const v = s.val();
      if (!v) continue;
      const id = allUniqueIds[i];
      questionById[id] = v;
    }

    const cleanPhaseToIds = {};
    for (let p=0;p<phaseKeys.length;p++){
      const phaseKey = phaseKeys[p];
      const ids = phaseToIds[phaseKey] || [];
      const out = [];
      for (let i=0;i<ids.length;i++){
        const id = ids[i];
        if (id && questionById[id]) out.push(id);
      }
      cleanPhaseToIds[phaseKey] = out;
    }

    const initial = buildInitialSelectionByPhase(phaseKeys, cleanPhaseToIds);
    let selectedIds = initial.selectedIds || [];
    const phaseLimit = initial.phaseLimit || 2;

    if (selectedIds.length > MAX_TOTAL_TEST) selectedIds = selectedIds.slice(0, MAX_TOTAL_TEST);
    if (!selectedIds.length) return [];

    const availableByPhaseDiff = buildAvailableByPhaseDifficulty(cleanPhaseToIds, questionById);
    selectedIds = adjustDifficultyBySwaps(selectedIds.slice(), phaseOfId, questionById, availableByPhaseDiff, phaseLimit);

    const finalSet = new Set();
    const finalIds = [];
    for (let i=0;i<selectedIds.length;i++){
      const id = selectedIds[i];
      if (!id) continue;
      if (finalSet.has(id)) continue;
      if (!questionById[id]) continue;
      finalSet.add(id);
      finalIds.push(id);
      if (finalIds.length >= MAX_TOTAL_TEST) break;
    }

    const list = [];
    for (let i=0;i<finalIds.length;i++){
      const id = finalIds[i];
      const v = questionById[id];
      if (!v) continue;

      const q = Object.assign({}, v);
      q.id = q.id || id;
      q.level = q.level || levelDir;
      q.unit  = q.unit  || unitDir;
      q.fase  = q.fase || phaseOfId[id] || null;

      if (!q.type) q.type = "mcq";
      if (!Array.isArray(q.options)) q.options = [];

      q.difficulty = normalizeDifficulty(q.difficulty);

      list.push(q);
    }

    shuffle(list);
    return list;
  }

  async function initTest(){
    showLoader(true);
    try{
      await new Promise((resolve)=>ensureUserIsAuthenticated(()=>resolve()));
      if(!currentUserId){
        subtitle.textContent = "User not authenticated.";
        promptEl.textContent = "Please login again.";
        mediaBox.innerHTML = '';
        optionsEl.innerHTML = '';
        return;
      }

      subtitle.textContent = `${TEST_DISPLAY_NAME} ‚Äî answer carefully.`;

      const list = await buildTestForUnitFromFirebase();
      if(!list.length){
        subtitle.textContent = "No questions found.";
        promptEl.textContent = "This unit has no questions available yet.";
        mediaBox.innerHTML = '<div style="padding:10px;text-align:center;color:#334155">Please check if activities + questions exist in Firebase for this unit.</div>';
        optionsEl.innerHTML = '';
        return;
      }

      questions = list;

      initTestArrays(questions.length);
      buildCorrectAnswers();
      idx = 0;
      renderQuestion();

      loadExistingGrade();

    }catch(err){
      console.error("[TEST] Init failed:", err);
      toast("Error loading questions from Firebase.");
      subtitle.textContent = "Failed to load content";
      promptEl.textContent = "Could not load test content from Firebase. Please try again.";
      mediaBox.innerHTML = '';
      optionsEl.innerHTML = '';
    }finally{
      showLoader(false);
    }
  }

  function initTestArrays(n){
    userAnswers   = Array(n).fill(null);
    correctAnswers= Array(n).fill(null);
    lockedQuestion= Array(n).fill(false);
    wrongTapCount = Array(n).fill(0);
  }

  function buildCorrectAnswers(){
    correctAnswers = questions.map(q=>{
      if(q.type==='order'){
        const seq = Array.isArray(q.answer) ? q.answer.slice() :
                    (q.answer && typeof q.answer==='object'
                      ? Object.keys(q.answer).sort((a,b)=>(parseInt(a.replace(/\D/g,''))||0)-(parseInt(b.replace(/\D/g,''))||0)).map(k=>q.answer[k])
                      : [q.answer]);
        return {type:'order', value: seq.map(String) };
      } else if(q.type==='match'){
        const pairs = Array.isArray(q.pairs) ? q.pairs : [];
        const canon = pairs.map(p=>{
          const L = (typeof p.left  === 'string')?p.left :(p.left.value || p.left.label || '');
          const R = (typeof p.right === 'string')?p.right:(p.right.value|| p.right.label|| '');
          return String(R||L);
        });
        return {type:'match', value: canon.sort().map(String) };
      } else {
        if (Array.isArray(q.answer)) {
          return { type:'choice', value: q.answer.map(String) };
        } else if (q.answer && typeof q.answer === 'object') {
          const keys = Object.keys(q.answer).sort((a,b)=>{
            const na = parseInt(String(a).replace(/\D/g,'')) || 0;
            const nb = parseInt(String(b).replace(/\D/g,'')) || 0;
            return na-nb;
          });
          return { type:'choice', value: keys.map(k => String(q.answer[k])) };
        } else {
          return { type:'choice', value: String(q.answer ?? '') };
        }
      }
    });
  }

  function renderPromptWithBlanks(str){
    const s = String(str ?? '');
    return s
      .replace(/\{blank\}/g, '<span class="blank" aria-hidden="true"></span>')
      .replace(/\{b\d+\}/gi, '<span class="blank" aria-hidden="true"></span>')
      .replace(/_{3,}/g,     '<span class="blank" aria-hidden="true"></span>');
  }

  function countBlanksInPrompt(prompt){
    const s = String(prompt ?? '');

    const bTags = (s.match(/\{b\d+\}/gi) || []);
    if (bTags.length){
      const nums = bTags.map(t => {
        const m = t.match(/\d+/);
        return m ? (parseInt(m[0],10) || 0) : 0;
      });
      return Math.max(1, ...nums);
    }

    const blanks = (s.match(/\{blank\}/g) || []).length;
    const underscores = (s.match(/_{3,}/g) || []).length;
    return Math.max(1, blanks + underscores);
  }

  function expectedChoiceArray(correct){
    if (!correct) return [];
    if (Array.isArray(correct.value)) return correct.value.map(String);
    return [String(correct.value ?? '')];
  }

  function ttsSanitize(str){
    return String(str ?? '')
      .replace(/\{blank\}/g, '')
      .replace(/\{b\d+\}/gi, '')
      .replace(/_{3,}/g, '');
  }
  function stripQuotesForTTS(str){
    return String(str ?? '').replace(/[‚Äú‚Äù"]/g,'').replace(/\s{2,}/g,' ').trim();
  }
  function buildSpokenPrompt(q){
    if (q.tts && String(q.tts).trim()) return stripQuotesForTTS(q.tts);

    let text = String(q.prompt || '');
    if (q.type !== 'fillblank'){ return stripQuotesForTTS(ttsSanitize(text)); }

    const optMap = new Map();
    (Array.isArray(q.options) ? q.options : []).forEach(op=>{
      const o = (typeof op === 'string') ? {label:op, value:op} : Object.assign({}, op);
      optMap.set(normalize(o.value), o);
    });
    const speakValue = (val)=>{
      const key = normalize(val);
      const o = optMap.get(key);
      return stripQuotesForTTS((o && (o.tts || o.label || o.value)) || String(val||''));
    };

    text = text.replace(/\{b(\d+)\}/gi, (_m, nStr)=>{
      const n = parseInt(nStr,10);
      let ans = null;
      if (Array.isArray(q.answer)) ans = q.answer[n-1];
      else if (q.answer && typeof q.answer==='object') ans = q.answer['b'+n] ?? q.answer[n] ?? q.answer[nStr];
      else ans = q.answer;
      return speakValue(ans);
    });

    const seqAnswers = (()=> {
      if (Array.isArray(q.answer)) return q.answer.slice();
      if (q.answer && typeof q.answer==='object'){
        const keys = Object.keys(q.answer).sort((a,b)=>{
          const na = parseInt(String(a).replace(/\D/g,'')) || 0;
          const nb = parseInt(String(b).replace(/\D/g,'')) || 0;
          return na-nb;
        });
        return keys.map(k=>q.answer[k]);
      }
      return [q.answer];
    })();

    let seqIdx = 0;
    text = text.replace(/\{blank\}|_{3,}/g, ()=>{
      const val = seqAnswers[Math.min(seqIdx, seqAnswers.length-1)];
      seqIdx++;
      return speakValue(val);
    });

    return stripQuotesForTTS(text);
  }

  function stopAllAudio(){
    try { speechSynthesis.cancel(); } catch(e){}
    if (currentAudio){
      try { currentAudio.pause(); currentAudio.currentTime = 0; } catch(e){}
      currentAudio = null;
    }
  }

  function speak(text){
    const t = String(text || '').trim();
    if(!t) return;
    try{
      const u = new SpeechSynthesisUtterance(t);
      u.lang = 'en-US'; u.rate = 0.95; u.pitch = 1.0;
      speechSynthesis.cancel(); speechSynthesis.speak(u);
    }catch(e){}
  }

  const FIXED_PHRASE_MP3 = {
    "Great!": "./great!.mp3",
    "You may review your result now.": "./you-may-review-your-result-now.mp3",
    "Awesome!": "./awesome!.mp3",
    "We will learn with this one.": "./we-will-learn-with-this-one.mp3",
    "Yes! Great job!": "./yes!-great-job!.mp3",
    "You did it!": "./you-did-it!.mp3",
  };

  const fixedAudioCache = {};
  Object.keys(FIXED_PHRASE_MP3).forEach((phrase) => {
    const src = FIXED_PHRASE_MP3[phrase];
    const a = new Audio(src);
    a.preload = "auto";
    fixedAudioCache[phrase] = a;
  });

  function playFixedPhrase(phrase){
    const key = String(phrase || "").trim();
    const src = FIXED_PHRASE_MP3[key];
    if (!src){
      console.warn("[FixedPhrase] No MP3 mapped for:", key);
      return;
    }

    stopAllAudio();

    let a;
    try{
      a = fixedAudioCache[key] ? fixedAudioCache[key].cloneNode(true) : new Audio(src);
    }catch(e){
      a = new Audio(src);
    }

    currentAudio = a;
    a.onended = () => { currentAudio = null; };
    a.onerror  = () => { currentAudio = null; console.warn("[FixedPhrase] MP3 failed:", src); };

    a.play().catch((err) => {
      console.warn("[FixedPhrase] play() blocked/failed:", err);
    });
  }

  function playFixedFriendly(pool){
    const arr = Array.isArray(pool) ? pool : [];
    if (!arr.length) return;
    const pick = arr[(Math.random() * arr.length) | 0];
    playFixedPhrase(pick);
  }

  function playPrompt(q){
    stopAllAudio();
    const spoken = buildSpokenPrompt(q);

    if (q.promptAudio){
      const a = new Audio(absPathQ(q.promptAudio));
      currentAudio = a;
      a.onended = () => { currentAudio = null; };
      a.onerror  = () => { currentAudio = null; speak(spoken); };
      a.play().catch(() => { currentAudio = null; speak(spoken); });
    } else {
      speak(spoken);
    }
  }

  function getCorrectChoiceValueForIndex(i){
    const corr = correctAnswers[i];
    const expArr = expectedChoiceArray(corr);
    return String(expArr[0] ?? '').trim();
  }

  function findCorrectOptionObject(q, correctVal){
    const opts = Array.isArray(q.options) ? q.options : [];
    const want = normalize(correctVal);
    for (let i=0;i<opts.length;i++){
      const raw = opts[i];
      const o = (typeof raw === 'string') ? { label: raw, value: raw } : Object.assign({}, raw);
      const v = normalize(o.value ?? o.label ?? '');
      const l = normalize(o.label ?? o.value ?? '');
      if (v === want || l === want) return o;
    }
    return null;
  }

  function playCorrectOptionForAudioMCQ(){
    const q = questions[idx];
    if (!q || q.type !== 'audio_mcq') return;

    const correctVal = getCorrectChoiceValueForIndex(idx);
    if (!correctVal){
      toast("Correct answer not found for this question.");
      return;
    }

    const opt = findCorrectOptionObject(q, correctVal);
    const speakText = stripQuotesForTTS(String((opt && (opt.tts || opt.label || opt.value)) || correctVal));

    stopAllAudio();

    if (opt && opt.audio){
      try{
        const a = new Audio(absPathQ(opt.audio));
        currentAudio = a;
        a.onended = () => { currentAudio = null; };
        a.onerror = () => { currentAudio = null; speak(speakText); };
        a.play().catch(() => { currentAudio = null; speak(speakText); });
      }catch(e){
        speak(speakText);
      }
    } else {
      speak(speakText);
    }
  }

  function renderQuestion(){
    answered = false;
    btnNext.disabled = true; btnNext.classList.remove('ready');

    promptAudioIcon.disabled = false;
    btnListenCorrect.classList.add('is-hidden');
    btnListenCorrect.disabled = false;

    const q = questions[idx];
    if(!q){ finish(); return; }

    const pct = Math.round(((idx)/questions.length)*100);
    bar.style.width = pct + '%';
    statusPill.textContent = `Question ${idx+1}/${questions.length}`;

    let rawPrompt = q.prompt || '‚Äî';
    if (q.type === 'audio_mcq' && (!rawPrompt || rawPrompt === '‚Äî')) {
      rawPrompt = 'Listen. Choose.';
    }

    promptEl.innerHTML = renderPromptWithBlanks(rawPrompt);
    if (q.type === 'fillblank' && !/\{blank\}|\{b\d+\}|_{3,}/i.test(rawPrompt)) {
      const span = document.createElement('span');
      span.className = 'blank'; span.setAttribute('aria-hidden','true');
      promptEl.appendChild(document.createTextNode(' '));
      promptEl.appendChild(span);
    }

    promptAudioIcon.onclick = () => { if (!isReading) playPrompt(q); };

    if (q.type === 'audio_mcq'){
      btnListenCorrect.classList.remove('is-hidden');
      btnListenCorrect.onclick = () => {
        if (isReading) return;
        (ensureAudio()? sfxTick() : sTap.play().catch(()=>{}));
        playCorrectOptionForAudioMCQ();
      };
    }

    mediaBox.innerHTML = '';
    if(q.image){
      const img = new Image(); img.alt = 'Question image';
      img.src = absPathQ(q.image); mediaBox.appendChild(img);
    } else {
      const img = new Image(); img.src = './hannah_pensando.png'; img.alt = 'Hannah thinking';
      mediaBox.appendChild(img);
    }

    optionsEl.innerHTML = '';
    optionsEl.classList.remove('is-order');

    if (q.type === 'order') {
      renderOrderQuestion(q);
    } else if (q.type === 'match') {
      renderMatchQuestion(q);
    } else {
      const baseOpts = Array.isArray(q.options) ? q.options.slice() : [];
      const opts = (q.shuffleOptions===false) ? baseOpts : shuffle(baseOpts);
      opts.forEach(opt => optionsEl.appendChild(makeOption(q, opt)));
    }

    btnNext.onclick = () => {
      (ensureAudio()? sfxTick() : sNext.play().catch(()=>{}));
      idx++;
      if (idx >= questions.length) { finish(); return; }
      renderQuestion();
    };

    if (q.type === 'audio_mcq') {
      const auto = (q.autoplayPrompt !== false);
      if (auto) {
        setTimeout(() => {
          if (questions[idx] === q && !answered && !isReading) {
            playPrompt(q);
          }
        }, 250);
      }
    }
  }

  function makeOption(q, opt){
    const o0 = (typeof opt === 'string') ? { label: opt, value: opt } : Object.assign({}, opt);
    const o = Object.assign({}, o0, {
      label: (o0.label != null && String(o0.label).trim() !== '') ? String(o0.label) : String(o0.value ?? ''),
      value: (o0.value != null && String(o0.value).trim() !== '') ? String(o0.value) : String(o0.label ?? '')
    });

    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'option';
    btn.setAttribute('aria-label', o.aria || o.label || 'option');

    const thumb = document.createElement('div');
    thumb.className = 'thumb';
    if (o.image){
      const img = new Image(); img.src = absPathQ(o.image); img.alt = o.label || '';
      thumb.appendChild(img);
    } else if (o.emoji){
      thumb.textContent = o.emoji;
    } else {
      const box = document.createElement('span');
      box.className = 'square-outline';
      box.style.setProperty('--sq', '#7c3aed');
      thumb.appendChild(box);
    }

    const textWrap = document.createElement('div');
    textWrap.style.flex = '1';
    textWrap.style.minWidth = '0';
    const label = document.createElement('div');
    label.className = 'label';
    label.textContent = o.label || o.value;
    textWrap.appendChild(label);
    if (typeof o.sub === 'string' && o.sub.trim()){
      const sub = document.createElement('div'); sub.className = 'sub'; sub.textContent = o.sub;
      textWrap.appendChild(sub);
    }

    btn.appendChild(thumb); btn.appendChild(textWrap);

    const commit = () => {
      if (TEST_MODE && lockedQuestion[idx]) return;

      const blanksTotal = (q.type === 'fillblank') ? countBlanksInPrompt(q.prompt) : 1;
      const chosenVal = String(o.value ?? o.label ?? '');

      if (TEST_MODE){
        if (blanksTotal <= 1){
          userAnswers[idx] = chosenVal;
          lockedQuestion[idx] = true;
        } else {
          if (!Array.isArray(userAnswers[idx])) userAnswers[idx] = [];
          userAnswers[idx].push(chosenVal);

          const done = userAnswers[idx].length;
          if (done >= blanksTotal){
            lockedQuestion[idx] = true;
          } else {
            btn.dataset.chosen = '1';
            btn.disabled = true;
            btn.style.opacity = .65;
          }
        }
      }

      handleAnswer(q, o, btn);
    };

    btn.onclick = () => {
      (ensureAudio()? sfxTick() : sTap.play().catch(()=>{}));
      commit();
    };
    thumb.style.cursor = 'pointer';
    thumb.title = 'Choose';
    thumb.onclick = (e) => {
      e.preventDefault(); e.stopPropagation();
      (ensureAudio()? sfxTick() : sTap.play().catch(()=>{}));
      commit();
    };

    return btn;
  }

  function renderOrderQuestion(q){
    optionsEl.classList.add('is-order');

    const words = (q.options || []).map(w => String(w));
    const answerSeq = Array.isArray(q.answer) ? q.answer.map(String) : [];
    let built = [];

    const wrap = document.createElement('div'); wrap.className = 'build-wrap';
    const tray = document.createElement('div'); tray.className = 'build-tray'; tray.id = 'buildTray';
    tray.setAttribute('aria-label','Sentence tray');
    const actions = document.createElement('div'); actions.className = 'build-actions';
    const undoBtn = document.createElement('button'); undoBtn.className = 'build-btn'; undoBtn.textContent = 'Undo';
    const clearBtn = document.createElement('button'); clearBtn.className = 'build-btn'; clearBtn.textContent = 'Clear';
    actions.appendChild(undoBtn); actions.appendChild(clearBtn);
    wrap.appendChild(tray); wrap.appendChild(actions);
    optionsEl.appendChild(wrap);

    const grid = document.createElement('div'); grid.className = 'build-grid';
    optionsEl.appendChild(grid);

    words.forEach(w=>{
      const b = document.createElement('button');
      b.type='button'; b.className='option word-only';
      b.innerHTML = `<div class="label">${w}</div>`;
      b.onclick = ()=>{
        (ensureAudio()? sfxTick() : sTap.play().catch(()=>{}));
        if (built.length >= answerSeq.length) return;
        built.push(w);
        drawTray();
        checkBuilt();
      };
      grid.appendChild(b);
    });

    undoBtn.onclick = ()=>{ if(TEST_MODE && lockedQuestion[idx]) return; built.pop(); drawTray(); btnNext.disabled = true; btnNext.classList.remove('ready'); };
    clearBtn.onclick = ()=>{ if(TEST_MODE && lockedQuestion[idx]) return; built = []; drawTray(); btnNext.disabled = true; btnNext.classList.remove('ready'); };

    function drawTray(){
      tray.innerHTML = '';
      built.forEach(word=>{
        const chip = document.createElement('span');
        chip.className='word-chip';
        chip.textContent = word;
        tray.appendChild(chip);
      });
    }
    function finalizeAttempt(ok){
      if(TEST_MODE && !lockedQuestion[idx]){
        userAnswers[idx] = built.slice();
        lockedQuestion[idx] = true;
      }
      if(ok){
        try{
          mediaBox.innerHTML = '';
          const gif = new Image(); gif.src = './hannah_feliz.gif'; gif.alt = 'Hannah celebrating';
          gif.setAttribute('draggable','false'); gif.style.pointerEvents = 'none';
          mediaBox.appendChild(gif);
        }catch(e){}
        confetti(18);
        (ensureAudio()? sfxCorrect() : sCorrect.play().catch(()=>{}));
        playFixedFriendly(['Great!','Awesome!']);
        liveEl.textContent = 'Correct order';
      } else {
        (ensureAudio()? sfxWrong() : sWrong.play().catch(()=>{}));
        playFixedPhrase('We will learn with this one.');
        liveEl.textContent = 'Recorded order for grading';
      }
      btnNext.disabled = false; btnNext.classList.add('ready');
      answered = true;
      Array.from(optionsEl.querySelectorAll('.option')).forEach(el=> el.disabled = true);
      undoBtn.disabled = true; clearBtn.disabled = true;
    }
    function checkBuilt(){
      const sameLen = built.length === answerSeq.length;
      if (!sameLen) return;
      const ok = built.every((w,i)=> normalize(w) === normalize(answerSeq[i]));
      finalizeAttempt(ok);
    }
  }

  function renderMatchQuestion(q){
    const pairs = Array.isArray(q.pairs) ? q.pairs : [];
    if(!pairs.length){
      optionsEl.innerHTML = '<div style="padding:10px;color:#334155">No pairs found for this match question.</div>';
      return;
    }

    const leftItems = pairs.map(p => p.left);
    const rightItems = pairs.map(p => p.right);

    const leftShuffled  = shuffle(leftItems.slice());
    const rightShuffled = shuffle(rightItems.slice());

    let selectedLeftIndex = null;
    let selectedRightIndex = null;

    const wrap = document.createElement('div');
    wrap.className = 'match-grid';

    const colL = document.createElement('div');
    colL.className = 'match-col';
    const colR = document.createElement('div');
    colR.className = 'match-col';

    wrap.appendChild(colL);
    wrap.appendChild(colR);
    optionsEl.appendChild(wrap);

    function itemToObj(x){
      if(typeof x === 'string') return { label:x, value:x };
      return Object.assign({}, x || {});
    }

    const leftButtons = [];
    const rightButtons = [];

    function clearSelections(){
      selectedLeftIndex = null;
      selectedRightIndex = null;
      leftButtons.forEach(b=>b.classList.remove('selected'));
      rightButtons.forEach(b=>b.classList.remove('selected'));
    }

    function markMatched(li, ri){
      leftButtons[li].classList.add('matched');
      rightButtons[ri].classList.add('matched');
      leftButtons[li].disabled = true;
      rightButtons[ri].disabled = true;
      clearSelections();
    }

    function allMatched(){
      return leftButtons.every(b => b.classList.contains('matched')) &&
             rightButtons.every(b => b.classList.contains('matched'));
    }

    function commitMatch(){
      if (selectedLeftIndex === null || selectedRightIndex === null) return;

      const L = itemToObj(leftShuffled[selectedLeftIndex]);
      const R = itemToObj(rightShuffled[selectedRightIndex]);

      if(TEST_MODE){
        if(!Array.isArray(userAnswers[idx])) userAnswers[idx] = [];
        const chosen = String(R.value ?? R.label ?? '').trim();
        userAnswers[idx].push(chosen);
      }

      const leftVal  = normalize(String(L.value ?? L.label ?? ''));
      const rightVal = normalize(String(R.value ?? R.label ?? ''));

      const ok = pairs.some(p=>{
        const pL = itemToObj(p.left);
        const pR = itemToObj(p.right);
        const pLv = normalize(String(pL.value ?? pL.label ?? ''));
        const pRv = normalize(String(pR.value ?? pR.label ?? ''));
        return (pLv === leftVal && pRv === rightVal);
      });

      if(ok){
        markMatched(selectedLeftIndex, selectedRightIndex);
        (ensureAudio()? sfxCorrect() : sCorrect.play().catch(()=>{}));
        playFixedFriendly(['Great!','Awesome!']);
        confetti(10);
      }else{
        wrongTapCount[idx] = (wrongTapCount[idx]||0) + 1;
        (ensureAudio()? sfxWrong() : sWrong.play().catch(()=>{}));
        playFixedPhrase('We will learn with this one.');
        toast("Try again!");
        clearSelections();
      }

      if(allMatched()){
        if(TEST_MODE){
          lockedQuestion[idx] = true;
          if(Array.isArray(userAnswers[idx])) userAnswers[idx] = userAnswers[idx].slice().sort();
        }
        btnNext.disabled = false; btnNext.classList.add('ready');
        answered = true;
        liveEl.textContent = 'Match completed';
      }
    }

    function buildButtonFromItem(item, side){
      const o = itemToObj(item);

      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'option';
      btn.setAttribute('aria-label', (o.aria || o.label || o.value || 'item'));

      const thumb = document.createElement('div');
      thumb.className = 'thumb';

      if (o.image){
        const img = new Image();
        img.src = absPathQ(o.image);
        img.alt = o.label || '';
        thumb.appendChild(img);
      } else if (o.emoji){
        thumb.textContent = o.emoji;
      } else {
        const box = document.createElement('span');
        box.className = 'square-outline';
        box.style.setProperty('--sq', side === 'L' ? '#2563eb' : '#7c3aed');
        thumb.appendChild(box);
      }

      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = (o.label != null && String(o.label).trim() !== '') ? String(o.label) : String(o.value ?? '');

      const textWrap = document.createElement('div');
      textWrap.style.flex = '1';
      textWrap.style.minWidth = '0';
      textWrap.appendChild(label);

      btn.appendChild(thumb);
      btn.appendChild(textWrap);

      return btn;
    }

    leftShuffled.forEach((item, i)=>{
      const b = buildButtonFromItem(item,'L');
      b.onclick = ()=>{
        if(TEST_MODE && lockedQuestion[idx]) return;
        if(b.classList.contains('matched')) return;
        (ensureAudio()? sfxTick() : sTap.play().catch(()=>{}));
        leftButtons.forEach(x=>x.classList.remove('selected'));
        b.classList.add('selected');
        selectedLeftIndex = i;
        if(selectedRightIndex !== null) commitMatch();
      };
      colL.appendChild(b);
      leftButtons.push(b);
    });

    rightShuffled.forEach((item, i)=>{
      const b = buildButtonFromItem(item,'R');
      b.onclick = ()=>{
        if(TEST_MODE && lockedQuestion[idx]) return;
        if(b.classList.contains('matched')) return;
        (ensureAudio()? sfxTick() : sTap.play().catch(()=>{}));
        rightButtons.forEach(x=>x.classList.remove('selected'));
        b.classList.add('selected');
        selectedRightIndex = i;
        if(selectedLeftIndex !== null) commitMatch();
      };
      colR.appendChild(b);
      rightButtons.push(b);
    });

    btnNext.disabled = true; btnNext.classList.remove('ready');
  }

  function isCorrectForIndex(i){
    const q = questions[i];
    const corr = correctAnswers[i];
    const ua = userAnswers[i];

    if(!q || !corr) return false;

    if(q.type === 'order'){
      const expected = Array.isArray(corr.value) ? corr.value : [];
      const given = Array.isArray(ua) ? ua : [];
      if(given.length !== expected.length) return false;
      for(let k=0;k<expected.length;k++){
        if(normalize(given[k]) !== normalize(expected[k])) return false;
      }
      return true;
    }

    if(q.type === 'match'){
      const expected = Array.isArray(corr.value) ? corr.value.slice().map(String).sort() : [];
      const given = Array.isArray(ua) ? ua.slice().map(String).sort() : [];
      return arraysEqual(expected, given);
    }

    const expectedArr = expectedChoiceArray(corr).map(String);

    if(Array.isArray(expectedArr) && expectedArr.length > 1){
      const given = Array.isArray(ua) ? ua.map(String) : [String(ua ?? '')];
      if(given.length !== expectedArr.length) return false;
      for(let k=0;k<expectedArr.length;k++){
        if(normalize(given[k]) !== normalize(expectedArr[k])) return false;
      }
      return true;
    }

    return normalize(String(ua ?? '')) === normalize(String(expectedArr[0] ?? ''));
  }

  function computeScore(){
    let correct = 0;
    for(let i=0;i<questions.length;i++){
      if(isCorrectForIndex(i)) correct++;
    }
    const pct = questions.length ? Math.round((correct / questions.length) * 100) : 0;
    return { correct, total: questions.length, pct };
  }

  function finish(){
    bar.style.width = '100%';
    btnNext.disabled = true;
    btnNext.classList.remove('ready');

    const score = computeScore();

    const passed = score.pct >= PASSING_GRADE;
    const msg = `Score: ${score.correct}/${score.total} (${score.pct}%) ‚Äî ${passed ? 'PASSED' : 'TRY AGAIN'}`;

    gradeEl.style.display = 'block';
    gradeEl.textContent = msg;

    overlayEl.style.display = 'block';
    modalEl.style.display = 'block';
    modalEl.querySelector('p').textContent = msg;

    if(passed){
      try{
        ensureUserIsAuthenticated((uid)=>updateNextPhase(uid));
      }catch(e){}
      (ensureAudio()? sfxWin() : sCorrect.play().catch(()=>{}));
      playFixedFriendly(['You did it!','Yes! Great job!']);
      confetti(26);
    }else{
      (ensureAudio()? sfxWrong() : sWrong.play().catch(()=>{}));
      playFixedPhrase('You may review your result now.');
    }

    saveGrade(score.pct, score.correct, score.total, passed).catch(err=>{
      console.warn("[TEST] saveGrade failed:", err);
    });

    updateRestartPolicy(passed);
  }

  function closeModal(){
    overlayEl.style.display = 'none';
    modalEl.style.display = 'none';
  }
  window.closeModal = closeModal;

  function confetti(n){
    const count = n || 18;
    for(let i=0;i<count;i++){
      const p = document.createElement('div');
      p.className = 'piece';
      p.style.left = (Math.random()*100)+'%';
      p.style.setProperty('--h', String((Math.random()*360)|0));
      const dur = 1.5 + Math.random()*1.3;
      p.style.animationDuration = dur+'s';
      p.style.opacity = String(0.75 + Math.random()*0.25);
      confettiEl.appendChild(p);
      setTimeout(()=>p.remove(), (dur*1000)+200);
    }
  }

  async function saveGrade(pct, correct, total, passed){
    if(!currentUserId) return;

    const { level, unit } = getParams();
    const levelKey = normalizeDir('Level', level || '0', '0');
    const unitKey  = normalizeDir('Unit',  unit  || '1', '1');

    const ref = firebase.database().ref(`usuarios/${currentUserId}/tests/${levelKey}/${unitKey}/${TEST_DB_KEY}`);
    const payload = {
      name: TEST_DISPLAY_NAME,
      pct,
      correct,
      total,
      passed: !!passed,
      updatedAt: Date.now()
    };

    if(!canOverwrite){
      console.log("[TEST] canOverwrite=false; not saving grade.");
      return;
    }

    await ref.set(payload);
  }

  async function loadExistingGrade(){
    if(!currentUserId) return;

    const { level, unit } = getParams();
    const levelKey = normalizeDir('Level', level || '0', '0');
    const unitKey  = normalizeDir('Unit',  unit  || '1', '1');

    try{
      const ref = firebase.database().ref(`usuarios/${currentUserId}/tests/${levelKey}/${unitKey}/${TEST_DB_KEY}`);
      const snap = await ref.once('value');
      const v = snap.val();

      if(v && typeof v.pct === 'number'){
        canOverwrite = false;

        gradeEl.style.display = 'block';
        gradeEl.textContent = `Last score: ${v.correct}/${v.total} (${v.pct}%) ‚Äî ${v.passed ? 'PASSED' : 'TRY AGAIN'}`;

        restartNote.textContent = "A score already exists for this test. Restart may be disabled (depends on your policy).";
        updateRestartPolicy(!!v.passed);
      }else{
        canOverwrite = true;
        restartNote.textContent = "";
      }
    }catch(err){
      console.warn("[TEST] loadExistingGrade error:", err);
      canOverwrite = true;
    }
  }

  function updateRestartPolicy(passed){
    if(!canOverwrite){
      restartBtn.disabled = true;
      restartNote.textContent = "Restart disabled because this test already has a saved score.";
      return;
    }
    restartBtn.disabled = false;
    restartNote.textContent = passed
      ? "You passed! You can restart if you want to practice."
      : "You can restart to try again.";
  }

  function resetTest(){
    closeModal();

    idx = 0;
    answered = false;
    initTestArrays(questions.length);
    buildCorrectAnswers();
    bar.style.width = '0%';
    renderQuestion();

    toast("Test restarted.");
  }

  function handleAnswer(q, o, btn){
    if (answered) return;

    const corr = correctAnswers[idx];
    const expected = expectedChoiceArray(corr).map(String);
    const blanksTotal = (q.type === 'fillblank') ? countBlanksInPrompt(q.prompt) : 1;

    if (q.type === 'fillblank' && blanksTotal > 1){
      const ua = userAnswers[idx];
      const done = Array.isArray(ua) ? ua.length : 0;

      if (done < blanksTotal){
        liveEl.textContent = `Selected ${done}/${blanksTotal}`;
        return;
      }
    }

    let ok = false;

    if (q.type === 'fillblank' && blanksTotal > 1){
      const given = Array.isArray(userAnswers[idx]) ? userAnswers[idx].map(String) : [];
      if (given.length === expected.length){
        ok = true;
        for(let k=0;k<expected.length;k++){
          if(normalize(given[k]) !== normalize(expected[k])) { ok = false; break; }
        }
      }
    }else{
      const chosen = String(o.value ?? o.label ?? '');
      ok = normalize(chosen) === normalize(String(expected[0] ?? ''));
      userAnswers[idx] = chosen;
    }

    answered = true;

    const allButtons = Array.from(optionsEl.querySelectorAll('.option'));
    allButtons.forEach(b=> b.disabled = true);

    if(ok){
      btn.classList.add('ok');
      (ensureAudio()? sfxCorrect() : sCorrect.play().catch(()=>{}));
      confetti(14);

      try{
        mediaBox.innerHTML = '';
        const gif = new Image(); gif.src = './hannah_feliz.gif'; gif.alt = 'Hannah celebrating';
        gif.setAttribute('draggable','false'); gif.style.pointerEvents = 'none';
        mediaBox.appendChild(gif);
      }catch(e){}

      playFixedFriendly(['Great!','Awesome!']);
      liveEl.textContent = 'Correct';
    }else{
      btn.classList.add('err');
      (ensureAudio()? sfxWrong() : sWrong.play().catch(()=>{}));
      playFixedPhrase('We will learn with this one.');
      liveEl.textContent = 'Wrong';
    }

    btnNext.disabled = false;
    btnNext.classList.add('ready');
  }

  window.goBack = function(){
    try{ stopAllAudio(); }catch(e){}
    history.back();
  };

  initTest();
})(); // end IIFE
  </script>
</body>
</html>
