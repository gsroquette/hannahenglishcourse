<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Word Drop Express (Responsivo)</title>

  <style>
    /* ==================================================
       1) For√ßar paisagem: esconder jogo em portrait
    ================================================== */
    #game-container {
      display: block;
    }
    #rotate-notice {
      display: none;
      position: fixed;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.85);
      color: white;
      font-size: 1.2em;
      text-align: center;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      flex-direction: column;
    }
    @media only screen and (orientation: portrait) {
      #game-container {
        display: none;
      }
      #rotate-notice {
        display: flex;
      }
    }

    /* ==================================================
       2) Geral / Responsividade
    ================================================== */
    body {
      margin: 0;
      padding: 0;
      font-family: "Times New Roman", Times, serif;
      background: url('../../../imagens/fundo.png') repeat;
      height: 100vh;
      overflow: hidden;
    }
    #game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    /* Trem e vag√µes */
    #train {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 25vh;        /* 25% da altura da tela */
      min-height: 100px;   /* nunca menor que 100px */
      background: #2c3e50;
      display: flex;
      align-items: flex-end;
      justify-content: space-around;
      padding-bottom: 5px;
    }
    .wagon {
      position: relative;
      width: calc(100% / var(--num-wagons));
      height: 80%;
      background: #ecf0f1;
      border: 3px solid #34495e;
      border-radius: 5px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .wagon .word {
      font-size: clamp(9px, 2.5vw, 24px);
      color: #2c3e50;
      text-transform: uppercase;
      text-align: center;
      padding: 2px 4px;
    }
    .wagon.correct {
      animation: glow 0.8s ease-out forwards;
    }
    @keyframes glow {
      0%   { box-shadow: 0 0 5px rgba(46, 204, 113, 0.5); }
      50%  { box-shadow: 0 0 20px rgba(46, 204, 113, 1); }
      100% { box-shadow: 0 0 5px rgba(46, 204, 113, 0.5); }
    }

    /* Bal√µes (tamanho relativo) */
    .balloon {
      position: absolute;
      width: 15vw;       /* 15% da largura da tela */
      max-height: 18vh;  /* no m√°ximo 18% da altura */
      background: url('balloon.png') no-repeat center center;
      background-size: contain;
      cursor: pointer;
      transition: transform 0.2s ease;
    }
    .balloon:hover {
      transform: scale(1.1);
    }
    .balloon img {
      position: absolute;
      top: calc(100% + 1vh); /* 1% da altura da tela abaixo do bal√£o */
      left: 50%;
      transform: translateX(-50%);
      width: 10vw;       /* 10% da largura da tela */
      max-height: 12vh;  /* 12% da altura da tela */
      object-fit: contain;
      pointer-events: none;
    }

    /* Feedback ‚ÄúTry Again!‚Äù */
    #feedback {
      position: absolute;
      top: 45%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(231, 76, 60, 0.9);
      color: white;
      padding: 15px 25px;
      border-radius: 8px;
      font-size: 1.2em;
      display: none;
      z-index: 1000;
    }

    /* Bot√£o Reiniciar */
    #restart-button {
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 10px 20px;
      background-color: #2980b9;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1em;
      z-index: 1000;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      transition: background-color 0.3s ease;
    }
    #restart-button:hover {
      background-color: #1c5980;
    }

    /* Imagem ‚Äúcaindo‚Äù */
    .falling {
      position: absolute;
      width: 10vw;        /* mesma regra de responsividade da imagem do bal√£o */
      max-height: 12vh;
      object-fit: contain;
      pointer-events: none;
      z-index: 500;
    }
  </style>
</head>
<body>
  <!-- 1) Mensagem pedindo para girar o dispositivo -->
  <div id="rotate-notice">
    <div>
      <p>üì± Por favor, vire seu dispositivo para o modo paisagem (landscape) para jogar.</p>
      <p>‚Ü™Ô∏è Vire o celular/tablet e aguarde...</p>
    </div>
  </div>

  <!-- 2) Container principal do jogo -->
  <div id="game-container">
    <button id="restart-button" onclick="restartGame()">Restart</button>
    <div id="feedback">Try Again!</div>
    <div id="train"></div>
  </div>

  <!-- Firebase SDK (inalterado) -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

  <script>
    // ===== CONFIGURA√á√ÉO DO FIREBASE (igual ao seu c√≥digo) =====
    const firebaseConfig = {
      apiKey: "AIzaSyDGgo2H_hDKXF88xN7XnLFNUj8ikMY7Xdc",
      authDomain: "hannahenglishcourse.firebaseapp.com",
      databaseURL: "https://hannahenglishcourse-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "hannahenglishcourse",
      storageBucket: "hannahenglishcourse.appspot.com",
      messagingSenderId: "449818788486",
      appId: "1:449818788486:web:8a49d3f68591e6fb3f0707"
    };
    firebase.initializeApp(firebaseConfig);
    // =================================================================================

    // Refer√™ncias de DOM
    const trainElement    = document.getElementById('train');
    const feedbackElement = document.getElementById('feedback');

    let wordsList    = [];  // array de palavras
    let imagesList   = [];  // array de { src, pair, word }
    let numWagons    = 0;   // n√∫mero de vag√µes
    let correctCount = 0;   // quantos pares j√° foram acertados

    // Array que guarda todos os bal√µes criados (para animar)
    const balloonsArray = [];

    // =================================================
    // 1) L√™ par√¢metros level e unit da URL
    // =================================================
    function getParamsFromURL() {
      const params = new URLSearchParams(window.location.search);
      return {
        level: params.get('level'),
        unit:  params.get('unit'),
        fase:  params.get('fase'),
      };
    }

    // =================================================
    // 2) Carrega palavras e imagens do diret√≥rio
    // =================================================
    function loadCardsData(callback) {
      const { level, unit } = getParamsFromURL();
      if (!level || !unit) {
        console.error("Par√¢metros 'level' e 'unit' s√£o obrigat√≥rios na URL.");
        return;
      }

      const wordsPath         = `../../${level}/${unit}/data1/words.txt`;
      const imagePathTemplate = `../../${level}/${unit}/data1/imagens/imagem`;

      fetch(wordsPath)
        .then(response => {
          if (!response.ok) {
            throw new Error(`Erro ao carregar palavras de ${wordsPath}`);
          }
          return response.text();
        })
        .then(text => {
          const words = text.trim().split('\n');
          wordsList   = words.map(w => w.trim());
          numWagons   = wordsList.length;

          // Monta lista de imagens com par e palavra correspondente
          imagesList = [];
          wordsList.forEach((word, index) => {
            const imgPath = `${imagePathTemplate}${index + 1}.png`;
            imagesList.push({
              src:  imgPath,
              pair: `pair${index + 1}`,
              word: word
            });
          });

          callback(); // Chama a inicializa√ß√£o do jogo
        })
        .catch(error => {
          console.error("Erro ao carregar dados:", error);
        });
    }

    // =================================================
    // 3) Inicializa o Word Drop Express
    // =================================================
    function initWordDropGame() {
      correctCount = 0;
      trainElement.innerHTML = '';
      removeAllBalloons();
      balloonsArray.length = 0; // limpa o array de bal√µes

      // Ajusta custom-property para distribuir vag√µes
      trainElement.style.setProperty('--num-wagons', numWagons);

      // 3.1) Gera vag√µes com as palavras
      wordsList.forEach((word, index) => {
        const wagon = document.createElement('div');
        wagon.classList.add('wagon');
        wagon.dataset.pair = `pair${index + 1}`;

        const wordDiv = document.createElement('div');
        wordDiv.classList.add('word');
        wordDiv.textContent = word;
        wagon.appendChild(wordDiv);

        trainElement.appendChild(wagon);
      });

      // 3.2) Gera bal√µes com imagens
      imagesList.forEach(imgObj => {
        createBalloon(imgObj);
      });

      // Inicia anima√ß√£o de voo (horizontal + vertical)
      requestAnimationFrame(animateBalloons);
    }

    // =================================================
    // Remove todos os bal√µes flutuantes do DOM
    // =================================================
    function removeAllBalloons() {
      const existing = document.querySelectorAll('.balloon');
      existing.forEach(b => b.remove());
    }

    // =================================================
    // 4) CRIA√á√ÉO DO BAL√ÉO (com imagem logo abaixo)
    // =================================================
    function createBalloon(imgObj) {
      // Cria elemento ‚Äúbal√£o‚Äù
      const balloon = document.createElement('div');
      balloon.classList.add('balloon');
      balloon.dataset.pair = imgObj.pair;
      balloon.dataset.word = imgObj.word;

      // Adiciona temporariamente ao DOM s√≥ para medir o tamanho real em px
      document.body.appendChild(balloon);
      const rect = balloon.getBoundingClientRect();
      const balW = rect.width;   // largura real em px
      const balH = rect.height;  // altura real em px

      // Posi√ß√£o inicial: X rand√¥mico entre 0 e (largura da tela - largura do bal√£o)
      const screenW = window.innerWidth;
      const randomX = Math.random() * (screenW - balW);
      const initialTop = window.innerHeight * 0.05; // 5% do topo

      balloon.style.left = randomX + 'px';
      balloon.style.top  = initialTop + 'px';

      // Anexa a imagem ‚Äúpendurada‚Äù logo abaixo
      const imgTag = document.createElement('img');
      imgTag.src = imgObj.src;
      balloon.appendChild(imgTag);

      // Evento de clique: ‚Äúestoura‚Äù e cai a imagem
      balloon.addEventListener('click', () => {
        popBalloon(balloon, imgObj);
      });

      // ===== Propriedades de anima√ß√£o para flutuar (X e Y) =====
      const speedX = getRandomBetween(0.03, 0.07);           // px por ms
      const direction = Math.random() < 0.5 ? -1 : 1;        // sentido horizontal
      const ampY = getRandomBetween(10, 30);                 // amplitude da oscila√ß√£o vertical
      const freqY = getRandomBetween(0.002, 0.005);          // frequ√™ncia vertical
      const phaseX = Math.random() * Math.PI * 2;            // fase horizontal (n√£o usada ativamente aqui, mas pode servir)
      const phaseY = Math.random() * Math.PI * 2;            // fase vertical

      balloon._floatProps = {
        speedX,
        direction,
        amplitudeY: ampY,
        frequencyY: freqY,
        phaseX,
        phaseY,
        startLeft: randomX,
        topBase: initialTop,
        width: balW,
        lastTimestamp: null
      };

      // J√° est√° no DOM. Apenas guardamos no array para animar
      balloonsArray.push(balloon);
    }

    // Gera valor aleat√≥rio entre min e max (float)
    function getRandomBetween(min, max) {
      return min + Math.random() * (max - min);
    }

    // =================================================
    // 5) AO CLICAR NO BAL√ÉO: remove bal√£o e inicia queda da imagem
    // =================================================
    function popBalloon(balloonElem, imgObj) {
      // Captura ret√¢ngulo do bal√£o (posi√ß√£o)
      const startRect = balloonElem.getBoundingClientRect();
      // Remove o bal√£o do DOM e do array
      const idx = balloonsArray.indexOf(balloonElem);
      if (idx !== -1) balloonsArray.splice(idx, 1);
      balloonElem.remove();

      // Cria elemento de imagem que cair√°
      const fallingImg = document.createElement('img');
      fallingImg.src = imgObj.src;
      fallingImg.classList.add('falling');
      fallingImg.style.left = startRect.left + (startRect.width - 60) / 2 + 'px';
      fallingImg.style.top  = startRect.top + 'px';
      fallingImg.dataset.pair = imgObj.pair;
      fallingImg.dataset.word = imgObj.word;

      document.body.appendChild(fallingImg);
      animateFall(fallingImg);
    }

    // =================================================
    // 6) ANIMA√á√ÉO DA QUEDA: verifica colis√£o com vag√µes
    // =================================================
    function animateFall(imgElement) {
      const speed = 4; // pixels por frame
      function step() {
        const currTop = parseFloat(imgElement.style.top);
        imgElement.style.top = (currTop + speed) + 'px';

        const trainRect = trainElement.getBoundingClientRect();
        const imgRect   = imgElement.getBoundingClientRect();

        if (imgRect.bottom >= trainRect.top) {
          // Verifica qual vag√£o ‚Äúrecebeu‚Äù a imagem
          const centerX = imgRect.left + imgRect.width / 2;
          const wagons  = Array.from(document.querySelectorAll('.wagon'));
          let landedWagon = null;

          for (let w of wagons) {
            const wRect = w.getBoundingClientRect();
            if (centerX >= wRect.left && centerX <= wRect.right) {
              landedWagon = w;
              break;
            }
          }

          if (landedWagon) {
            const correctPair = landedWagon.dataset.pair;
            if (correctPair === imgElement.dataset.pair) {
              // ====== ACERTO ======
              handleCorrectDrop(landedWagon, imgElement);
            } else {
              // ====== ERRO ======
              handleWrongDrop(imgElement);
            }
          } else {
            // Caiu fora do trem: volta ao jogo
            handleWrongDrop(imgElement);
          }
          return;
        }
        requestAnimationFrame(step);
      }
      requestAnimationFrame(step);
    }

    // =================================================
    // 7) TRATAMENTO DE ACERTO: encaixa imagem no vag√£o
    // =================================================
    function handleCorrectDrop(wagonElem, imgElement) {
      const wRect = wagonElem.getBoundingClientRect();
      imgElement.style.position = 'absolute';
      imgElement.style.top  = (wRect.top + wRect.height * 0.1) + 'px';
      imgElement.style.left = (wRect.left + (wRect.width - imgElement.width) / 2) + 'px';
      imgElement.style.width  = '10vw';
      imgElement.style.maxHeight = '12vh';
      imgElement.style.zIndex = '1';

      wagonElem.classList.add('correct');
      correctCount++;
      if (correctCount === numWagons) {
        showCompletionModal();
        updateNextPhaseAuth();
      }
    }

    // =================================================
    // 8) TRATAMENTO DE ERRO: volta imediatamente ao jogo
    // =================================================
    function handleWrongDrop(imgElement) {
      showFeedback();
      const pair = imgElement.dataset.pair;
      imgElement.remove(); // remove a imagem ca√≠da

      // Recria o bal√£o com a mesma imagem para voltar a flutuar
      const imgObj = imagesList.find(obj => obj.pair === pair);
      if (imgObj) {
        createBalloon(imgObj);
      }
    }

    // =================================================
    // 9) FEEDBACK VISUAL ‚ÄúTry Again!‚Äù
    // =================================================
    function showFeedback() {
      feedbackElement.style.display = 'block';
      setTimeout(() => {
        feedbackElement.style.display = 'none';
      }, 800);
    }

    // =================================================
    // 10) MODAL DE CONCLUS√ÉO
    // =================================================
    function showCompletionModal() {
      alert("Congratulations! You completed this phase.");
    }

    // =================================================
    // 11) ATUALIZA√á√ÉO DO PR√ìXIMO PHASE (igual ao original)
    // =================================================
    function updateNextPhaseAuth() {
      firebase.auth().onAuthStateChanged(user => {
        if (user) {
          updateNextPhase(user.uid);
        } else {
          console.error("Usu√°rio n√£o autenticado. N√£o ser√° poss√≠vel atualizar progresso.");
        }
      });
    }

    async function updateNextPhase(userId) {
      console.log("Updating next phase...");
      const currentPhase = getPhaseFromURL();
      const { level, unit } = getParamsFromURL();
      const dbRef = firebase.database().ref(`usuarios/${userId}/progresso/${level}/${unit}`);

      try {
        if (currentPhase === "last") {
          const nextUnit = `Unit${parseInt(unit.replace('Unit', '')) + 1}`;
          await firebase.database().ref(`usuarios/${userId}/progresso/${level}/${nextUnit}`).set({ fase1: true });
        } else if (currentPhase === "end") {
          const nextLevel = `Level${parseInt(level.replace('Level', '')) + 1}`;
          await firebase.database().ref(`usuarios/${userId}/progresso/${nextLevel}/Unit1`).set({ fase1: true });
        } else {
          const nextPhase = parseInt(currentPhase) + 1;
          await dbRef.update({ [`fase${currentPhase}`]: true, [`fase${nextPhase}`]: true });
        }
        console.log("Update successful.");
      } catch (error) {
        console.error("Error updating next phase:", error);
      }
    }

    function getPhaseFromURL() {
      const params = new URLSearchParams(window.location.search);
      return params.get('fase');
    }

    // =================================================
    // 12) REINICIAR O JOGO
    // =================================================
    function restartGame() {
      correctCount = 0;

      // 1) Remove todos os bal√µes flutuantes
      removeAllBalloons();
      balloonsArray.length = 0;

      // 2) Remove todas as imagens de queda (class="falling")
      const fallingImgs = document.querySelectorAll('.falling');
      fallingImgs.forEach(img => img.remove());

      // 3) Remove quaisquer <img> que estejam dentro dos vag√µes
      const imgsInWagons = document.querySelectorAll('.wagon img');
      imgsInWagons.forEach(img => img.remove());

      // 4) Remove a classe ‚Äúcorrect‚Äù de todos os vag√µes
      const allWagons = document.querySelectorAll('.wagon');
      allWagons.forEach(w => w.classList.remove('correct'));

      // 5) Recria tudo do zero
      initWordDropGame();
    }

    // =================================================
    // 13) INICIALIZA√á√ÉO AO CARREGAR P√ÅGINA
    // =================================================
    window.addEventListener('load', () => {
      loadCardsData(initWordDropGame);
    });

    // =================================================
    // 14) ANIMA√á√ÉO DE VOO (HORIZONTAL + OSCILA√á√ÉO VERTICAL)
    // =================================================
    function animateBalloons(timestamp) {
      for (let balloon of balloonsArray) {
        const props = balloon._floatProps;
        if (!props.lastTimestamp) {
          props.lastTimestamp = timestamp;
        }
        const delta = timestamp - props.lastTimestamp; // tempo em ms desde o √∫ltimo frame
        props.lastTimestamp = timestamp;

        // CALCULA DESLOCAMENTO HORIZONTAL
        let currLeft = parseFloat(balloon.style.left);
        const moveX   = props.speedX * props.direction * delta;
        let newLeft   = currLeft + moveX;

        // Se sair para al√©m da direita, reaparece √† esquerda
        if (newLeft > window.innerWidth) {
          newLeft = -props.width;
        }
        // Se sair para al√©m da esquerda, reaparece √† direita
        if (newLeft < -props.width) {
          newLeft = window.innerWidth;
        }

        // CALCULA OSCILA√á√ÉO VERTICAL (senoide)
        const timeTotal = timestamp; // usamos timestamp como tempo ‚Äútotal‚Äù
        const oscY      = props.amplitudeY * Math.sin(props.phaseY + props.frequencyY * timeTotal);
        const newTop    = props.topBase + oscY;

        balloon.style.left = newLeft + 'px';
        balloon.style.top  = newTop + 'px';
      }
      requestAnimationFrame(animateBalloons);
    }

    // =================================================
    // 15) EVENT LISTENER PARA REDIMENSIONAMENTO
    // =================================================
    window.addEventListener('resize', () => {
      // Se quiser, podemos recalcular props.topBase para todos os bal√µes aqui.
    });
  </script>
</body>
</html>
