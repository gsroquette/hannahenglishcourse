<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Drop Express</title>
    <style>
        /* ========== ESTILIZAÇÃO GERAL ========== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: "Times New Roman", Times, serif;
            background: url('../../../imagens/fundo.png') repeat;
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        /* ========== CONTÊINER PRINCIPAL ========== */
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        /* ========== TREM E VAGÕES ========== */
        #train {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 25%; /* altura fixa para o trem */
            background: #2c3e50; /* cor de trilho/fundo do trem */
            display: flex;
            align-items: flex-end;
            justify-content: space-around;
            padding-bottom: 10px;
        }
        .wagon {
            position: relative;
            width: calc(100% / var(--num-wagons)); /* dividimos igualmente */
            height: 80%;
            background: #ecf0f1;
            border: 3px solid #34495e;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .wagon .word {
            font-size: 1.5em;
            color: #2c3e50;
            text-transform: uppercase;
            text-align: center;
            padding: 5px;
        }
        .wagon.correct {
            animation: glow 0.8s ease-out forwards;
        }
        @keyframes glow {
            0% { box-shadow: 0 0 5px rgba(46, 204, 113, 0.5); }
            50% { box-shadow: 0 0 20px rgba(46, 204, 113, 1); }
            100% { box-shadow: 0 0 5px rgba(46, 204, 113, 0.5); }
        }

        /* ========== BALÕES + IMAGENS ========== */
        .balloon {
            position: absolute;
            top: 5%; /* começam no topo */
            width: 80px;
            height: 100px;
            background: url('balloon.png') no-repeat center center; /* imagem de fundo do balão */
            background-size: contain;
            cursor: pointer;
            transition: transform 0.2s ease;
        }
        .balloon:hover {
            transform: scale(1.1);
        }
        .balloon img {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 60px;
            object-fit: contain;
            pointer-events: none;
        }

        /* ========== FEEDBACK DE ERRO PARCIAL ========== */
        #feedback {
            position: absolute;
            top: 45%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(231, 76, 60, 0.9);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 1.2em;
            display: none;
            z-index: 1000;
        }

        /* ========== BOTÃO DE REINICIAR ========== */
        #restart-button {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px 20px;
            background-color: #2980b9;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            z-index: 1000;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transition: background-color 0.3s ease;
        }
        #restart-button:hover {
            background-color: #1c5980;
        }

        /* ========== ANIMAÇÃO DE QUEDA DA IMAGEM ========== */
        .falling {
            position: absolute;
            width: 60px;
            height: 60px;
            object-fit: contain;
            pointer-events: none;
            z-index: 500;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Botão para reiniciar a fase -->
        <button id="restart-button" onclick="restartGame()">Restart</button>

        <!-- Feedback de erro -->
        <div id="feedback">Try Again!</div>

        <!-- Contêiner do trem e vagões -->
        <div id="train"></div>
    </div>

    <!-- Firebase SDK (se você quiser manter controle de progresso, igual ao original) -->
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

    <script>
        // ===== CONFIGURAÇÃO DO FIREBASE (mantida igual ao seu código original) =====
        const firebaseConfig = {
            apiKey: "AIzaSyDGgo2H_hDKXF88xN7XnLFNUj8ikMY7Xdc",
            authDomain: "hannahenglishcourse.firebaseapp.com",
            databaseURL: "https://hannahenglishcourse-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "hannahenglishcourse",
            storageBucket: "hannahenglishcourse.appspot.com",
            messagingSenderId: "449818788486",
            appId: "1:449818788486:web:8a49d3f68591e6fb3f0707"
        };
        firebase.initializeApp(firebaseConfig);
        // =================================================================================

        // Controles gerais do jogo
        const gameContainer = document.getElementById('game-container');
        const trainElement = document.getElementById('train');
        const feedbackElement = document.getElementById('feedback');
        const restartBtn = document.getElementById('restart-button');

        let wordsList = [];          // Array das palavras (strings)
        let imagesList = [];         // Array de objetos { src: caminho, pair: 'pairX', word: 'palavra' }
        let numWagons = 0;           // Quantidade de vagões (mesmo número de palavras)
        let correctCount = 0;        // Quantos pares já foram acertados

        // =================================================
        // 1) Lê parâmetros level e unit da URL, iguais ao original
        // =================================================
        function getParamsFromURL() {
            const params = new URLSearchParams(window.location.search);
            return {
                level: params.get('level'),
                unit: params.get('unit'),
                fase: params.get('fase'),
            };
        }

        // =================================================
        // 2) Carrega palavras e imagens do seu diretório, igual ao jogo da memória
        // =================================================
        function loadCardsData(callback) {
            const { level, unit } = getParamsFromURL();
            if (!level || !unit) {
                console.error("Parâmetros 'level' e 'unit' são obrigatórios na URL.");
                return;
            }

            const wordsPath = `../../${level}/${unit}/data1/words.txt`;
            const imagePathTemplate = `../../${level}/${unit}/data1/imagens/imagem`;

            fetch(wordsPath)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Erro ao carregar palavras de ${wordsPath}`);
                    }
                    return response.text();
                })
                .then(text => {
                    const words = text.trim().split('\n');
                    wordsList = words.map(w => w.trim());
                    numWagons = wordsList.length;

                    // Monta lista de imagens com par e palavra correspondente
                    imagesList = [];
                    wordsList.forEach((word, index) => {
                        const imgPath = `${imagePathTemplate}${index + 1}.png`;
                        imagesList.push({
                            src: imgPath,
                            pair: `pair${index + 1}`,
                            word: word.trim()
                        });
                    });

                    callback(); // Chama o init do jogo
                })
                .catch(error => {
                    console.error("Erro ao carregar dados:", error);
                });
        }

        // =================================================
        // 3) Inicializa o Word Drop Express
        // =================================================
        function initWordDropGame() {
            correctCount = 0;
            trainElement.innerHTML = '';
            removeAllBalloons();

            // Configura CSS custom-property para calcular largura dos vagões
            trainElement.style.setProperty('--num-wagons', numWagons);

            // 3.1) Gera/DESENHA os vagões com as palavras
            wordsList.forEach((word, index) => {
                const wagon = document.createElement('div');
                wagon.classList.add('wagon');
                wagon.dataset.pair = `pair${index + 1}`;

                const wordDiv = document.createElement('div');
                wordDiv.classList.add('word');
                wordDiv.textContent = word;
                wagon.appendChild(wordDiv);

                trainElement.appendChild(wagon);
            });

            // 3.2) Gera os balões com imagens (no topo), cada um em x aleatório
            imagesList.forEach((imgObj, idx) => {
                createBalloon(imgObj, idx);
            });
        }

        // Função auxiliar: remove balões pré-existentes (ao reiniciar)
        function removeAllBalloons() {
            const existing = document.querySelectorAll('.balloon');
            existing.forEach(b => b.remove());
        }

        // =================================================
        // 4) CRIAÇÃO DO BALÃO (click para “estourar” e cair a imagem)
        // =================================================
        function createBalloon(imgObj, idx) {
            // Cria elemento pai “balloon”
            const balloon = document.createElement('div');
            balloon.classList.add('balloon');
            balloon.dataset.pair = imgObj.pair;
            balloon.dataset.word = imgObj.word;

            // Define posição horizontal aleatória (dentro da largura da tela)
            const screenW = window.innerWidth;
            const balloonWidth = 80; // igual ao CSS
            const maxLeft = screenW - balloonWidth - 20; // margem de 20px
            const randomX = Math.floor(Math.random() * (maxLeft - 20)) + 20;
            balloon.style.left = randomX + 'px';

            // Anexa a imagem dentro do balão
            const imgTag = document.createElement('img');
            imgTag.src = imgObj.src;
            balloon.appendChild(imgTag);

            // Evento de clique: estoura e chama queda
            balloon.addEventListener('click', () => {
                popBalloon(balloon, imgObj);
            });

            // Adiciona ao DOM
            document.body.appendChild(balloon);

            // Opcional: se quiser movimento horizontal lento (flutuação), pode adicionar animação CSS/JS aqui
            // Por simplicidade, o balão fica estático até ser clicado
        }

        // =================================================
        // 5) AO CLICAR NO BALÃO: “estoura” e inicia queda da imagem
        // =================================================
        function popBalloon(balloonElem, imgObj) {
            // Remove o balão da tela
            const startRect = balloonElem.getBoundingClientRect();
            balloonElem.remove();

            // Cria elemento de imagem que irá cair (na mesma posição do balão)
            const fallingImg = document.createElement('img');
            fallingImg.src = imgObj.src;
            fallingImg.classList.add('falling');
            fallingImg.style.left = startRect.left + (startRect.width - 60)/2 + 'px'; // centraliza a imagem dentro do balão
            fallingImg.style.top = startRect.top + 'px';
            fallingImg.dataset.pair = imgObj.pair;
            fallingImg.dataset.word = imgObj.word;

            document.body.appendChild(fallingImg);

            // Inicia animação de queda
            animateFall(fallingImg);
        }

        // =================================================
        // 6) ANIMAÇÃO DA QUEDA: verifica colisão com vagões
        // =================================================
        function animateFall(imgElement) {
            const speed = 4; // pixels por frame
            function step() {
                const currTop = parseFloat(imgElement.style.top);
                imgElement.style.top = (currTop + speed) + 'px';

                // Verifica se já atingiu o topo do trem
                const trainRect = trainElement.getBoundingClientRect();
                const imgRect = imgElement.getBoundingClientRect();

                if (imgRect.bottom >= trainRect.top) {
                    // Verificar em qual vagão caiu (pelo centro da imagem)
                    const centerX = imgRect.left + imgRect.width / 2;
                    const wagons = Array.from(document.querySelectorAll('.wagon'));
                    let landedWagon = null;

                    for (let w of wagons) {
                        const wRect = w.getBoundingClientRect();
                        if (centerX >= wRect.left && centerX <= wRect.right) {
                            landedWagon = w;
                            break;
                        }
                    }

                    if (landedWagon) {
                        const correctPair = landedWagon.dataset.pair;
                        if (correctPair === imgElement.dataset.pair) {
                            // ========== ACERTO ==========
                            handleCorrectDrop(landedWagon, imgElement);
                        } else {
                            // ========= ERRO =========
                            handleWrongDrop(imgElement);
                        }
                    } else {
                        // Se não estiver sobre nenhum vagão, some a imagem
                        imgElement.remove();
                    }
                    return;
                }

                // Continua a animação
                requestAnimationFrame(step);
            }
            requestAnimationFrame(step);
        }

        // =================================================
        // 7) TRATAMENTO DE ACERTO: “encaixa” a imagem no vagão
        // =================================================
        function handleCorrectDrop(wagonElem, imgElement) {
            // Posiciona a imagem dentro do vagão, ajustando coordenadas
            const wRect = wagonElem.getBoundingClientRect();
            imgElement.style.position = 'absolute';
            imgElement.style.top = (wRect.top + wRect.height*0.1) + 'px';  // ajusta verticalmente dentro do vagão
            imgElement.style.left = (wRect.left + (wRect.width - imgElement.width)/2) + 'px';
            imgElement.style.width = '80px';
            imgElement.style.height = '80px';
            imgElement.style.zIndex = '1';

            // Marca vagão com classe de “acerto” para animação
            wagonElem.classList.add('correct');

            // Incrementa contador de acertos
            correctCount++;
            if (correctCount === numWagons) {
                // Todas as palavras foram encontradas: fase concluída
                showCompletionModal();
                updateNextPhaseAuth();
            }
        }

        // =================================================
        // 8) TRATAMENTO DE ERRO: exibe feedback e remove a imagem
        // =================================================
        function handleWrongDrop(imgElement) {
            // Exibe mensagem de erro rápida
            showFeedback();
            // Remove a imagem errada após um breve delay
            setTimeout(() => {
                imgElement.remove();
            }, 500);
        }

        // =================================================
        // 9) FEEDBACK VISUAL DE “TRY AGAIN”
        // =================================================
        function showFeedback() {
            feedbackElement.style.display = 'block';
            setTimeout(() => {
                feedbackElement.style.display = 'none';
            }, 1000);
        }

        // =================================================
        // 10) MOSTRAR MODAL DE CONCLUSÃO (BÁSICO)
        // =================================================
        function showCompletionModal() {
            alert("Congratulations! You completed this phase.");
        }

        // =================================================
        // 11) ATUALIZAÇÃO DO PRÓXIMO PHASE (igual ao seu original)
        // =================================================
        function updateNextPhaseAuth() {
            firebase.auth().onAuthStateChanged(function(user) {
                if (user) {
                    updateNextPhase(user.uid);
                } else {
                    console.error("Usuário não autenticado. Não será possível atualizar progresso.");
                }
            });
        }

        async function updateNextPhase(userId) {
            console.log("Updating next phase...");
            const currentPhase = getPhaseFromURL();
            const { level, unit } = getParamsFromURL();
            const dbRef = firebase.database().ref(`usuarios/${userId}/progresso/${level}/${unit}`);

            try {
                if (currentPhase === "last") {
                    const nextUnit = `Unit${parseInt(unit.replace('Unit', '')) + 1}`;
                    await firebase.database().ref(`usuarios/${userId}/progresso/${level}/${nextUnit}`).set({ fase1: true });
                } else if (currentPhase === "end") {
                    const nextLevel = `Level${parseInt(level.replace('Level', '')) + 1}`;
                    await firebase.database().ref(`usuarios/${userId}/progresso/${nextLevel}/Unit1`).set({ fase1: true });
                } else {
                    const nextPhase = parseInt(currentPhase) + 1;
                    await dbRef.update({ [`fase${currentPhase}`]: true, [`fase${nextPhase}`]: true });
                }
                console.log("Update successful.");
            } catch (error) {
                console.error("Error updating next phase:", error);
            }
        }

        function getPhaseFromURL() {
            const params = new URLSearchParams(window.location.search);
            return params.get('fase');
        }

        // =================================================
        // 12) FUNÇÃO PARA REINICIAR O JOGO
        // =================================================
        function restartGame() {
            // Remove todas as imagens “caídas” e balões, reseta variáveis
            correctCount = 0;
            removeAllBalloons();
            initWordDropGame();
        }

        // =================================================
        // 13) INICIALIZAÇÃO AO CARREGAR PÁGINA
        // =================================================
        window.addEventListener('load', () => {
            loadCardsData(initWordDropGame);
        });

        // =================================================
        // 14) EVENT LISTENER PARA REDIMENSIONAMENTO (se desejar reposicionar balões)
        //     (nesse exemplo, não reposicionamos, mas poderia ser usado)
        // =================================================
        window.addEventListener('resize', () => {
            // Se quiser reposicionar balões ou ajustar algo em resize, implemente aqui
        });
    </script>
</body>
</html>
