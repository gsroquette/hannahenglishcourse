<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Word Drop Express</title>
  <style>
    /* ========== ESTILIZAÇÃO GERAL ========== */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      width: 100vw;
      height: 100vh;
      background: url('../../../imagens/fundo.png') repeat;
      position: relative;
      font-family: "Times New Roman", Times, serif;
      /* Removido overflow:hidden global para evitar que trem seja cortado */
    }

    /* ========== OVERLAY “ROTATE TO LANDSCAPE” ========== */
    #rotate-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.85);
      color: #fff;
      display: none;               /* inicialmente oculto */
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 1rem;
      box-sizing: border-box;
      z-index: 3000;               /* acima de todos os elementos do jogo */
    }
    #rotate-overlay p {
      font-size: 1.3rem;
      line-height: 1.5;
    }

    /* ========== CONTÊINER PRINCIPAL ========== */
    #game-container {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden; /* impede scroll mas não corta o trem */
    }

    /* ========== TREM E VAGÕES ========== */
    #train {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 20vh;        /* 20% da altura da viewport, deixa mais espaço ao jogo */
      background: #2c3e50; /* cor do trilho/fundo do trem */
      display: flex;
      align-items: flex-end;
      justify-content: space-around;
      padding-bottom: 10px;
      z-index: 100;        /* deve ficar acima do plano de fundo e abaixo dos balões */
    }
    .wagon {
      position: relative;
      width: calc(100% / var(--num-wagons)); /* divide igualmente a largura */
      height: 80%;                           /* 80% da altura do #train */
      background: #ecf0f1;
      border: 3px solid #34495e;
      border-radius: 5px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 101;        /* ligeiramente acima do trem, mas abaixo de balões */
      padding: 4px;
    }
    .wagon .word {
      /* Ajuste de fonte usando clamp para nunca cortar e caber em qualquer número de vagões */
      /* 12px é o mínimo, 24px é o máximo, e o valor intermediário escala de acordo com a largura de cada vagão */
      font-size: clamp(12px, calc((100vw / var(--num-wagons)) * 0.18), 24px);
      line-height: 1.1;
      color: #2c3e50;
      text-transform: uppercase;
      text-align: center;
      word-break: break-word; /* evita corte de texto */
      overflow-wrap: break-word;
    }
    .wagon.correct {
      animation: glow 0.8s ease-out forwards;
    }
    @keyframes glow {
      0%   { box-shadow: 0 0 5px rgba(46, 204, 113, 0.5); }
      50%  { box-shadow: 0 0 20px rgba(46, 204, 113, 1); }
      100% { box-shadow: 0 0 5px rgba(46, 204, 113, 0.5); }
    }

    /* ========== BALÕES + IMAGENS ========== */
    .balloon {
      position: absolute;
      /* Usa unidades relativas com limites para garantir que nunca cubram os vagões */
      width: clamp(50px, 10vw, 100px);
      height: clamp(60px, 12vw, 120px);
      background: url('balloon.png') no-repeat center center;
      background-size: contain;
      cursor: pointer;
      transition: transform 0.2s ease;
      z-index: 200; /* sempre acima dos vagões, mas abaixo do overlay */
    }
    .balloon:hover {
      transform: scale(1.1);
    }
    /* A imagem fica logo abaixo do balão, sem sobrepor os vagões */
    .balloon img {
      position: absolute;
      top: calc(100% + 5px); /* 100% da altura do balão + 5px de espaço */
      left: 50%;
      transform: translateX(-50%);
      width: clamp(40px, 8vw, 80px);
      height: clamp(40px, 8vw, 80px);
      object-fit: contain;
      pointer-events: none;
      z-index: 201; /* acima do balão, mas não interfere nos vagões */
    }

    /* ========== FEEDBACK DE ERRO ========== */
    #feedback {
      position: absolute;
      top: 45%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(231, 76, 60, 0.9);
      color: white;
      padding: 15px 25px;
      border-radius: 8px;
      font-size: 1.2em;
      display: none;
      z-index: 250; /* acima dos balões, mas abaixo do overlay */
    }

    /* ========== BOTÃO DE REINICIAR ========== */
    #restart-button {
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 10px 20px;
      background-color: #2980b9;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1em;
      z-index: 250;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      transition: background-color 0.3s ease;
    }
    #restart-button:hover {
      background-color: #1c5980;
    }

    /* ========== ANIMAÇÃO DE QUEDA DA IMAGEM ========== */
    .falling {
      position: absolute;
      width: clamp(40px, 8vw, 80px);
      height: clamp(40px, 8vw, 80px);
      object-fit: contain;
      pointer-events: none;
      z-index: 150; /* abaixo dos balões, mas acima do trem/vagões */
    }
  </style>
</head>
<body>
  <!-- Overlay que pede para girar para paisagem (Landscape) -->
  <div id="rotate-overlay">
    <p>Please rotate your device to Landscape mode to play.</p>
  </div>

  <div id="game-container">
    <!-- Botão para reiniciar a fase -->
    <button id="restart-button" onclick="restartGame()">Restart</button>

    <!-- Feedback de erro -->
    <div id="feedback">Try Again!</div>

    <!-- Contêiner do trem e vagões (sempre visível na base) -->
    <div id="train"></div>
  </div>

  <!-- Firebase SDK (mantida igual ao seu código original) -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

  <script>
    // ===== CONFIGURAÇÃO DO FIREBASE (mantida igual ao seu código original) =====
    const firebaseConfig = {
      apiKey: "AIzaSyDGgo2H_hDKXF88xN7XnLFNUj8ikMY7Xdc",
      authDomain: "hannahenglishcourse.firebaseapp.com",
      databaseURL: "https://hannahenglishcourse-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "hannahenglishcourse",
      storageBucket: "hannahenglishcourse.appspot.com",
      messagingSenderId: "449818788486",
      appId: "1:449818788486:web:8a49d3f68591e6fb3f0707"
    };
    firebase.initializeApp(firebaseConfig);
    // =================================================================================

    // Referências de DOM
    const trainElement    = document.getElementById('train');
    const feedbackElement = document.getElementById('feedback');
    const overlay         = document.getElementById('rotate-overlay');

    let wordsList    = [];  // array de palavras
    let imagesList   = [];  // array de { src, pair, word }
    let numWagons    = 0;   // número de vagões
    let correctCount = 0;   // quantos pares já foram acertados

    // Array que guarda todos os balões criados (para animar)
    const balloonsArray = [];

    // =================================================
    //  ORIENTAÇÃO E RESIZE (overlay em modo retrato)
    // =================================================
    function checkOrientation() {
      if (window.innerHeight > window.innerWidth) {
        // Modo retrato → exibe overlay e pausa o jogo (se houver loop em andamento)
        overlay.style.display = 'flex';
      } else {
        overlay.style.display = 'none';
      }
    }

    window.addEventListener('resize', () => {
      checkOrientation();
      // Ao redimensionar, queremos reposicionar trem e balões, então:
      resizeTrain();
    });
    window.addEventListener('orientationchange', () => {
      checkOrientation();
      resizeTrain();
    });
    window.addEventListener('load', () => {
      checkOrientation();
      // Só inicia o carregamento de dados após verificar orientação
      loadCardsData(initWordDropGame);
    });

    // =================================================
    // 1) Lê parâmetros level e unit da URL
    // =================================================
    function getParamsFromURL() {
      const params = new URLSearchParams(window.location.search);
      return {
        level: params.get('level'),
        unit:  params.get('unit'),
        fase:  params.get('fase'),
      };
    }

    // =================================================
    // 2) Carrega palavras e imagens do diretório
    // =================================================
    function loadCardsData(callback) {
      const { level, unit } = getParamsFromURL();
      if (!level || !unit) {
        console.error("Parâmetros 'level' e 'unit' são obrigatórios na URL.");
        return;
      }

      const wordsPath         = `../../${level}/${unit}/data1/words.txt`;
      const imagePathTemplate = `../../${level}/${unit}/data1/imagens/imagem`;

      fetch(wordsPath)
        .then(response => {
          if (!response.ok) {
            throw new Error(`Erro ao carregar palavras de ${wordsPath}`);
          }
          return response.text();
        })
        .then(text => {
          const words = text.trim().split('\n');
          wordsList   = words.map(w => w.trim());
          numWagons   = wordsList.length;

          // Monta lista de imagens com par e palavra correspondente
          imagesList = [];
          wordsList.forEach((word, index) => {
            const imgPath = `${imagePathTemplate}${index + 1}.png`;
            imagesList.push({
              src:  imgPath,
              pair: `pair${index + 1}`,
              word: word
            });
          });

          callback(); // Chama a inicialização do jogo
        })
        .catch(error => {
          console.error("Erro ao carregar dados:", error);
        });
    }

    // =================================================
    // 3) Inicializa o Word Drop Express
    // =================================================
    function initWordDropGame() {
      correctCount = 0;
      trainElement.innerHTML = '';
      removeAllBalloons();
      balloonsArray.length = 0; // limpa o array de balões

      // Ajusta custom-property para distribuir vagões
      trainElement.style.setProperty('--num-wagons', numWagons);

      // 3.1) Gera vagões com as palavras
      wordsList.forEach((word, index) => {
        const wagon = document.createElement('div');
        wagon.classList.add('wagon');
        wagon.dataset.pair = `pair${index + 1}`;

        const wordDiv = document.createElement('div');
        wordDiv.classList.add('word');
        wordDiv.textContent = word;
        wagon.appendChild(wordDiv);

        trainElement.appendChild(wagon);
      });

      // Depois que os vagões estão criados, ajusta a altura/posição no resize
      resizeTrain();

      // 3.2) Gera balões com imagens
      imagesList.forEach(imgObj => {
        createBalloon(imgObj);
      });

      // Inicia animação de voo (horizontal + vertical)
      requestAnimationFrame(animateBalloons);
    }

    // Remove todos os balões pré-existentes do DOM
    function removeAllBalloons() {
      const existing = document.querySelectorAll('.balloon');
      existing.forEach(b => b.remove());
    }

    // =================================================
    // 4) FUNÇÃO PARA AJUSTAR POSICIONAMENTO E TAMANHO DO TREM
    //    Assegura que o trem sempre fique visível na base
    // =================================================
    function resizeTrain() {
      // #train já está em bottom:0 e height:20vh. Apenas garantir que covere toda largura.
      trainElement.style.width = window.innerWidth + 'px';
      trainElement.style.height = (window.innerHeight * 0.20) + 'px'; // 20% da altura
      // Os vagões têm width calc(100%/numWagons). CSS cuida disso automaticamente.
    }

    // =================================================
    // 5) CRIAÇÃO DO BALÃO (com imagem logo abaixo)
    // =================================================
    function createBalloon(imgObj) {
      // Cria elemento “balão”
      const balloon = document.createElement('div');
      balloon.classList.add('balloon');
      balloon.dataset.pair = imgObj.pair;
      balloon.dataset.word = imgObj.word;

      // Precisamos aguardar um tick para que width/height via CSS sejam aplicados
      document.body.appendChild(balloon);
      const balloonRect = balloon.getBoundingClientRect();
      const balloonW    = balloonRect.width;
      const initialTop  = window.innerHeight * 0.05; // 5% do topo
      const screenW     = window.innerWidth;
      const randomX     = Math.floor(Math.random() * (screenW - balloonW - 20)) + 10;
      balloon.style.top  = initialTop + 'px';
      balloon.style.left = randomX + 'px';

      // Anexa a imagem “pendurada” logo abaixo
      const imgTag = document.createElement('img');
      imgTag.src = imgObj.src;
      balloon.appendChild(imgTag);

      // Evento de clique: “estoura” e cai a imagem
      balloon.addEventListener('click', () => {
        popBalloon(balloon, imgObj);
      });

      // ===== Propriedades de animação para flutuar (X e Y) =====
      const speedX    = getRandomBetween(0.03, 0.07);
      const direction = Math.random() < 0.5 ? -1 : 1;
      const ampY      = getRandomBetween(10, 30);
      const freqY     = getRandomBetween(0.002, 0.005);
      const phaseX    = Math.random() * 2 * Math.PI;
      const phaseY    = Math.random() * 2 * Math.PI;

      balloon._floatProps = {
        speedX,
        direction,
        amplitudeY: ampY,
        frequencyY: freqY,
        phaseX,
        phaseY,
        startLeft: randomX,
        topBase: initialTop,
        width: balloonW,
        lastTimestamp: null
      };

      balloonsArray.push(balloon);
    }

    // Gera valor aleatório entre min e max (float)
    function getRandomBetween(min, max) {
      return min + Math.random() * (max - min);
    }

    // =================================================
    // 6) AO CLICAR NO BALÃO: remove balão e inicia queda da imagem
    // =================================================
    function popBalloon(balloonElem, imgObj) {
      const startRect = balloonElem.getBoundingClientRect();
      balloonElem.remove(); // retira o balão
      const idx = balloonsArray.indexOf(balloonElem);
      if (idx !== -1) balloonsArray.splice(idx, 1);

      // Cria elemento de imagem que cairá
      const fallingImg = document.createElement('img');
      fallingImg.src = imgObj.src;
      fallingImg.classList.add('falling');

      // Aguarda o browser definir tamanho do .falling via CSS e então posiciona
      document.body.appendChild(fallingImg);
      const imgRect = fallingImg.getBoundingClientRect();
      fallingImg.style.left = (startRect.left + (startRect.width - imgRect.width) / 2) + 'px';
      fallingImg.style.top  = startRect.top + 'px';
      fallingImg.dataset.pair = imgObj.pair;
      fallingImg.dataset.word = imgObj.word;

      animateFall(fallingImg);
    }

    // =================================================
    // 7) ANIMAÇÃO DA QUEDA: verifica colisão com vagões
    // =================================================
    function animateFall(imgElement) {
      const speed = 4; // pixels por frame
      function step() {
        const currTop = parseFloat(imgElement.style.top);
        imgElement.style.top = (currTop + speed) + 'px';

        const trainRect = trainElement.getBoundingClientRect();
        const imgRect   = imgElement.getBoundingClientRect();

        if (imgRect.bottom >= trainRect.top) {
          // Verifica qual vagão “recebeu” a imagem
          const centerX = imgRect.left + imgRect.width / 2;
          const wagons  = Array.from(document.querySelectorAll('.wagon'));
          let landedWagon = null;

          for (let w of wagons) {
            const wRect = w.getBoundingClientRect();
            if (centerX >= wRect.left && centerX <= wRect.right) {
              landedWagon = w;
              break;
            }
          }

          if (landedWagon) {
            const correctPair = landedWagon.dataset.pair;
            if (correctPair === imgElement.dataset.pair) {
              // ====== ACERTO ======
              handleCorrectDrop(landedWagon, imgElement);
            } else {
              // ====== ERRO ======
              handleWrongDrop(imgElement);
            }
          } else {
            // Caiu fora do trem: volta ao jogo
            handleWrongDrop(imgElement);
          }
          return;
        }
        requestAnimationFrame(step);
      }
      requestAnimationFrame(step);
    }

    // =================================================
    // 8) TRATAMENTO DE ACERTO: encaixa imagem no vagão
    // =================================================
    function handleCorrectDrop(wagonElem, imgElement) {
      const wRect = wagonElem.getBoundingClientRect();
      imgElement.style.position = 'absolute';
      imgElement.style.top  = (wRect.top + wRect.height * 0.1) + 'px';
      imgElement.style.left = (wRect.left + (wRect.width - imgElement.getBoundingClientRect().width) / 2) + 'px';
      imgElement.style.width  = clampSize('8vw', '40px', '80px');
      imgElement.style.height = clampSize('8vw', '40px', '80px');
      imgElement.style.zIndex = '101';

      wagonElem.classList.add('correct');
      correctCount++;
      if (correctCount === numWagons) {
        showCompletionModal();
        updateNextPhaseAuth();
      }
    }

    // Helper para calcular clamp em JS, caso precise usar dinamicamente
    function clampSize(valueVW, minPx, maxPx) {
      // valueVW ex: "8vw"; minPx ex: "40px"; maxPx ex: "80px"
      // Calcula 8vw em pixels
      const vw = window.innerWidth * (parseFloat(valueVW) / 100);
      const min = parseFloat(minPx);
      const max = parseFloat(maxPx);
      const clamped = Math.min(Math.max(vw, min), max);
      return clamped + 'px';
    }

    // =================================================
    // 9) TRATAMENTO DE ERRO: volta imediatamente ao jogo
    // =================================================
    function handleWrongDrop(imgElement) {
      showFeedback();

      const pair = imgElement.dataset.pair;
      imgElement.remove(); // remove a imagem caída

      // Recria o balão com a mesma imagem para voltar a flutuar
      const imgObj = imagesList.find(obj => obj.pair === pair);
      if (imgObj) {
        createBalloon(imgObj);
      }
    }

    // =================================================
    // 10) FEEDBACK VISUAL “Try Again!”
    // =================================================
    function showFeedback() {
      feedbackElement.style.display = 'block';
      setTimeout(() => {
        feedbackElement.style.display = 'none';
      }, 800);
    }

    // =================================================
    // 11) MODAL DE CONCLUSÃO
    // =================================================
    function showCompletionModal() {
      alert("Congratulations! You completed this phase.");
    }

    // =================================================
    // 12) ATUALIZAÇÃO DO PRÓXIMO PHASE (igual ao original)
    // =================================================
    function updateNextPhaseAuth() {
      firebase.auth().onAuthStateChanged(user => {
        if (user) {
          updateNextPhase(user.uid);
        } else {
          console.error("Usuário não autenticado. Não será possível atualizar progresso.");
        }
      });
    }

    async function updateNextPhase(userId) {
      console.log("Updating next phase...");
      const currentPhase = getPhaseFromURL();
      const { level, unit } = getParamsFromURL();
      const dbRef = firebase.database().ref(`usuarios/${userId}/progresso/${level}/${unit}`);

      try {
        if (currentPhase === "last") {
          const nextUnit = `Unit${parseInt(unit.replace('Unit', '')) + 1}`;
          await firebase.database().ref(`usuarios/${userId}/progresso/${level}/${nextUnit}`).set({ fase1: true });
        } else if (currentPhase === "end") {
          const nextLevel = `Level${parseInt(level.replace('Level', '')) + 1}`;
          await firebase.database().ref(`usuarios/${userId}/progresso/${nextLevel}/Unit1`).set({ fase1: true });
        } else {
          const nextPhase = parseInt(currentPhase) + 1;
          await dbRef.update({ [`fase${currentPhase}`]: true, [`fase${nextPhase}`]: true });
        }
        console.log("Update successful.");
      } catch (error) {
        console.error("Error updating next phase:", error);
      }
    }

    function getParamsFromURL() {
      const params = new URLSearchParams(window.location.search);
      return params.get('fase');
    }

    // =================================================
    // 13) REINICIAR O JOGO
    // =================================================
    function restartGame() {
      // Zeramos contagem de acertos
      correctCount = 0;

      // 1) Remove todos os balões flutuantes do DOM
      removeAllBalloons();
      balloonsArray.length = 0;

      // 2) Remove todas as imagens de queda (class="falling")
      const fallingImgs = document.querySelectorAll('.falling');
      fallingImgs.forEach(img => img.remove());

      // 3) Remove quaisquer <img> que estejam dentro dos vagões (para garantir que não fique “presa” nada)
      const imgsInWagons = document.querySelectorAll('.wagon img');
      imgsInWagons.forEach(img => img.remove());

      // 4) Remove a classe “correct” de todos os vagões (para desfazer o glow)
      const allWagons = document.querySelectorAll('.wagon');
      allWagons.forEach(w => w.classList.remove('correct'));

      // 5) Recria o layout de vagões + balões do zero
      initWordDropGame();
    }

    // =================================================
    // 14) ANIMAÇÃO DE VOO (HORIZONTAL + OSCILAÇÃO VERTICAL)
    // =================================================
    function animateBalloons(timestamp) {
      for (let balloon of balloonsArray) {
        const props = balloon._floatProps;
        if (!props.lastTimestamp) {
          props.lastTimestamp = timestamp;
        }
        const delta = timestamp - props.lastTimestamp; // tempo em ms desde o último frame
        props.lastTimestamp = timestamp;

        // CALCULA DESLOCAMENTO HORIZONTAL
        let currLeft = parseFloat(balloon.style.left);
        const moveX   = props.speedX * props.direction * delta;
        let newLeft   = currLeft + moveX;

        // Se sair para além da direita, reaparece à esquerda
        if (newLeft > window.innerWidth) {
          newLeft = -props.width;
        }
        // Se sair para além da esquerda, reaparece à direita
        if (newLeft < -props.width) {
          newLeft = window.innerWidth;
        }

        // CALCULA OSCILAÇÃO VERTICAL (senoide)
        const timeTotal = timestamp;
        const oscY      = props.amplitudeY * Math.sin(props.phaseY + props.frequencyY * timeTotal);
        const newTop    = props.topBase + oscY;

        balloon.style.left = newLeft + 'px';
        balloon.style.top  = newTop + 'px';
      }
      requestAnimationFrame(animateBalloons);
    }

    // =================================================
    // 15) EVENT LISTENER PARA REDIMENSIONAMENTO (extra)
    // =================================================
    window.addEventListener('resize', () => {
      // Poderia reposicionar balões recalculando props.topBase se necessário
    });
  </script>
</body>
</html>
