<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Word Drop Express – Landscape Only</title>
  <style>
    /* ============================
       0) Reset e overflow hidden
    ============================ */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: "Times New Roman", Times, serif;
      background: url('../../../imagens/fundo.png') repeat;
    }

    /* =====================================================
       1) Wrapper que força conteúdo em “landscape”  
       Mesmo que o dispositivo esteja em portrait,  
       rotacionamos o jogo 90° para a direita
    ===================================================== */
    #landscape-wrapper {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      /* Sem transformação por padrão (landscape natural) */
      transform: none;
      transform-origin: top left;
    }
    @media screen and (orientation: portrait) {
      /* Se o dispositivo estiver em portrait,  
         rotaciona todo o conteúdo 90° para a direita  
         Ajusta width/height para caber corretamente */
      #landscape-wrapper {
        width: 100vh;
        height: 100vw;
        transform: rotate(90deg);
        transform-origin: top left;
      }
    }

    /* ============================
       2) Game Container
    ============================ */
    #game-container {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    /* ============================
       3) Trem e vagões
    ============================ */
    #train {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 25vh;        /* 25% da altura visível */
      min-height: 100px;   /* não ficar muito pequeno em telas baixas */
      background: #2c3e50;
      display: flex;
      align-items: flex-end;
      justify-content: space-around;
      padding-bottom: 5px;
    }
    .wagon {
      position: relative;
      width: calc(100% / var(--num-wagons));
      height: 80%;
      background: #ecf0f1;
      border: 3px solid #34495e;
      border-radius: 5px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .wagon .word {
      font-size: clamp(9px, 2.5vw, 24px);
      color: #2c3e50;
      text-transform: uppercase;
      text-align: center;
      padding: 2px 4px;
    }
    .wagon.correct {
      animation: glow 0.8s ease-out forwards;
    }
    @keyframes glow {
      0%   { box-shadow: 0 0 5px rgba(46, 204, 113, 0.5); }
      50%  { box-shadow: 0 0 20px rgba(46, 204, 113, 1); }
      100% { box-shadow: 0 0 5px rgba(46, 204, 113, 0.5); }
    }

    /* ============================
       4) Balões + Imagens
    ============================ */
    .balloon {
      position: absolute;
      width: 15vw;         /* 15% da largura da tela */
      max-height: 18vh;    /* no máximo 18% da altura */
      background: url('balloon.png') no-repeat center center;
      background-size: contain;
      cursor: pointer;
      transition: transform 0.2s ease;
    }
    .balloon:hover {
      transform: scale(1.1);
    }
    .balloon img {
      position: absolute;
      top: calc(100% + 1vh); /* 1% da altura abaixo do balão */
      left: 50%;
      transform: translateX(-50%);
      width: 10vw;        /* 10% da largura */
      max-height: 12vh;   /* 12% da altura */
      object-fit: contain;
      pointer-events: none;
    }

    /* ============================
       5) Feedback “Try Again!”
    ============================ */
    #feedback {
      position: absolute;
      top: 45%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(231, 76, 60, 0.9);
      color: white;
      padding: 15px 25px;
      border-radius: 8px;
      font-size: 1.2em;
      display: none;
      z-index: 1000;
      text-align: center;
    }

    /* ============================
       6) Botão Restart
    ============================ */
    #restart-button {
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 10px 20px;
      background-color: #2980b9;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1em;
      z-index: 1000;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      transition: background-color 0.3s ease;
    }
    #restart-button:hover {
      background-color: #1c5980;
    }

    /* ============================
       7) Imagem “falling”
    ============================ */
    .falling {
      position: absolute;
      width: 10vw;        /* 10% da largura */
      max-height: 12vh;   /* 12% da altura */
      object-fit: contain;
      pointer-events: none;
      z-index: 500;
    }
  </style>
</head>
<body>
  <!-- Wrapper que forçará rotação em portrait -->
  <div id="landscape-wrapper">
    <div id="game-container">
      <!-- Botão Restart -->
      <button id="restart-button" onclick="restartGame()">Restart</button>

      <!-- Feedback “Try Again!” -->
      <div id="feedback">Try Again!</div>

      <!-- Trem e vagões -->
      <div id="train"></div>
    </div>
  </div>

  <!-- Firebase SDK (inalterado) -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

  <script>
    // ===== CONFIGURAÇÃO DO FIREBASE (igual ao seu código) =====
    const firebaseConfig = {
      apiKey: "AIzaSyDGgo2H_hDKXF88xN7XnLFNUj8ikMY7Xdc",
      authDomain: "hannahenglishcourse.firebaseapp.com",
      databaseURL: "https://hannahenglishcourse-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "hannahenglishcourse",
      storageBucket: "hannahenglishcourse.appspot.com",
      messagingSenderId: "449818788486",
      appId: "1:449818788486:web:8a49d3f68591e6fb3f0707"
    };
    firebase.initializeApp(firebaseConfig);
    // =================================================================================

    // Referências de DOM
    const trainElement    = document.getElementById('train');
    const feedbackElement = document.getElementById('feedback');

    let wordsList    = [];  // array de palavras (strings)
    let imagesList   = [];  // array de { src, pair, word }
    let numWagons    = 0;   // número de vagões
    let correctCount = 0;   // quantos pares já foram acertados

    // Array que guarda todos os balões para animar
    const balloonsArray = [];

    // ============================
    // 1) Lê parâmetros level e unit da URL
    // ============================
    function getParamsFromURL() {
      const params = new URLSearchParams(window.location.search);
      return {
        level: params.get('level'),
        unit:  params.get('unit'),
        fase:  params.get('fase'),
      };
    }

    // ============================
    // 2) Carrega palavras e imagens
    // ============================
    function loadCardsData(callback) {
      const { level, unit } = getParamsFromURL();
      if (!level || !unit) {
        console.error("Parâmetros 'level' e 'unit' são obrigatórios na URL.");
        return;
      }

      const wordsPath         = `../../${level}/${unit}/data1/words.txt`;
      const imagePathTemplate = `../../${level}/${unit}/data1/imagens/imagem`;

      fetch(wordsPath)
        .then(response => {
          if (!response.ok) {
            throw new Error(`Erro ao carregar palavras de ${wordsPath}`);
          }
          return response.text();
        })
        .then(text => {
          const words = text.trim().split('\n');
          wordsList   = words.map(w => w.trim());
          numWagons   = wordsList.length;

          // Monta lista de imagens com par e palavra correspondente
          imagesList = [];
          wordsList.forEach((word, index) => {
            const imgPath = `${imagePathTemplate}${index + 1}.png`;
            imagesList.push({
              src:  imgPath,
              pair: `pair${index + 1}`,
              word: word
            });
          });

          callback(); // Chama a inicialização do jogo
        })
        .catch(error => {
          console.error("Erro ao carregar dados:", error);
        });
    }

    // ============================
    // 3) Inicializa o Word Drop Express
    // ============================
    function initWordDropGame() {
      correctCount = 0;
      trainElement.innerHTML = '';
      removeAllBalloons();
      balloonsArray.length = 0; // limpa array de balões

      // Ajusta custom-property para distribuir vagões
      trainElement.style.setProperty('--num-wagons', numWagons);

      // 3.1) Gera vagões com as palavras
      wordsList.forEach((word, index) => {
        const wagon = document.createElement('div');
        wagon.classList.add('wagon');
        wagon.dataset.pair = `pair${index + 1}`;

        const wordDiv = document.createElement('div');
        wordDiv.classList.add('word');
        wordDiv.textContent = word;
        wagon.appendChild(wordDiv);

        trainElement.appendChild(wagon);
      });

      // 3.2) Gera balões com imagens
      imagesList.forEach(imgObj => {
        createBalloon(imgObj);
      });

      // Inicia animação de voo (horizontal + vertical)
      requestAnimationFrame(animateBalloons);
    }

    // Remove todos os balões flutuantes do DOM
    function removeAllBalloons() {
      const existing = document.querySelectorAll('.balloon');
      existing.forEach(b => b.remove());
    }

    // ============================
    // 4) CRIAÇÃO DO BALÃO (com imagem logo abaixo)
    // ============================
    function createBalloon(imgObj) {
      // Cria elemento “balão”
      const balloon = document.createElement('div');
      balloon.classList.add('balloon');
      balloon.dataset.pair = imgObj.pair;
      balloon.dataset.word = imgObj.word;

      // Adiciona temporariamente ao DOM só para medir tamanho real em px
      document.body.appendChild(balloon);
      const rect = balloon.getBoundingClientRect();
      const balW = rect.width;   // largura real em px
      const balH = rect.height;  // altura real em px

      // Posição inicial: X randômico entre 0 e (largura tela - largura balão)
      const screenW = window.innerWidth;
      const randomX = Math.random() * (screenW - balW);
      const initialTop = window.innerHeight * 0.05; // 5% do topo

      balloon.style.left = randomX + 'px';
      balloon.style.top  = initialTop + 'px';

      // Anexa a imagem “pendurada” logo abaixo
      const imgTag = document.createElement('img');
      imgTag.src = imgObj.src;
      balloon.appendChild(imgTag);

      // Evento de clique: “estoura” e cai a imagem
      balloon.addEventListener('click', () => {
        popBalloon(balloon, imgObj);
      });

      // ===== Propriedades para animação de flutuação (X e Y) =====
      const speedX    = getRandomBetween(0.03, 0.07);   // px por ms
      const direction = Math.random() < 0.5 ? -1 : 1;   // sentido horizontal
      const ampY      = getRandomBetween(10, 30);       // amplitude vertical (px)
      const freqY     = getRandomBetween(0.002, 0.005); // frequência vertical (px/ms)
      const phaseX    = Math.random() * Math.PI * 2;    // fase horizontal (pode ser usada futuramente)
      const phaseY    = Math.random() * Math.PI * 2;    // fase vertical

      balloon._floatProps = {
        speedX,
        direction,
        amplitudeY: ampY,
        frequencyY: freqY,
        phaseX,
        phaseY,
        startLeft: randomX,
        topBase: initialTop,
        width: balW,
        lastTimestamp: null
      };

      // Já está no DOM. Armazena para animar
      balloonsArray.push(balloon);
    }

    // Gera valor aleatório entre min e max (float)
    function getRandomBetween(min, max) {
      return min + Math.random() * (max - min);
    }

    // ============================
    // 5) AO CLICAR NO BALÃO: remove balão e inicia queda da imagem
    // ============================
    function popBalloon(balloonElem, imgObj) {
      const startRect = balloonElem.getBoundingClientRect();
      // Remove balão do DOM e do array
      const idx = balloonsArray.indexOf(balloonElem);
      if (idx !== -1) balloonsArray.splice(idx, 1);
      balloonElem.remove();

      // Cria elemento de imagem que cairá
      const fallingImg = document.createElement('img');
      fallingImg.src       = imgObj.src;
      fallingImg.classList.add('falling');
      fallingImg.style.left = startRect.left + (startRect.width - (startRect.width * 0.667)) / 2 + 'px';
      // Explicação: a imagem tem width:10vw, mas a bounding box foi medida antes.
      // Para centralizar, subtrai 2/3 da largura do balão (aprox. 0.667 * balW).
      fallingImg.style.top  = startRect.top + 'px';
      fallingImg.dataset.pair = imgObj.pair;
      fallingImg.dataset.word = imgObj.word;

      document.body.appendChild(fallingImg);
      animateFall(fallingImg);
    }

    // ============================
    // 6) ANIMAÇÃO DA QUEDA: verifica colisão com vagões
    // ============================
    function animateFall(imgElement) {
      const speed = 4; // pixels por frame
      function step() {
        const currTop = parseFloat(imgElement.style.top);
        imgElement.style.top = (currTop + speed) + 'px';

        const trainRect = trainElement.getBoundingClientRect();
        const imgRect   = imgElement.getBoundingClientRect();

        if (imgRect.bottom >= trainRect.top) {
          // Verifica em qual vagão a imagem caiu (baseado no centro X)
          const centerX = imgRect.left + imgRect.width / 2;
          const wagons  = Array.from(document.querySelectorAll('.wagon'));
          let landedWagon = null;

          for (let w of wagons) {
            const wRect = w.getBoundingClientRect();
            if (centerX >= wRect.left && centerX <= wRect.right) {
              landedWagon = w;
              break;
            }
          }

          if (landedWagon) {
            const correctPair = landedWagon.dataset.pair;
            if (correctPair === imgElement.dataset.pair) {
              // ACERTO
              handleCorrectDrop(landedWagon, imgElement);
            } else {
              // ERRO
              handleWrongDrop(imgElement);
            }
          } else {
            // Caiu fora do trem → volta imediatamente ao jogo
            handleWrongDrop(imgElement);
          }
          return;
        }
        requestAnimationFrame(step);
      }
      requestAnimationFrame(step);
    }

    // ============================
    // 7) TRATAMENTO DE ACERTO: encaixa imagem no vagão
    // ============================
    function handleCorrectDrop(wagonElem, imgElement) {
      const wRect = wagonElem.getBoundingClientRect();
      imgElement.style.position   = 'absolute';
      imgElement.style.top        = (wRect.top + wRect.height * 0.1) + 'px';
      imgElement.style.left       = (wRect.left + (wRect.width - (window.innerWidth * 0.10)) / 2) + 'px';
      imgElement.style.width      = '10vw';
      imgElement.style.maxHeight  = '12vh';
      imgElement.style.zIndex     = '1';

      wagonElem.classList.add('correct');
      correctCount++;
      if (correctCount === numWagons) {
        showCompletionModal();
        updateNextPhaseAuth();
      }
    }

    // ============================
    // 8) TRATAMENTO DE ERRO: volta imediatamente ao jogo
    // ============================
    function handleWrongDrop(imgElement) {
      showFeedback();

      const pair = imgElement.dataset.pair;
      imgElement.remove(); // remove a imagem caída

      // Recria o balão com a mesma imagem para voltar a flutuar
      const imgObj = imagesList.find(obj => obj.pair === pair);
      if (imgObj) {
        createBalloon(imgObj);
      }
    }

    // ============================
    // 9) FEEDBACK “Try Again!”
    // ============================
    function showFeedback() {
      feedbackElement.style.display = 'block';
      setTimeout(() => {
        feedbackElement.style.display = 'none';
      }, 800);
    }

    // ============================
    // 10) MODAL DE CONCLUSÃO
    // ============================
    function showCompletionModal() {
      alert("Congratulations! You completed this phase.");
    }

    // ============================
    // 11) ATUALIZAÇÃO DO PRÓXIMO PHASE (igual ao original)
    // ============================
    function updateNextPhaseAuth() {
      firebase.auth().onAuthStateChanged(user => {
        if (user) {
          updateNextPhase(user.uid);
        } else {
          console.error("Usuário não autenticado. Não será possível atualizar progresso.");
        }
      });
    }

    async function updateNextPhase(userId) {
      console.log("Updating next phase...");
      const currentPhase = getPhaseFromURL();
      const { level, unit } = getParamsFromURL();
      const dbRef = firebase.database().ref(`usuarios/${userId}/progresso/${level}/${unit}`);

      try {
        if (currentPhase === "last") {
          const nextUnit = `Unit${parseInt(unit.replace('Unit', '')) + 1}`;
          await firebase.database().ref(`usuarios/${userId}/progresso/${level}/${nextUnit}`).set({ fase1: true });
        } else if (currentPhase === "end") {
          const nextLevel = `Level${parseInt(level.replace('Level', '')) + 1}`;
          await firebase.database().ref(`usuarios/${userId}/progresso/${nextLevel}/Unit1`).set({ fase1: true });
        } else {
          const nextPhase = parseInt(currentPhase) + 1;
          await dbRef.update({ [`fase${currentPhase}`]: true, [`fase${nextPhase}`]: true });
        }
        console.log("Update successful.");
      } catch (error) {
        console.error("Error updating next phase:", error);
      }
    }

    function getPhaseFromURL() {
      const params = new URLSearchParams(window.location.search);
      return params.get('fase');
    }

    // ============================
    // 12) REINICIAR O JOGO
    // ============================
    function restartGame() {
      correctCount = 0;

      // 1) Remove todos os balões flutuantes
      removeAllBalloons();
      balloonsArray.length = 0;

      // 2) Remove todas as imagens de queda (class="falling")
      const fallingImgs = document.querySelectorAll('.falling');
      fallingImgs.forEach(img => img.remove());

      // 3) Remove quaisquer <img> que estejam dentro dos vagões
      const imgsInWagons = document.querySelectorAll('.wagon img');
      imgsInWagons.forEach(img => img.remove());

      // 4) Remove a classe “correct” de todos os vagões
      const allWagons = document.querySelectorAll('.wagon');
      allWagons.forEach(w => w.classList.remove('correct'));

      // 5) Recria tudo do zero
      initWordDropGame();
    }

    // ============================
    // 13) INICIALIZAÇÃO AO CARREGAR PÁGINA
    // ============================
    window.addEventListener('load', () => {
      loadCardsData(initWordDropGame);
    });

    // ============================
    // 14) ANIMAÇÃO DE VOO (HORIZONTAL + OSCILAÇÃO VERTICAL)
    // ============================
    function animateBalloons(timestamp) {
      for (let balloon of balloonsArray) {
        const props = balloon._floatProps;
        if (!props.lastTimestamp) {
          props.lastTimestamp = timestamp;
        }
        const delta = timestamp - props.lastTimestamp; // tempo em ms desde o último frame
        props.lastTimestamp = timestamp;

        // CALCULA DESLOCAMENTO HORIZONTAL
        let currLeft = parseFloat(balloon.style.left);
        const moveX   = props.speedX * props.direction * delta;
        let newLeft   = currLeft + moveX;

        // Se sair para além da direita, reaparece à esquerda
        if (newLeft > window.innerWidth) {
          newLeft = -props.width;
        }
        // Se sair para além da esquerda, reaparece à direita
        if (newLeft < -props.width) {
          newLeft = window.innerWidth;
        }

        // CALCULA OSCILAÇÃO VERTICAL (senoide)
        const timeTotal = timestamp; // usamos timestamp como tempo “total”
        const oscY      = props.amplitudeY * Math.sin(props.phaseY + props.frequencyY * timeTotal);
        const newTop    = props.topBase + oscY;

        balloon.style.left = newLeft + 'px';
        balloon.style.top  = newTop + 'px';
      }
      requestAnimationFrame(animateBalloons);
    }

    // ============================
    // 15) EVENT LISTENER PARA REDIMENSIONAMENTO
    // ============================
    window.addEventListener('resize', () => {
      // Caso queira, poderia recalcular props.topBase para os balões
      // Exemplo (não obrigatório):
      // for (let balloon of balloonsArray) {
      //   balloon._floatProps.topBase = window.innerHeight * 0.05;
      // }
    });
  </script>
</body>
</html>
