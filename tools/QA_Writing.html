<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hannah ‚Äî Prompt Builder v3.1 (Separated Outputs)</title>
  <style>
    :root { --bg:#0b1220; --card:#0f1a33; --muted:#8aa0c8; --text:#e9f0ff; --border:#1f2f55; }
    body { margin:0; font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:linear-gradient(180deg,var(--bg),#050914); color:var(--text); }
    .wrap { max-width:1200px; margin:0 auto; padding:22px; }
    h1 { margin:0 0 6px; font-size:20px; letter-spacing:.2px; }
    .sub { margin:0 0 18px; color:var(--muted); font-size:13px; }
    .grid { display:grid; grid-template-columns: 1fr 1fr; gap:14px; }
    @media (max-width: 980px){ .grid{ grid-template-columns:1fr; } }
    .card { background:rgba(15,26,51,.86); border:1px solid var(--border); border-radius:14px; padding:14px; box-shadow: 0 8px 30px rgba(0,0,0,.25); }
    .row { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    @media (max-width: 540px){ .row{ grid-template-columns:1fr; } }
    label { display:block; font-size:12px; color:var(--muted); margin:0 0 6px; }
    input, select, textarea {
      width:100%; box-sizing:border-box;
      background:#071127; color:var(--text);
      border:1px solid var(--border);
      border-radius:10px; padding:10px 10px;
      outline:none;
    }
    textarea { min-height:140px; resize:vertical; line-height:1.35; }
    .small { font-size:12px; color:var(--muted); margin-top:6px; }
    .btnbar { display:flex; flex-wrap:wrap; gap:10px; margin-top:10px; align-items:center; }
    button {
      border:1px solid var(--border);
      background:#0a1733;
      color:var(--text);
      padding:10px 12px;
      border-radius:10px;
      cursor:pointer;
      font-weight:600;
    }
    button.primary { border-color: rgba(97,218,251,.35); background: rgba(97,218,251,.14); }
    button:disabled { opacity:.5; cursor:not-allowed; }
    .pill { display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px; border:1px solid var(--border); color:var(--muted); font-size:12px; }
    .ok { color:#a6ffbf; }
    .warn { color:#ffdba6; }
    .err { color:#ffb0b0; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .hr { height:1px; background: rgba(31,47,85,.9); margin:12px 0; }
    .hint { color:var(--muted); font-size:12px; margin-top:6px; }
    .sectionTitle { margin:0 0 8px; font-size:14px; }
    .outGrid { display:grid; grid-template-columns: 1fr; gap:12px; }
    .outBox { border:1px solid var(--border); border-radius:14px; padding:12px; background: rgba(7,17,39,.55); }
    .outHead { display:flex; gap:10px; align-items:center; justify-content:space-between; margin-bottom:8px; }
    .outHead strong { font-size:13px; }
    .copyHint { color:var(--muted); font-size:12px; margin-top:6px; }
    .count { font-size:12px; color:var(--muted); }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>üß† Prompt Builder v3.1 ‚Äî Sa√≠das Separadas por Bloco</h1>
    <p class="sub">
      Ajustes: (1) cada sa√≠da em seu pr√≥prio quadro com bot√£o Copiar; (2) prompts.txt de FILLBLANK usam palavra completa (sem <span class="mono">{blank}</span>).
    </p>

    <div class="grid">
      <!-- LEFT: Inputs -->
      <div class="card">
        <h2 class="sectionTitle">1) Entradas e Carregamento</h2>

        <div class="row">
          <div>
            <label for="baseUrl">Base URL (Netlify)</label>
            <input id="baseUrl" value="https://hannahenglishcourse.netlify.app" />
            <div class="small">Sem barra no final.</div>
          </div>

          <div>
            <label for="cefr">N√≠vel CEFR (Aluno)</label>
            <select id="cefr">
              <option value="Starter" selected>Starter</option>
              <option value="Pre-A1">Pre-A1</option>
              <option value="A1">A1</option>
              <option value="A2">A2</option>
              <option value="B1">B1</option>
              <option value="B2">B2</option>
              <option value="C1">C1</option>
              <option value="C2">C2</option>
            </select>
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <div>
            <label for="level">Level</label>
            <input id="level" value="Level0" />
          </div>
          <div>
            <label for="unit">Unit</label>
            <input id="unit" value="Unit1" />
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <div>
            <label for="qaA">QA Grupo A</label>
            <input id="qaA" value="QA5" />
          </div>
          <div>
            <label for="qaB">QA Grupo B</label>
            <input id="qaB" value="QA6" />
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <div>
            <label for="qaC">QA Grupo C</label>
            <input id="qaC" value="QA7" />
          </div>
          <div>
            <label>&nbsp;</label>
            <div class="btnbar" style="margin-top:0;">
              <button class="primary" id="btnLoadAll">Carregar words do Netlify</button>
              <span class="pill">Status: <span class="warn" id="statusText">Aguardando</span></span>
            </div>
          </div>
        </div>

        <div class="hr"></div>

        <div class="row">
          <div>
            <label for="groupA">Grupo A (data1/words.txt) ‚Äî obrigat√≥rio</label>
            <textarea id="groupA" placeholder="1 palavra por linha (UPPERCASE)"></textarea>
            <div class="small">/{level}/{unit}/data1/words.txt</div>
          </div>
          <div>
            <label for="groupB">Grupo B (data2/words.txt) ‚Äî opcional</label>
            <textarea id="groupB" placeholder="1 palavra por linha (UPPERCASE)"></textarea>
            <div class="small">/{level}/{unit}/data2/words.txt</div>
          </div>
        </div>

        <div style="margin-top:10px;">
          <label for="groupC">Grupo C (data3/words.txt) ‚Äî opcional</label>
          <textarea id="groupC" placeholder="Se n√£o existir na unit, pode ficar vazio"></textarea>
          <div class="small">/{level}/{unit}/data3/words.txt</div>
        </div>

        <div class="btnbar">
          <button class="primary" id="btnGenerate">Gerar Prompt Completo</button>
          <span class="pill">Obs: Bloco B/C s√≥ aparece se houver palavras.</span>
        </div>

        <div class="hint">
          Importante: nos <span class="mono">Block*_prompts.txt</span>, FILLBLANK deve virar <span class="mono">WRITE: WORD</span> (palavra completa), sem {blank}.
        </div>
      </div>

      <!-- RIGHT: Outputs -->
      <div class="card">
        <h2 class="sectionTitle">2) Sa√≠das (copiar separadamente)</h2>
        <div class="outGrid">

          <div class="outBox" id="boxAJson" style="display:none;">
            <div class="outHead">
              <strong>BLOCK A ‚Äî PROMPT COMPLETO</strong>
              <div style="display:flex; gap:10px; align-items:center;">
                <span class="count" id="countAJson">0 chars</span>
                <button id="copyAJson" disabled>Copiar</button>
              </div>
            </div>
            <textarea id="outAJson" class="mono" style="min-height:180px;"></textarea>
            <div class="copyHint" id="hintAJson"></div>
          </div>

          <div class="outBox" id="boxAPrompts" style="display:none;">
            <div class="outHead">
              <strong>BLOCK A ‚Äî BlockA_prompts.txt</strong>
              <div style="display:flex; gap:10px; align-items:center;">
                <span class="count" id="countAPrompts">0 chars</span>
                <button id="copyAPrompts" disabled>Copiar</button>
              </div>
            </div>
            <textarea id="outAPrompts" class="mono" style="min-height:140px;"></textarea>
            <div class="copyHint" id="hintAPrompts"></div>
          </div>

          <div class="outBox" id="boxBJson" style="display:none;">
            <div class="outHead">
              <strong>BLOCK B ‚Äî PROMPT COMPLETO</strong>
              <div style="display:flex; gap:10px; align-items:center;">
                <span class="count" id="countBJson">0 chars</span>
                <button id="copyBJson" disabled>Copiar</button>
              </div>
            </div>
            <textarea id="outBJson" class="mono" style="min-height:180px;"></textarea>
            <div class="copyHint" id="hintBJson"></div>
          </div>

          <div class="outBox" id="boxBPrompts" style="display:none;">
            <div class="outHead">
              <strong>BLOCK B ‚Äî BlockB_prompts.txt</strong>
              <div style="display:flex; gap:10px; align-items:center;">
                <span class="count" id="countBPrompts">0 chars</span>
                <button id="copyBPrompts" disabled>Copiar</button>
              </div>
            </div>
            <textarea id="outBPrompts" class="mono" style="min-height:140px;"></textarea>
            <div class="copyHint" id="hintBPrompts"></div>
          </div>

          <div class="outBox" id="boxCJson" style="display:none;">
            <div class="outHead">
              <strong>BLOCK C ‚Äî PROMPT COMPLETO</strong>
              <div style="display:flex; gap:10px; align-items:center;">
                <span class="count" id="countCJson">0 chars</span>
                <button id="copyCJson" disabled>Copiar</button>
              </div>
            </div>
            <textarea id="outCJson" class="mono" style="min-height:180px;"></textarea>
            <div class="copyHint" id="hintCJson"></div>
          </div>

          <div class="outBox" id="boxCPrompts" style="display:none;">
            <div class="outHead">
              <strong>BLOCK C ‚Äî BlockC_prompts.txt</strong>
              <div style="display:flex; gap:10px; align-items:center;">
                <span class="count" id="countCPrompts">0 chars</span>
                <button id="copyCPrompts" disabled>Copiar</button>
              </div>
            </div>
            <textarea id="outCPrompts" class="mono" style="min-height:140px;"></textarea>
            <div class="copyHint" id="hintCPrompts"></div>
          </div>

        </div>
      </div>
    </div>
  </div>

  <script>
    // ========= Helpers =========
    function $(id){ return document.getElementById(id); }
    function normalizeBaseUrl(url){ return String(url || "").trim().replace(/\/+$/, ""); }
    function normalizePathSegment(seg){ return String(seg || "").trim().replace(/^\/+|\/+$/g, ""); }
    function joinUrl(base, path){
      base = normalizeBaseUrl(base);
      path = String(path || "").trim();
      if (!path.startsWith("/")) path = "/" + path;
      return base + path;
    }
    function setStatus(type, msg){
      const el = $("statusText");
      el.textContent = msg;
      el.className = type; // ok | warn | err
    }
    async function fetchText(url){
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status + " ‚Äî " + url);
      return await res.text();
    }
    function parseWords(raw){
      return String(raw || "")
        .split(/\r?\n/)
        .map(s => s.trim())
        .filter(Boolean)
        .map(w => w.toUpperCase());
    }
    function wordsToTextarea(words){ return words.join("\n"); }

    // Clipboard (Safari-safe)
    async function copyToClipboard(text){
      if (navigator.clipboard && navigator.clipboard.writeText) {
        await navigator.clipboard.writeText(text);
        return true;
      }
      const ta = document.createElement("textarea");
      ta.value = text;
      ta.setAttribute("readonly", "");
      ta.style.position = "fixed";
      ta.style.top = "-9999px";
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, ta.value.length);
      let ok = false;
      try { ok = document.execCommand("copy"); } catch(e) { ok = false; }
      document.body.removeChild(ta);
      return ok;
    }

    function setBoxContent(boxId, textareaId, countId, btnId, hintId, text){
      const box = $(boxId);
      const ta = $(textareaId);
      const count = $(countId);
      const btn = $(btnId);
      const hint = $(hintId);

      box.style.display = "block";
      ta.value = text || "";
      count.textContent = (ta.value || "").length + " chars";
      btn.disabled = !(ta.value || "").trim().length;
      hint.textContent = "";
    }

    function hideBox(boxId){
      $(boxId).style.display = "none";
    }

    // ========= Prompt Builders =========
    function buildPromptBaseHeader({cefr, level, unit, qaA, qaB, qaC}){
      // Prompt completo (com todas instru√ß√µes), atualizado:
      // - Mant√©m tudo.
      // - Audio_mcq: mant√©m exemplo SEM "tts".
      // - prompts.txt: FILLBLANK deve usar palavra completa (WRITE: WORD).
      return [
`üß† PROMPT DEFINITIVO ‚Äî GERADOR DE QUEST√ïES (Hannah Questions)`,
``,
`Voc√™ √© uma IA respons√°vel por gerar atividades pedag√≥gicas em JSON para o aplicativo Hannah English Course, voltado para crian√ßas iniciantes de ingl√™s.`,
``,
`Seu objetivo √© criar blocos de 10 quest√µes para cada grupo de palavras (A, B e opcionalmente C), seguindo rigorosamente todas as regras abaixo.`,
``,
`‚ö†Ô∏è Este sistema n√£o tolera improvisa√ß√µes.`,
`‚ö†Ô∏è Qualquer viola√ß√£o de caminho, tipo ou l√≥gica invalida a atividade.`,
``,
`üî¥ CONFIGURA√á√ÉO GLOBAL OBRIGAT√ìRIA (N√ÉO IGNORAR)`,
``,
`Antes de gerar qualquer exerc√≠cio, considere obrigatoriamente as seguintes informa√ß√µes de contexto, que definem onde os arquivos ser√£o buscados e gravados:`,
``,
`üìò Unidade (Unit)`,
``,
`Unit atual: ${unit}`,
``,
`Todos os caminhos de imagens, √°udios e prompts devem usar exatamente esta unidade, a menos que eu indique outra explicitamente.`,
``,
`üéß Estrutura de QA por Grupo`,
``,
`Cada grupo utiliza um diret√≥rio de QA espec√≠fico, que n√£o pode ser alterado:`,
``,
`Grupo A`,
``,
`QA: ${qaA}`,
``,
`PromptAudio:`,
`/${level}/${unit}/${qaA}/prompt{q}.mp3`,
``,
`Grupo B`,
``,
`QA: ${qaB}`,
``,
`PromptAudio:`,
`/${level}/${unit}/${qaB}/prompt{q}.mp3`,
``,
`Grupo C (se existir)`,
``,
`QA: ${qaC}`,
``,
`PromptAudio:`,
`/${level}/${unit}/${qaC}/prompt{q}.mp3`,
``,
`‚ö†Ô∏è Regra absoluta:`,
``,
`‚ùå Nunca misturar QA entre grupos`,
``,
`‚ùå Nunca inferir QA automaticamente`,
``,
`‚úîÔ∏è Sempre respeitar exatamente o QA definido acima`,
``,
`Essas defini√ß√µes valem para todas as listas de exerc√≠cios geradas neste prompt.`,
``,
`1Ô∏è‚É£ ENTRADA (O QUE EU VOU FORNECER)`,
``,
`Eu vou fornecer:`,
``,
`Grupo A (obrigat√≥rio)`,
``,
`Grupo B (opcional)`,
``,
`Grupo C (opcional)`,
``,
`Para cada grupo, eu fornecerei:`,
``,
`Nome do grupo (A, B ou C)`,
``,
`Lista ordenada de palavras (posi√ß√£o 1, 2, 3‚Ä¶)`,
``,
`Essas palavras s√£o a √∫nica fonte de vocabul√°rio permitida`,
``,
`‚ùå √â PROIBIDO:`,
``,
`Inventar palavras`,
`Misturar palavras de grupos diferentes`,
`Criar palavras novas`,
`Alterar grafia`,
``,
`2Ô∏è‚É£ REGRA CR√çTICA ‚Äî ESTRUTURA DE PASTAS (N√ÉO ALTERAR)`,
``,
`Cada grupo corresponde diretamente a uma pasta dataX.`,
``,
`üìÇ Grupo A ‚Üí data1`,
`Imagem da palavra n:`,
`/${level}/${unit}/data1/imagens/imagem{n}.png`,
``,
`Som da palavra n:`,
`/${level}/${unit}/data1/sounds/som{n}.mp3`,
``,
`üìÇ Grupo B ‚Üí data2`,
`Imagem da palavra n:`,
`/${level}/${unit}/data2/imagens/imagem{n}.png`,
``,
`Som da palavra n:`,
`/${level}/${unit}/data2/sounds/som{n}.mp3`,
``,
`üìÇ Grupo C ‚Üí data3 (se existir)`,
`Imagem da palavra n:`,
`/${level}/${unit}/data3/imagens/imagem{n}.png`,
``,
`Som da palavra n:`,
`/${level}/${unit}/data3/sounds/som{n}.mp3`,
``,
`üìå Regra absoluta:`,
`O n√∫mero {n} vem exclusivamente da posi√ß√£o da palavra na lista fornecida.`,
``,
`3Ô∏è‚É£ TIPOS DE QUEST√ïES PERMITIDOS (APENAS ESTES 3)`,
``,
`Voc√™ S√ì PODE USAR os seguintes tipos:`,
``,
`üîπ A) ORDER (letras) ‚Äî constru√ß√£o da palavra`,
``,
`Crian√ßa monta a palavra letra por letra`,
`Alternativas s√£o LETRAS`,
`Prompt mostra a palavra-modelo`,
``,
`Estrutura (exemplo):`,
`{`,
`  "type": "order",`,
`  "prompt": "WRITE: PALAVRA",`,
`  "image": "/${level}/${unit}/dataX/imagens/imagemN.png",`,
`  "options": ["L", "E", "T", "R", "A"],`,
`  "answer": ["L", "E", "T", "R", "A"],`,
`  "promptAudio": "/${level}/${unit}/QAY/prompt1.mp3"`,
`}`,
``,
`üìå promptAudio aqui l√™ o enunciado, n√£o a resposta.`,
``,
`üîπ B) MCQ ‚Äî LISTEN. CHOOSE. (spelling auditivo)`,
``,
`Crian√ßa escuta a palavra`,
`Escolhe a grafia correta`,
`Op√ß√µes s√£o PALAVRAS escritas`,
`Cada op√ß√£o TEM √°udio pr√≥prio`,
`O bot√£o üîä N√ÉO l√™ o enunciado, l√™ a resposta correta`,
`(exemplo)`,
`Estrutura:`,
`{`,
`  "type": "audio_mcq",`,
`  "prompt": "Listen. Choose.",`,
`  "promptAudio": "/${level}/${unit}/QA2/prompt7.mp3",`,
`  "answer": "abraham",`,
`  "answerAudio": "/${level}/${unit}/data1/sounds/som1.mp3",`,
`  "optionAudios": {`,
`    "abraham": "/${level}/${unit}/data1/sounds/som1.mp3",`,
`    "sarah": "/${level}/${unit}/data1/sounds/som2.mp3",`,
`    "father": "/${level}/${unit}/data1/sounds/som3.mp3"`,
`  },`,
`  "options": [`,
`    {`,
`      "label": "ABRAHAM",`,
`      "value": "abraham",`,
`      "image": "/${level}/${unit}/data1/imagens/imagem1.png",`,
`      "audio": "/${level}/${unit}/data1/sounds/som1.mp3"`,
`    },`,
`    {`,
`      "label": "SARAH",`,
`      "value": "sarah",`,
`      "image": "/${level}/${unit}/data1/imagens/imagem2.png",`,
`      "audio": "/${level}/${unit}/data1/sounds/som2.mp3"`,
`    },`,
`    {`,
`      "label": "FATHER",`,
`      "value": "father",`,
`      "image": "/${level}/${unit}/data1/imagens/imagem3.png",`,
`      "audio": "/${level}/${unit}/data1/sounds/som3.mp3"`,
`    }`,
`  ]`,
`},`,
``,
`‚ùå N√ÉO usar tts`,
`‚ùå N√ÉO usar prompt gen√©rico para √°udio`,
``,
`üîπ C) FILL IN THE BLANK (letra faltando) ‚Äî N√öCLEO DA ATIVIDADE`,
``,
`Alternativas s√£o LETRAS`,
`A palavra aparece com {blank}`,
`Foco m√°ximo em ortografia`,
``,
`Estrutura (exemplo):`,
`{`,
`  "type": "fillblank",`,
`  "prompt": "WRITE: W{blank}RD.",`,
`  "image": "/${level}/${unit}/dataX/imagens/imagemN.png",`,
`  "options": [`,
`    { "label": "O", "value": "o" },`,
`    { "label": "A", "value": "a" },`,
`    { "label": "E", "value": "e" }`,
`  ],`,
`  "answer": "o",`,
`  "promptAudio": "/${level}/${unit}/QAY/prompt3.mp3"`,
`}`,
``,
`üìå promptAudio aqui l√™ o enunciado, n√£o a resposta.`,
``,
`IMPORTANTE: TIPOS OFICIAIS DE QUEST√ïES (VOCABUL√ÅRIO FECHADO)`,
``,
`‚ö†Ô∏è APENAS estes 8 valores s√£o permitidos no campo type:`,
``,
`mcq`,
`yesno`,
`truefalse`,
`image_mcq`,
`audio_mcq`,
`fillblank`,
`order`,
`match`,
``,
`‚ùå N√£o inventar novos tipos`,
`‚ùå N√£o usar nomes alternativos`,
``,
`4Ô∏è‚É£ ESTRUTURA FIXA ‚Äî 10 QUEST√ïES POR GRUPO`,
``,
`Para cada grupo, voc√™ deve gerar EXATAMENTE 10 quest√µes, nesta l√≥gica pedag√≥gica:`,
``,
`1Ô∏è‚É£‚Äì2Ô∏è‚É£ ‚Üí ORDER`,
`3Ô∏è‚É£‚Äì5Ô∏è‚É£ ‚Üí FILL IN THE BLANK (letra)`,
`6Ô∏è‚É£‚Äì7Ô∏è‚É£ ‚Üí LISTEN. CHOOSE.`,
`8Ô∏è‚É£‚Äì10Ô∏è‚É£ ‚Üí FILL IN THE BLANK (letra)`,
``,
`‚úîÔ∏è Palavras podem se repetir`,
`‚úîÔ∏è Tipos podem se repetir`,
`‚ùå Nunca misturar grupos`,
``,
`5Ô∏è‚É£ PROMPTS DE √ÅUDIO (promptAudio) ‚Äî REGRA FINAL`,
``,
`üîä Para TODOS OS TIPOS DE QUEST√ïES`,
``,
`promptAudio = enunciado da quest√£o`,
``,
`Caminho:`,
``,
`/Level0/Unitx/QAY/prompt1.mp3`,
`/Level0/Unitx/QAY/prompt2.mp3`,
`...`,
``,
`6) ARQUIVOS .TXT COM LISTA DE PROMPTS (OBRIGAT√ìRIO)`,
``,
`Depois de gerar os JSONs, gere tamb√©m um arquivo .txt por grupo:`,
``,
`BlockA_prompts.txt`,
`BlockB_prompts.txt`,
`BlockC_prompts.txt (se houver grupo C)`,
``,
`Cada enunciado de quest√£o deve estar em uma linha`,
``,
`‚úÖ Regra adicional (OBRIGAT√ìRIA, para gerar √°udio corretamente):`,
`Nos arquivos Block*_prompts.txt, N√ÉO use {blank}.`,
`Ou seja, para FILL IN THE BLANK, a linha deve conter a palavra completa:`,
`WRITE: {WORD}`,
`(ex.: WRITE: WORLD)`,
``,
`7) SA√çDA ESPERADA`,
``,
`Retorne APENAS JSON`,
`Um bloco por grupo`,
`Sem coment√°rios`,
`Sem explica√ß√µes`,
`Sem texto fora do JSON`,
``,
`üéØ OBJETIVO FINAL`,
``,
`Gerar atividades que:`,
`‚úîÔ∏è funcionem imediatamente no app`,
`‚úîÔ∏è treinem escrita de forma progressiva`,
`‚úîÔ∏è respeitem rigorosamente paths e assets`,
`‚úîÔ∏è n√£o precisem de corre√ß√µes posteriores`,
``,
`10) DADOS PARA EXECU√á√ÉO`,
``,
`N√≠vel CEFR (Aluno): ${cefr}`,
`Level / Unit: ${level} / ${unit}`,
``,
`Agora eu vou colar os grupos de palavras (A, B e possivelmente C) abaixo.`
      ].join("\n");
    }

    function buildBlockPrompt({ header, groupName, groupWords, level, unit, qaForGroup, dataFolder }){
      // "PROMPT COMPLETO" por bloco: header + grupo espec√≠fico + lembrete do QA do grupo (redundante, mas evita erro)
      return [
header,
``,
`(BLOCO ATUAL)`,
`Grupo ${groupName}`,
`QA deste grupo: ${qaForGroup}`,
`Pasta deste grupo: ${dataFolder}`,
``,
`Grupo ${groupName} (lista ordenada de palavras):`,
groupWords.join("\n")
      ].join("\n");
    }

    function buildPromptsTxtLinesForGroup(groupWords){
      // 10 linhas, seguindo a estrutura fixa:
      // 1-2 ORDER => WRITE: WORD
      // 3-5 FILLBLANK => WRITE: WORD (PALAVRA COMPLETA, sem {blank})
      // 6-7 LISTEN => Listen. Choose.
      // 8-10 FILLBLANK => WRITE: WORD (completa)
      // Observa√ß√£o: palavras podem repetir; aqui escolhemos sequencialmente e repetimos se necess√°rio.
      const lines = [];
      const n = groupWords.length;

      function wordAt(i){
        if (n === 0) return "";
        return groupWords[i % n];
      }

      // 1-2 ORDER
      lines.push(`WRITE: ${wordAt(0)}`);
      lines.push(`WRITE: ${wordAt(1)}`);

      // 3-5 FILLBLANK (mas prompts.txt precisa palavra completa)
      lines.push(`WRITE: ${wordAt(2)}`);
      lines.push(`WRITE: ${wordAt(3)}`);
      lines.push(`WRITE: ${wordAt(4)}`);

      // 6-7 LISTEN
      lines.push(`Listen. Choose.`);
      lines.push(`Listen. Choose.`);

      // 8-10 FILLBLANK (palavra completa)
      lines.push(`WRITE: ${wordAt(5)}`);
      lines.push(`WRITE: ${wordAt(6)}`);
      lines.push(`WRITE: ${wordAt(7)}`);

      return lines.join("\n");
    }

    // ========= Loaders =========
    async function loadAll(){
      const baseUrl = normalizeBaseUrl($("baseUrl").value);
      const level = normalizePathSegment($("level").value);
      const unit  = normalizePathSegment($("unit").value);

      const urlA = joinUrl(baseUrl, `/${level}/${unit}/data1/words.txt`);
      const urlB = joinUrl(baseUrl, `/${level}/${unit}/data2/words.txt`);
      const urlC = joinUrl(baseUrl, `/${level}/${unit}/data3/words.txt`);

      setStatus("warn", "Carregando...");
      $("btnLoadAll").disabled = true;

      try{
        const aTxt = await fetchText(urlA);
        $("groupA").value = wordsToTextarea(parseWords(aTxt));

        try{
          const bTxt = await fetchText(urlB);
          $("groupB").value = wordsToTextarea(parseWords(bTxt));
        }catch(_e){
          $("groupB").value = "";
        }

        try{
          const cTxt = await fetchText(urlC);
          $("groupC").value = wordsToTextarea(parseWords(cTxt));
        }catch(_e){
          $("groupC").value = "";
        }

        setStatus("ok", "Carregado com sucesso");
      }catch(e){
        console.error(e);
        setStatus("err", "Erro ao carregar (ver console)");
        alert("Falha ao carregar do Netlify.\n\nDetalhe: " + (e && e.message ? e.message : String(e)));
      }finally{
        $("btnLoadAll").disabled = false;
      }
    }

    function generateSeparated(){
      // Hide all boxes first
      ["boxAJson","boxAPrompts","boxBJson","boxBPrompts","boxCJson","boxCPrompts"].forEach(hideBox);

      const cefr  = $("cefr").value;
      const level = normalizePathSegment($("level").value);
      const unit  = normalizePathSegment($("unit").value);

      const qaA = normalizePathSegment($("qaA").value);
      const qaB = normalizePathSegment($("qaB").value);
      const qaC = normalizePathSegment($("qaC").value);

      const groupA = parseWords($("groupA").value || "");
      const groupB = parseWords($("groupB").value || "");
      const groupC = parseWords($("groupC").value || "");

      if (!groupA.length){
        alert("Grupo A √© obrigat√≥rio. Preencha ou carregue do Netlify.");
        return;
      }

      const header = buildPromptBaseHeader({cefr, level, unit, qaA, qaB, qaC});

      // Block A
      const aPrompt = buildBlockPrompt({
        header,
        groupName:"A",
        groupWords: groupA,
        level, unit,
        qaForGroup: qaA,
        dataFolder: "data1"
      });
      const aPromptsTxt = buildPromptsTxtLinesForGroup(groupA);

      setBoxContent("boxAJson","outAJson","countAJson","copyAJson","hintAJson", aPrompt);
      setBoxContent("boxAPrompts","outAPrompts","countAPrompts","copyAPrompts","hintAPrompts", aPromptsTxt);

      // Block B (only if provided)
      if (groupB.length){
        const bPrompt = buildBlockPrompt({
          header,
          groupName:"B",
          groupWords: groupB,
          level, unit,
          qaForGroup: qaB,
          dataFolder: "data2"
        });
        const bPromptsTxt = buildPromptsTxtLinesForGroup(groupB);

        setBoxContent("boxBJson","outBJson","countBJson","copyBJson","hintBJson", bPrompt);
        setBoxContent("boxBPrompts","outBPrompts","countBPrompts","copyBPrompts","hintBPrompts", bPromptsTxt);
      }

      // Block C (only if provided)
      if (groupC.length){
        const cPrompt = buildBlockPrompt({
          header,
          groupName:"C",
          groupWords: groupC,
          level, unit,
          qaForGroup: qaC,
          dataFolder: "data3"
        });
        const cPromptsTxt = buildPromptsTxtLinesForGroup(groupC);

        setBoxContent("boxCJson","outCJson","countCJson","copyCJson","hintCJson", cPrompt);
        setBoxContent("boxCPrompts","outCPrompts","countCPrompts","copyCPrompts","hintCPrompts", cPromptsTxt);
      }
    }

    // ========= Copy button wiring =========
    function wireCopy(btnId, textareaId, hintId){
      $(btnId).addEventListener("click", async () => {
        const text = ($(textareaId).value || "");
        if (!text.trim()) return;
        const ok = await copyToClipboard(text);
        $(hintId).textContent = ok ? "‚úÖ Copiado." : "‚ö†Ô∏è N√£o foi poss√≠vel copiar automaticamente. Selecione e copie manualmente.";
      });
    }

    wireCopy("copyAJson","outAJson","hintAJson");
    wireCopy("copyAPrompts","outAPrompts","hintAPrompts");
    wireCopy("copyBJson","outBJson","hintBJson");
    wireCopy("copyBPrompts","outBPrompts","hintBPrompts");
    wireCopy("copyCJson","outCJson","hintCJson");
    wireCopy("copyCPrompts","outCPrompts","hintCPrompts");

    // ========= Events =========
    $("btnLoadAll").addEventListener("click", loadAll);
    $("btnGenerate").addEventListener("click", generateSeparated);
  </script>
</body>
</html>