<!DOCTYPE html> 
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Gerador de Prompt — questions.txt (Multi-Tipos)</title>
<style>
  :root{
    --bg:#0f172a; --card:#0b1022; --muted:#94a3b8; --text:#e2e8f0; --brand:#60a5fa; --ok:#22c55e; --bd:#1f2a44; --err:#ef4444;
  }
  *{box-sizing:border-box}
  body{margin:0;background:linear-gradient(180deg,#0b1022,#0f172a);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,'Helvetica Neue',Arial}
  .wrap{max-width:1100px;margin:32px auto;padding:0 16px}
  h1{font-weight:900;font-size:26px;margin:0 0 6px}
  .sub{color:var(--muted);margin:0 0 18px}
  .card{background:rgba(255,255,255,.03);border:1px solid var(--bd);border-radius:14px;padding:14px;margin-bottom:14px}
  label{display:flex;justify-content:space-between;gap:10px;font-size:13px;color:#cbd5e1;margin-bottom:6px}
  textarea{width:100%;background:#0a0f1e;border:1px solid #1f2a44;border-radius:10px;color:var(--text);padding:10px;font-size:14px;min-height:120px;line-height:1.45;resize:vertical}
  .small{min-height:100px}
  .grid{display:grid;gap:14px}
  @media(min-width:980px){.grid{grid-template-columns:1fr 1fr}}
  .inline{display:flex;gap:10px;flex-wrap:wrap;align-items:flex-end}
  select,input[type="number"],input[type="text"],input[type="file"]{background:#0a0f1e;border:1px solid #1f2a44;border-radius:10px;color:#e2e8f0;padding:10px;font-size:14px}
  button{appearance:none;border:none;background:linear-gradient(90deg,#3b82f6,#22c55e);color:white;font-weight:800;padding:10px 14px;border-radius:12px;cursor:pointer}
  button.ghost{background:transparent;border:1px solid var(--bd);color:#cbd5e1}
  .badge{font-size:12px;color:var(--muted)}
  .help{color:#9fb3c8;font-size:12px;margin-top:6px}
  .cols{display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:12px}
  .k{display:flex;gap:8px;align-items:center;justify-content:space-between;border:1px dashed #263254;border-radius:10px;padding:8px}
  .k>div{display:flex;gap:8px;align-items:center}
  .k input[type="number"]{width:88px}
  code{background:#0b1224;border:1px solid #1f2a44;border-radius:6px;padding:1px 6px}
  .note{color:#fcd34d;font-weight:700}
</style>
</head>
<body>
<div class="wrap">
  <h1>Gerador de Prompt — <span style="font-family:ui-monospace,monospace">questions.txt</span></h1>
  <p class="sub">Gera um <b>prompt</b> para a IA produzir <b>JSON</b> no formato do app Hannah, com os <b>tipos de questões</b> que você escolher.</p>

  <!-- 0) CARREGAMENTO AUTOMÁTICO (NETLIFY) -->
  <div class="card">
    <label>0) Carregar automaticamente (Netlify)</label>

    <div class="inline" style="margin-top:6px">
      <div style="flex:1;min-width:260px">
        <div class="help" style="margin-bottom:6px">Base URL</div>
        <input id="baseUrl" type="text" placeholder="https://seu-site.netlify.app" />
      </div>

      <div>
        <div class="help" style="margin-bottom:6px">Level</div>
        <input id="netLevel" type="text" placeholder="Level0" value="Level0" />
      </div>

      <div>
        <div class="help" style="margin-bottom:6px">Unit</div>
        <input id="netUnit" type="text" placeholder="Unit1" value="Unit1" />
      </div>

      <button id="btnLoadAuto" class="ghost">Carregar automaticamente</button>
      <span id="loadMsg" class="badge"></span>
    </div>

    <div class="help" style="margin-top:10px">
      <div><b>Texto de gramática (principal):</b> <code>/${level}/${unit}/DataGrammar/texto.txt</code></div>
      <div><b>Texto inspirador (apoio):</b> <code>/${level}/${unit}/DataStory/images.txt</code></div>
    </div>
  </div>

  <!-- 1) INSPIRAÇÃO & GRAMÁTICA -->
  <div class="grid">
    <div class="card">
      <label>1A) Texto inspirador (opcional)</label>
      <textarea id="inspire" placeholder="#title: ...
#imagem1
&quot;...&quot;"></textarea>
      <div class="help">Pode ficar vazio se você for usar apenas o texto de <b>Gramática</b>.</div>
    </div>
    <div class="card">
      <label>1B) Texto de gramática (principal)</label>
      <textarea id="grammar" placeholder="(Este campo será carregado automaticamente)
..."></textarea>
      <div class="help"><b>Prioridade máxima:</b> as questões devem ser geradas a partir deste texto.</div>
    </div>
  </div>

  <!-- 2) PARÂMETROS GERAIS -->
  <div class="grid">
    <div class="card">
      <label>2) Nível, quantidade, alternativas e QA</label>
      <div class="inline" style="margin-bottom:8px">
        <div>
          <div class="help" style="margin-bottom:6px">Nível (CEFR)</div>
          <select id="cefrLevel">
            <option value="Starter" selected>Starter (Pre-A1)</option>
            <option value="A1">A1</option>
            <option value="A2">A2</option>
            <option value="B1">B1</option>
            <option value="B2">B2</option>
          </select>
        </div>
        <div>
          <div class="help" style="margin-bottom:6px">Qtd. de questões</div>
          <input id="qCount" type="number" min="4" max="60" step="1" value="12" />
        </div>
        <div>
          <div class="help" style="margin-bottom:6px">Qtd. de alternativas</div>
          <input id="altCount" type="number" min="2" max="6" step="1" value="4" />
        </div>
        <div style="flex:1;min-width:260px">
          <div class="help" style="margin-bottom:6px">Base de mídia (opcional)</div>
          <input id="mediaBase" type="text" placeholder="../../LevelX/UnitY/QA/" />
        </div>
      </div>

      <div class="inline" style="margin-top:8px">
        <div style="min-width:260px;flex:1">
          <div class="help" style="margin-bottom:6px">QA (obrigatório p/ caminhos)</div>
          <input id="courseQA" type="text" placeholder="QA8" value="QA8" />
        </div>
      </div>

      <div class="help">
        <span class="note">Importante:</span> Nesta etapa, a IA deve gerar apenas o <b>núcleo das questões</b>.
        Não inclua <code>id</code>, <code>order</code>, <code>level</code>, <code>unit</code>, <code>fase</code>, <code>difficulty</code>, <code>skillType</code> — isso é adicionado depois.
      </div>
    </div>
  </div>

  <!-- 3) TIPOS E DISTRIBUIÇÃO -->
  <div class="card">
    <label>3) Tipos de questões e distribuição</label>
    <div class="help">Marque os tipos que deseja.</div>
    <div class="cols" id="types"></div>
    <div class="inline" style="margin-top:8px">
      <div>
        <input type="checkbox" id="autoDist" checked />
        <label for="autoDist" style="margin:0;gap:6px">Distribuição automática proporcional</label>
      </div>
      <span class="badge" id="sumInfo"></span>
    </div>
  </div>

  <!-- 5) AÇÕES -->
  <div class="row" style="display:flex;gap:10px;align-items:center;margin:14px 0">
    <button id="btnGen">Gerar prompt</button>
    <button id="btnCopy" class="ghost">Copiar prompt</button>
    <span id="msg" class="badge"></span>
  </div>

  <!-- 6) SAÍDA -->
  <div class="card">
    <label>6) Prompt gerado (saída) — cole na IA</label>
    <textarea id="out" class="small" placeholder="O prompt aparecerá aqui…" readonly></textarea>
  </div>
</div>

<script>
(function(){
  const $ = (id)=>document.getElementById(id);

  // Topo (Netlify)
  const baseUrlEl   = $('baseUrl');
  const netLevelEl  = $('netLevel');
  const netUnitEl   = $('netUnit');
  const btnLoadAuto = $('btnLoadAuto');
  const loadMsgEl   = $('loadMsg');

  // Textos
  const inspireEl = $('inspire');
  const grammarEl = $('grammar');

  // Configs
  const cefrLevelEl = $('cefrLevel');
  const qCountEl    = $('qCount');
  const altCountEl  = $('altCount');
  const mediaBaseEl = $('mediaBase');
  const courseQAEl  = $('courseQA');

  // UI
  const outEl      = $('out');
  const btnGen     = $('btnGen');
  const btnCopy    = $('btnCopy');
  const msgEl      = $('msg');
  const typesWrap  = $('types');
  const autoDistEl = $('autoDist');
  const sumInfoEl  = $('sumInfo');

  // Tipos alinhados ao app
  const TYPE_LIST = [
    { key:'mcq',       label:'mcq' },
    { key:'image_mcq', label:'image_mcq' },
    { key:'audio_mcq', label:'audio_mcq' },
    { key:'fillblank', label:'fillblank' },
    { key:'order',     label:'order' },
    { key:'match',     label:'match' },
    { key:'truefalse', label:'truefalse' },
    { key:'yesno',     label:'yesno' },
  ];

  function renderTypes(){
    typesWrap.innerHTML = '';
    TYPE_LIST.forEach(t => {
      const row = document.createElement('div');
      row.className = 'k';
      row.innerHTML = `
        <div>
          <input type="checkbox" id="cb_${t.key}" data-key="${t.key}" checked />
          <label for="cb_${t.key}" style="margin:0;gap:6px">${t.label}</label>
        </div>
        <div>
          <span class="badge">Qtd.</span>
          <input type="number" id="n_${t.key}" data-key="${t.key}" min="0" max="60" step="1"
                 value="0" ${autoDistEl.checked ? 'disabled' : ''} />
        </div>
      `;
      typesWrap.appendChild(row);
    });
  }
  renderTypes();

  autoDistEl.addEventListener('change', ()=>{
    TYPE_LIST.forEach(t=>{
      const n = $('n_'+t.key);
      if(!n) return;
      n.disabled = autoDistEl.checked;
    });
    updateSumInfo();
  });

  typesWrap.addEventListener('input', updateSumInfo);
  qCountEl.addEventListener('input', updateSumInfo);

  function updateSumInfo(){
    const total = parseInt(qCountEl.value||'0',10);
    let sum = 0;
    let marked = 0;

    TYPE_LIST.forEach(t=>{
      const cb = $('cb_'+t.key);
      if(cb && cb.checked) marked++;
      const n = $('n_'+t.key);
      if(n && !n.disabled){
        sum += parseInt(n.value||'0',10);
      }
    });

    if(autoDistEl.checked){
      sumInfoEl.textContent = `Auto: ${marked} tipo(s) selecionado(s) → ${total} distribuído(s)`;
    } else {
      sumInfoEl.textContent = `Manual: soma por tipo = ${sum} / ${total}`;
    }
  }
  updateSumInfo();

  function sanitize(s){ return (s||'').trim(); }

  /* -------------------------
      AUTO LOAD (NETLIFY)
  --------------------------*/

  function normalizeBaseUrl(url){
    const u = (url||'').trim();
    if(!u) return '';
    return u.endsWith('/') ? u.slice(0,-1) : u;
  }

  async function fetchTextWithTimeout(url, ms){
    const supportsAbort = typeof AbortController !== 'undefined';
    if(!supportsAbort){
      const r = await fetch(url, { cache:'no-store' });
      return { ok: r.ok, status: r.status, text: r.ok ? await r.text() : '' };
    }
    const ctrl = new AbortController();
    const timer = setTimeout(()=>ctrl.abort(), ms || 12000);
    try{
      const r = await fetch(url, { cache:'no-store', signal: ctrl.signal });
      const t = r.ok ? await r.text() : '';
      return { ok: r.ok, status: r.status, text: t };
    } finally {
      clearTimeout(timer);
    }
  }

  async function loadAuto(){
    loadMsgEl.textContent = '';
    msgEl.textContent = '';

    const base  = normalizeBaseUrl(baseUrlEl.value);
    const level = sanitize(netLevelEl.value);
    const unit  = sanitize(netUnitEl.value);

    if(!base || !level || !unit){
      loadMsgEl.textContent = '⚠ Preencha Base URL, Level e Unit (ex.: Level0 / Unit4).';
      return;
    }

    const grammarUrl = `${base}/${level}/${unit}/DataGrammar/texto.txt`;
    const inspireUrl = `${base}/${level}/${unit}/DataStory/images.txt`;

    btnLoadAuto.disabled = true;
    btnLoadAuto.textContent = 'Carregando...';
    loadMsgEl.textContent = '⏳ Buscando textos...';

    try{
      const [g, i] = await Promise.all([
        fetchTextWithTimeout(grammarUrl, 15000),
        fetchTextWithTimeout(inspireUrl, 15000)
      ]);

      if(!g.ok){
        loadMsgEl.textContent = `⚠ Erro ao carregar gramática (${g.status}).`;
        return;
      }

      grammarEl.value = (g.text || '').trim();

      if(i.ok){
        inspireEl.value = (i.text || '').trim();
      } else {
        inspireEl.value = inspireEl.value || '';
      }

      loadMsgEl.textContent = '✅ Textos carregados.';
    } catch(err){
      const m = (err && err.name === 'AbortError')
        ? '⚠ Timeout ao buscar textos. Verifique internet/base URL.'
        : '⚠ Falha ao buscar textos. Verifique base URL/paths.';
      loadMsgEl.textContent = m;
    } finally {
      btnLoadAuto.disabled = false;
      btnLoadAuto.textContent = 'Carregar automaticamente';
    }
  }

  btnLoadAuto.addEventListener('click', loadAuto);

  // Defaults
  (function initDefaults(){
    try{
      baseUrlEl.value = window.location.origin || '';
    }catch{
      baseUrlEl.value = '';
    }
    if(!sanitize(netLevelEl.value)) netLevelEl.value = 'Level0';
    if(!sanitize(netUnitEl.value))  netUnitEl.value  = 'Unit1';
  })();

  /* -------------------------
      PROMPT BUILDER
  --------------------------*/

  function getSelectedTypes(){
    return TYPE_LIST
      .filter(t=>{
        const cb = $('cb_'+t.key);
        return cb && cb.checked;
      })
      .map(t=>t.key);
  }

  function autoDistribute(total, activeTypes){
    const base = Math.floor(total / activeTypes.length);
    const rest = total % activeTypes.length;
    const map = {};
    activeTypes.forEach((t,i)=>{ map[t] = base + (i < rest ? 1 : 0); });
    return map;
  }

  function manualDistribution(){
    const map = {};
    TYPE_LIST.forEach(t=>{
      const cb = $('cb_'+t.key);
      if(!cb || !cb.checked) return;
      const n = $('n_'+t.key);
      const v = parseInt(n.value||'0',10);
      map[t.key] = v;
    });
    return map;
  }

  function buildExamples(L, U, Q){
    return `
EXEMPLOS OFICIAIS (COPIE O FORMATO EXATO; NÃO INCLUA METADADOS ADICIONADOS DEPOIS)

1) truefalse (mínimo)
{
  "type": "truefalse",
  "prompt": "Sarah laughed and said, 'I am ninety years old!'",
  "image": "/${L}/${U}/${Q}/imagem1.png",
  "options": [
    { "label": "True",  "value": "true",  "audio": "/${L}/${U}/${Q}/sounds/true.mp3" },
    { "label": "False", "value": "false", "audio": "/${L}/${U}/${Q}/sounds/false.mp3" }
  ],
  "answer": "true",
  "promptAudio": "/${L}/${U}/${Q}/prompt1.mp3"
}

2) image_mcq (mínimo)
{
  "type": "image_mcq",
  "prompt": "Look and choose the correct answer.",
  "image": "/${L}/${U}/${Q}/imagem2.png",
  "options": [
    { "label": "I am seven years old.", "value": "correct",    "audio": "/${L}/${U}/${Q}/sounds/i-am-seven-years-old.mp3" },
    { "label": "I am ten years old.",   "value": "wrong",      "audio": "/${L}/${U}/${Q}/sounds/i-am-ten-years-old.mp3" },
    { "label": "I am seven.",           "value": "incomplete", "audio": "/${L}/${U}/${Q}/sounds/i-am-seven.mp3" }
  ],
  "answer": "correct",
  "promptAudio": "/${L}/${U}/${Q}/prompt2.mp3"
}

3) yesno (mínimo)
{
  "type": "yesno",
  "prompt": "Is this Mary?",
  "image": "/${L}/${U}/${Q}/imagem3.png",
  "options": [
    { "label": "Yes", "value": "yes", "audio": "/${L}/${U}/${Q}/sounds/yes.mp3" },
    { "label": "No",  "value": "no",  "audio": "/${L}/${U}/${Q}/sounds/no.mp3" }
  ],
  "answer": "yes",
  "promptAudio": "/${L}/${U}/${Q}/prompt3.mp3"
}

4) fillblank (mínimo)
{
  "type": "fillblank",
  "prompt": "___ and Sarah lived in Canaan.",
  "image": "/${L}/${U}/${Q}/imagem4.png",
  "options": [
    { "label": "Abraham", "value": "abraham", "audio": "/${L}/${U}/${Q}/sounds/abraham.mp3" },
    { "label": "Father",  "value": "father",  "audio": "/${L}/${U}/${Q}/sounds/father.mp3" }
  ],
  "answer": "abraham",
  "promptAudio": "/${L}/${U}/${Q}/prompt4.mp3"
}

5) mcq (mínimo)
{
  "type": "mcq",
  "prompt": "Choose the correct word.",
  "options": [
    { "label": "sit down", "value": "sit-down", "audio": "/${L}/${U}/${Q}/sounds/sit-down.mp3" },
    { "label": "Stand up", "value": "stand-up", "audio": "/${L}/${U}/${Q}/sounds/stand-up.mp3" }
  ],
  "answer": "sit-down",
  "promptAudio": "/${L}/${U}/${Q}/prompt5.mp3"
}

6) audio_mcq (mínimo)
{
  "type": "audio_mcq",
  "prompt": "Listen and choose.",
  "promptAudio": "/${L}/${U}/${Q}/prompt6.mp3",
  "answerAudio": "/${L}/${U}/${Q}/answer6.mp3",
  "optionAudios": [
    "/${L}/${U}/${Q}/option6_1.mp3",
    "/${L}/${U}/${Q}/option6_2.mp3",
    "/${L}/${U}/${Q}/option6_3.mp3"
  ],
  "options": [
    { "label": "Car", "value": "car" },
    { "label": "May", "value": "may" },
    { "label": "Sit down", "value": "sit-down" }
  ],
  "answer": "car"
}

7) match (mínimo)
{
  "type": "match",
  "prompt": "Match the words.",
  "pairs": [
    { "left": "car", "right": "CAR" },
    { "left": "may", "right": "MAY" }
  ],
  "answer": "all",
  "promptAudio": "/${L}/${U}/${Q}/prompt7.mp3"
}

8) order (mínimo)
{
  "type": "order",
  "prompt": "Put the letters in order.",
  "options": ["C","A","R"],
  "answer": ["C","A","R"],
  "promptAudio": "/${L}/${U}/${Q}/prompt8.mp3"
}
`.trim();
  }

  function buildPrompt({
    textoInsp,
    textoGram,
    cefrLevel,
    total,
    altCount,
    types,
    dist,
    L,
    U,
    Q
  }){
    const textoFonte = [
      textoGram ? `TEXTO PRINCIPAL (GRAMÁTICA):\n${textoGram}` : '',
      textoInsp ? `\n\nTEXTO DE APOIO (INSPIRADOR):\n${textoInsp}` : ''
    ].filter(Boolean).join('\n');

    const levelGuide = {
      'Starter':'Use frases curtíssimas (3–6 palavras), vocabulário concreto e repetição; prompts simples e claros.',
      'A1':'Frases curtas; linguagem concreta; 1 ideia por questão.',
      'A2':'Frases simples; pode usar 2 ideias curtas.',
      'B1':'Frases breves, coesas; evite construções complexas.',
      'B2':'Frases curtas e objetivas; precisão lexical.'
    }[cefrLevel] || 'Use linguagem simples e clara, adequada ao nível.';

    const activeLabels = TYPE_LIST
      .filter(t=>types.includes(t.key))
      .map(t=>t.label)
      .join(', ');

    const distLines = Object.entries(dist)
      .map(([k,v])=>`• ${k}: ${v}`)
      .join('\n');

    const QA_RULES = `
REGRAS DE QA, IMAGENS E ÁUDIOS (OBRIGATÓRIO)
• Use estes valores nos caminhos:
  Level: "${L}"
  Unit: "${U}"
  QA: "${Q}"

• TODA imagem usada nas questões deve ser CRIADA por você (não reutilize imagens existentes da gramática).
  Portanto:
  - Se uma questão tiver "image": "/${L}/${U}/${Q}/imagemN.png"
  - ENTÃO essa mesma imagemN.png deve aparecer na lista [IMAGES_TO_CREATE] com descrição detalhada.

• Padrões:
  - image: "/${L}/${U}/${Q}/imagemN.png"
  - promptAudio: "/${L}/${U}/${Q}/promptN.mp3"  (N = posição da questão no array, começando em 1)
  - options[].audio: "/${L}/${U}/${Q}/sounds/<arquivo>.mp3"

• Nome do arquivo de áudio das alternativas:
  Derive do texto da alternativa (label), assim:
  - minúsculo
  - espaços viram hífen
  - sem acentos/pontuação
  Ex.: "Stand up" → "stand-up.mp3"; "sit down" → "sit-down.mp3"; "May" → "may.mp3"
`.trim();

    const CORE_RULES = `
REGRAS DO JSON (NESTA ETAPA)
1) Gere um JSON VÁLIDO no formato:
{
  "title": string,
  "questions": [ ... ]
}

2) Nesta etapa, gere APENAS o NÚCLEO das questões.
NÃO inclua estes campos (serão adicionados depois):
"id", "order", "level", "unit", "fase", "difficulty", "skillType".

3) Use os tipos exatamente como:
${activeLabels}

4) Opções:
• mcq / image_mcq / audio_mcq / fillblank / truefalse / yesno → devem ter "options" e "answer".
• truefalse e yesno → 2 opções.
• match → use "pairs" e "answer": "all".
• order → "options" e "answer" (ordem correta).

5) Objetivo pedagógico (MUITO IMPORTANTE)
• Gere as questões para EXPLICAR e TREINAR o conteúdo do TEXTO PRINCIPAL (GRAMÁTICA).
• Use o TEXTO DE APOIO (INSPIRADOR) apenas como CONTEXTO e VOCABULÁRIO secundário.
• Não fuja do ponto de gramática descrito no TEXTO PRINCIPAL.

6) Criatividade + didática (OBRIGATÓRIO)
• Crie questões visualmente didáticas: use imagens para ilustrar o conteúdo sempre que fizer sentido.
• Crie alternativas que ajudem a criança a aprender (sem pegadinhas injustas).
• Use frases simples e adequadas ao nível.
`.trim();

    const ASSET_OUTPUT = `
SAÍDA COMPLETA (OBRIGATÓRIO) — em 4 blocos, nesta ordem EXATA:

[QUESTIONS_JSON]
(cole aqui SOMENTE o JSON final do questions.txt)
[/QUESTIONS_JSON]

[IMAGES_TO_CREATE]
Liste TODAS as imagens usadas no JSON (mesmo nome) + descrição detalhada.
Formato: uma linha por imagem
imagemN.png — descrição detalhada da imagem (para eu gerar depois)
REGRA: se apareceu no JSON, tem que aparecer aqui. Não deixe esse bloco vazio.
[/IMAGES_TO_CREATE]

[PROMPTS_AUDIO_LIST]
Liste os textos de TODOS os prompts (perguntas) para eu gerar prompt1.mp3, prompt2.mp3, ...
Formato: uma linha por prompt (apenas texto)
[/PROMPTS_AUDIO_LIST]

[ANSWERS_AUDIO_LIST]
Liste os textos de TODAS as alternativas/respostas que precisam de áudio.
Formato: uma linha por alternativa (apenas texto).
IMPORTANTE: esses textos serão convertidos em nomes de arquivo mp3 pelo padrão:
minúsculo + espaços→hífen (ex.: "sit down"→"sit-down.mp3")
[/ANSWERS_AUDIO_LIST]
`.trim();

    const examples = buildExamples(L, U, Q);

    return (
`Crie um arquivo para <questions.txt> seguindo ESTRITAMENTE as regras abaixo.
Gere ${total} questões com os TIPOS: ${activeLabels}.

TEXTO-FONTE:
${textoFonte}

${QA_RULES}

${CORE_RULES}

NÍVEL CEFR (linguístico): ${cefrLevel}. ${levelGuide}

QUANTIDADE TOTAL DE QUESTÕES: ${total}
QUANTIDADE DE ALTERNATIVAS POR QUESTÃO: ${altCount}
(yesno e truefalse sempre têm 2 alternativas.)

DISTRIBUIÇÃO POR TIPO (respeite as quantidades):
${distLines}

${examples}

${ASSET_OUTPUT}

LEMBRETE FINAL:
• Não use Markdown.
• Não escreva explicações fora dos 4 blocos.
• Cada bloco deve ser preenchido e fechado com sua tag de fechamento.
`
    );
  }

  // Gerar prompt
  btnGen.addEventListener('click', ()=>{
    const textoInsp = sanitize(inspireEl.value);
    const textoGram = sanitize(grammarEl.value);

    const L = sanitize(netLevelEl.value);
    const U = sanitize(netUnitEl.value);
    const Q = sanitize(courseQAEl.value);

    const cefrLevel = cefrLevelEl.value;
    const total     = parseInt(qCountEl.value||'12',10);
    const altCount  = parseInt(altCountEl.value||'4',10);

    if(!textoInsp && !textoGram){
      msgEl.textContent = '⚠ Preencha ao menos um dos textos (inspirador ou gramática).';
      outEl.value = '';
      return;
    }

    if(!L || !U){
      msgEl.textContent = '⚠ Preencha Level e Unit do topo (ex.: Level0 / Unit4).';
      outEl.value = '';
      return;
    }

    if(!Q){
      msgEl.textContent = '⚠ Preencha o campo QA (ex.: QA8).';
      outEl.value = '';
      return;
    }

    const types = getSelectedTypes();
    if(!types.length){
      msgEl.textContent = '⚠ Selecione ao menos 1 tipo!';
      outEl.value = '';
      return;
    }

    let dist = {};
    if(autoDistEl.checked){
      dist = autoDistribute(total, types);
    } else {
      dist = manualDistribution();
      const sum = Object.values(dist).reduce((a,b)=>a+(+b||0),0);
      if(sum !== total){
        msgEl.textContent = `⚠ Soma manual (${sum}) ≠ total (${total}).`;
        outEl.value = '';
        return;
      }
      dist = Object.fromEntries(
        Object.entries(dist).filter(([k,v])=>types.includes(k) && v>0)
      );
    }

    const prompt = buildPrompt({
      textoInsp,
      textoGram,
      cefrLevel,
      total,
      altCount,
      types,
      dist,
      L, U, Q
    });

    outEl.value = prompt;
    outEl.focus();
    outEl.select();
    msgEl.textContent = '✅ Prompt pronto!';
  });

  // Copiar prompt
  btnCopy.addEventListener('click', async ()=>{
    try{
      await navigator.clipboard.writeText(outEl.value || '');
      btnCopy.textContent = 'Copiado!';
      setTimeout(()=> btnCopy.textContent='Copiar prompt', 1100);
    }catch{
      outEl.select();
      document.execCommand('copy');
    }
  });

})();
</script>
</body>
</html>