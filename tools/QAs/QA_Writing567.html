<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hannah ‚Äî Prompt Builder v3 (ORDER + FILLBLANK + LISTEN)</title>
  <style>
    :root { --bg:#0b1220; --card:#0f1a33; --muted:#8aa0c8; --text:#e9f0ff; --accent:#61dafb; --border:#1f2f55; }
    body { margin:0; font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:linear-gradient(180deg,var(--bg),#050914); color:var(--text); }
    .wrap { max-width:1100px; margin:0 auto; padding:22px; }
    h1 { margin:0 0 6px; font-size:20px; letter-spacing:.2px; }
    .sub { margin:0 0 18px; color:var(--muted); font-size:13px; }
    .grid { display:grid; grid-template-columns: 1fr 1fr; gap:14px; }
    @media (max-width: 980px){ .grid{ grid-template-columns:1fr; } }
    .card { background:rgba(15,26,51,.86); border:1px solid var(--border); border-radius:14px; padding:14px; box-shadow: 0 8px 30px rgba(0,0,0,.25); }
    .row { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    @media (max-width: 540px){ .row{ grid-template-columns:1fr; } }
    label { display:block; font-size:12px; color:var(--muted); margin:0 0 6px; }
    input, select, textarea {
      width:100%; box-sizing:border-box;
      background:#071127; color:var(--text);
      border:1px solid var(--border);
      border-radius:10px; padding:10px 10px;
      outline:none;
    }
    textarea { min-height:160px; resize:vertical; line-height:1.35; }
    .small { font-size:12px; color:var(--muted); margin-top:6px; }
    .btnbar { display:flex; flex-wrap:wrap; gap:10px; margin-top:10px; align-items:center; }
    button {
      border:1px solid var(--border);
      background:#0a1733;
      color:var(--text);
      padding:10px 12px;
      border-radius:10px;
      cursor:pointer;
      font-weight:600;
    }
    button.primary { border-color: rgba(97,218,251,.35); background: rgba(97,218,251,.14); }
    button:disabled { opacity:.5; cursor:not-allowed; }
    .pill { display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px; border:1px solid var(--border); color:var(--muted); font-size:12px; }
    .ok { color:#a6ffbf; }
    .warn { color:#ffdba6; }
    .err { color:#ffb0b0; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .hr { height:1px; background: rgba(31,47,85,.9); margin:12px 0; }
    .hint { color:var(--muted); font-size:12px; margin-top:6px; }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>üß† Prompt Builder v3 ‚Äî Spelling (ORDER + FILLBLANK + LISTEN)</h1>
    <p class="sub">
      Carrega automaticamente <span class="mono">words.txt</span> (data1‚Äìdata3) do Netlify e gera o prompt completo para IA criar blocos de 10 quest√µes por grupo.
      <br/>Ajustes aplicados: <span class="mono">audio_mcq sem "tts"</span> e prompts fixos com a palavra real.
    </p>

    <div class="grid">
      <!-- LEFT: Inputs -->
      <div class="card">
        <h2 style="margin:0 0 10px; font-size:15px;">1) Entradas e Carregamento</h2>

        <div class="row">
          <div>
            <label for="baseUrl">Base URL (Netlify)</label>
            <input id="baseUrl" value="https://hannahenglishcourse.netlify.app" />
            <div class="small">Sem barra no final. Ex.: <span class="mono">https://hannahenglishcourse.netlify.app</span></div>
          </div>

          <div>
            <label for="cefr">N√≠vel CEFR (Aluno)</label>
            <select id="cefr">
              <option value="Starter" selected>Starter</option>
              <option value="Pre-A1">Pre-A1</option>
              <option value="A1">A1</option>
              <option value="A2">A2</option>
              <option value="B1">B1</option>
              <option value="B2">B2</option>
              <option value="C1">C1</option>
              <option value="C2">C2</option>
            </select>
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <div>
            <label for="level">Level (path segment)</label>
            <input id="level" value="Level0" />
            <div class="small">Usado em paths: <span class="mono">/{level}/{unit}/...</span></div>
          </div>
          <div>
            <label for="unit">Unit (path segment)</label>
            <input id="unit" value="Unit1" />
            <div class="small">Use exatamente como no seu projeto (ex.: <span class="mono">Unit1</span> ou <span class="mono">unit4</span>)</div>
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <div>
            <label for="qaA">QA do Grupo A (edit√°vel)</label>
            <input id="qaA" value="QA5" />
          </div>
          <div>
            <label for="qaB">QA do Grupo B (edit√°vel)</label>
            <input id="qaB" value="QA6" />
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <div>
            <label for="qaC">QA do Grupo C (edit√°vel, se existir)</label>
            <input id="qaC" value="QA7" />
          </div>
          <div>
            <label>&nbsp;</label>
            <div class="btnbar" style="margin-top:0;">
              <button class="primary" id="btnLoadAll">Carregar words do Netlify</button>
              <span class="pill">Status: <span class="warn" id="statusText">Aguardando</span></span>
            </div>
          </div>
        </div>

        <div class="hr"></div>

        <div class="row">
          <div>
            <label for="groupA">Grupo A (data1/words.txt) ‚Äî obrigat√≥rio</label>
            <textarea id="groupA" placeholder="1 palavra por linha (UPPERCASE)"></textarea>
            <div class="small">Caminho: <span class="mono">/{level}/{unit}/data1/words.txt</span></div>
          </div>
          <div>
            <label for="groupB">Grupo B (data2/words.txt) ‚Äî opcional</label>
            <textarea id="groupB" placeholder="1 palavra por linha (UPPERCASE)"></textarea>
            <div class="small">Caminho: <span class="mono">/{level}/{unit}/data2/words.txt</span></div>
          </div>
        </div>

        <div style="margin-top:10px;">
          <label for="groupC">Grupo C (data3/words.txt) ‚Äî opcional</label>
          <textarea id="groupC" placeholder="Se n√£o existir na unit, pode ficar vazio"></textarea>
          <div class="small">Caminho: <span class="mono">/{level}/{unit}/data3/words.txt</span></div>
        </div>

        <div class="hint">
          Regras: Grupo A obrigat√≥rio. B e C opcionais. Parsing: 1 palavra por linha, UPPERCASE.
        </div>
      </div>

      <!-- RIGHT: Output -->
      <div class="card">
        <h2 style="margin:0 0 10px; font-size:15px;">2) Prompt Final</h2>

        <div class="btnbar" style="margin-top:0;">
          <button class="primary" id="btnGenerate">Gerar Prompt Completo</button>
          <button id="btnCopy" disabled>Copiar</button>
          <span class="pill">Contagem: <span class="mono" id="countInfo">0 chars</span></span>
        </div>

        <div style="margin-top:10px;">
          <label for="outPrompt">Sa√≠da</label>
          <textarea id="outPrompt" class="mono" placeholder="O prompt completo aparecer√° aqui..." style="min-height:610px;"></textarea>
          <div class="hint" id="copyHint"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ========= Helpers =========
    function $(id){ return document.getElementById(id); }
    function normalizeBaseUrl(url){ return String(url || "").trim().replace(/\/+$/, ""); }
    function normalizePathSegment(seg){ return String(seg || "").trim().replace(/^\/+|\/+$/g, ""); }
    function joinUrl(base, path){
      base = normalizeBaseUrl(base);
      path = String(path || "").trim();
      if (!path.startsWith("/")) path = "/" + path;
      return base + path;
    }
    function setStatus(type, msg){
      const el = $("statusText");
      el.textContent = msg;
      el.className = type; // ok | warn | err
    }
    async function fetchText(url){
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error("HTTP " + res.status + " ‚Äî " + url);
      return await res.text();
    }
    function parseWords(raw){
      return String(raw || "")
        .split(/\r?\n/)
        .map(s => s.trim())
        .filter(Boolean)
        .map(w => w.toUpperCase());
    }
    function wordsToTextarea(words){ return words.join("\n"); }

    // Clipboard (Safari-safe)
    async function copyToClipboard(text){
      if (navigator.clipboard && navigator.clipboard.writeText) {
        await navigator.clipboard.writeText(text);
        return true;
      }
      const ta = document.createElement("textarea");
      ta.value = text;
      ta.setAttribute("readonly", "");
      ta.style.position = "fixed";
      ta.style.top = "-9999px";
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, ta.value.length);
      let ok = false;
      try { ok = document.execCommand("copy"); } catch(e) { ok = false; }
      document.body.removeChild(ta);
      return ok;
    }
    function updateCount(){
      const txt = $("outPrompt").value || "";
      $("countInfo").textContent = txt.length + " chars";
      $("btnCopy").disabled = txt.trim().length === 0;
    }

    // ========= Prompt Template (UPDATED, mantendo todas as instru√ß√µes) =========
    // Ajustes feitos:
    // 1) "tts" removido do EXEMPLO de audio_mcq (mantendo todo o resto).
    // 2) Prompts fixos com a palavra real ("WRITE: WORD" e "WRITE: W{blank}RD.") explicados sem remover instru√ß√µes.
    function buildFullPrompt(params){
      const { cefr, level, unit, qaA, qaB, qaC, groupA, groupB, groupC } = params;

      return [
`üß† PROMPT DEFINITIVO ‚Äî GERADOR DE QUEST√ïES (Hannah Questions)`,
``,
`Voc√™ √© uma IA respons√°vel por gerar atividades pedag√≥gicas em JSON para o aplicativo Hannah English Course, voltado para crian√ßas iniciantes de ingl√™s.`,
``,
`Seu objetivo √© criar blocos de 10 quest√µes para cada grupo de palavras (A, B e opcionalmente C), seguindo rigorosamente todas as regras abaixo.`,
``,
`‚ö†Ô∏è Este sistema n√£o tolera improvisa√ß√µes.`,
`‚ö†Ô∏è Qualquer viola√ß√£o de caminho, tipo ou l√≥gica invalida a atividade.`,
``,
`üî¥ CONFIGURA√á√ÉO GLOBAL OBRIGAT√ìRIA (N√ÉO IGNORAR)`,
``,
`Antes de gerar qualquer exerc√≠cio, considere obrigatoriamente as seguintes informa√ß√µes de contexto, que definem onde os arquivos ser√£o buscados e gravados:`,
``,
`üìò Unidade (Unit)`,
``,
`Unit atual: ${unit}`,
``,
`Todos os caminhos de imagens, √°udios e prompts devem usar exatamente esta unidade, a menos que eu indique outra explicitamente.`,
``,
`üéß Estrutura de QA por Grupo`,
``,
`Cada grupo utiliza um diret√≥rio de QA espec√≠fico, que n√£o pode ser alterado:`,
``,
`Grupo A`,
``,
`QA: ${qaA}`,
``,
`PromptAudio:`,
`/${level}/${unit}/${qaA}/prompt{q}.mp3`,
``,
`Grupo B`,
``,
`QA: ${qaB}`,
``,
`PromptAudio:`,
`/${level}/${unit}/${qaB}/prompt{q}.mp3`,
``,
`Grupo C (se existir)`,
``,
`QA: ${qaC}`,
``,
`PromptAudio:`,
`/${level}/${unit}/${qaC}/prompt{q}.mp3`,
``,
`‚ö†Ô∏è Regra absoluta:`,
``,
`‚ùå Nunca misturar QA entre grupos`,
``,
`‚ùå Nunca inferir QA automaticamente`,
``,
`‚úîÔ∏è Sempre respeitar exatamente o QA definido acima`,
``,
`Essas defini√ß√µes valem para todas as listas de exerc√≠cios geradas neste prompt.`,
``,
`1Ô∏è‚É£ ENTRADA (O QUE EU VOU FORNECER)`,
``,
`Eu vou fornecer:`,
``,
`Grupo A (obrigat√≥rio)`,
``,
`Grupo B (opcional)`,
``,
`Grupo C (opcional)`,
``,
`Para cada grupo, eu fornecerei:`,
``,
`Nome do grupo (A, B ou C)`,
``,
`Lista ordenada de palavras (posi√ß√£o 1, 2, 3‚Ä¶)`,
``,
`Essas palavras s√£o a √∫nica fonte de vocabul√°rio permitida`,
``,
`‚ùå √â PROIBIDO:`,
``,
`Inventar palavras`,
``,
`Misturar palavras de grupos diferentes`,
``,
`Criar palavras novas`,
``,
`Alterar grafia`,
``,
`2Ô∏è‚É£ REGRA CR√çTICA ‚Äî ESTRUTURA DE PASTAS (N√ÉO ALTERAR)`,
``,
`Cada grupo corresponde diretamente a uma pasta dataX.`,
``,
`üìÇ Grupo A ‚Üí data1`,
`Imagem da palavra n:`,
`/${level}/${unit}/data1/imagens/imagem{n}.png`,
``,
`Som da palavra n:`,
`/${level}/${unit}/data1/sounds/som{n}.mp3`,
``,
`üìÇ Grupo B ‚Üí data2`,
`Imagem da palavra n:`,
`/${level}/${unit}/data2/imagens/imagem{n}.png`,
``,
`Som da palavra n:`,
`/${level}/${unit}/data2/sounds/som{n}.mp3`,
``,
`üìÇ Grupo C ‚Üí data3 (se existir)`,
`Imagem da palavra n:`,
`/${level}/${unit}/data3/imagens/imagem{n}.png`,
``,
`Som da palavra n:`,
`/${level}/${unit}/data3/sounds/som{n}.mp3`,
``,
``,
`üìå Regra absoluta:`,
`O n√∫mero {n} vem exclusivamente da posi√ß√£o da palavra na lista fornecida.`,
``,
`3Ô∏è‚É£ TIPOS DE QUEST√ïES PERMITIDOS (APENAS ESTES 3)`,
``,
`Voc√™ S√ì PODE USAR os seguintes tipos:`,
``,
`üîπ A) ORDER (letras) ‚Äî constru√ß√£o da palavra`,
``,
`Crian√ßa monta a palavra letra por letra`,
``,
`Alternativas s√£o LETRAS`,
``,
`Prompt mostra a palavra-modelo`,
``,
`‚úÖ Regra adicional (fixa√ß√£o do enunciado):`,
`O prompt deve ser exatamente:`,
`WRITE: {WORD}`,
`onde {WORD} √© a palavra real do item (ex.: WRITE: WORLD)`,
``,
`Estrutura (exemplo):`,
`{`,
`  "type": "order",`,
`  "prompt": "WRITE: PALAVRA",`,
`  "image": "/${level}/${unit}/dataX/imagens/imagemN.png",`,
`  "options": ["L", "E", "T", "R", "A"],`,
`  "answer": ["L", "E", "T", "R", "A"],`,
`  "promptAudio": "/${level}/${unit}/QAY/prompt1.mp3"`,
`}`,
``,
``,
`üìå promptAudio aqui l√™ o enunciado, n√£o a resposta.`,
``,
`üîπ B) MCQ ‚Äî LISTEN. CHOOSE. (spelling auditivo)`,
``,
`Crian√ßa escuta a palavra`,
``,
`Escolhe a grafia correta`,
``,
`Op√ß√µes s√£o PALAVRAS escritas`,
``,
`Cada op√ß√£o TEM √°udio pr√≥prio`,
``,
`O bot√£o üîä N√ÉO l√™ o enunciado, l√™ a resposta correta`,
`(exemplo)`,
`Estrutura:`,
`{`,
`      "type": "audio_mcq",`,
`      "prompt": "Listen. Choose.",`,
`      "promptAudio": "/${level}/${unit}/QA2/prompt7.mp3",`,
`      "answer": "abraham",`,
`      "answerAudio": "/${level}/${unit}/data1/sounds/som1.mp3",`,
`      "optionAudios": {`,
`        "abraham": "/${level}/${unit}/data1/sounds/som1.mp3",`,
`        "sarah": "/${level}/${unit}/data1/sounds/som2.mp3",`,
`        "father": "/${level}/${unit}/data1/sounds/som3.mp3"`,
`      },`,
`      "options": [`,
`        {`,
`          "label": "ABRAHAM",`,
`          "value": "abraham",`,
`          "image": "/${level}/${unit}/data1/imagens/imagem1.png",`,
`          "audio": "/${level}/${unit}/data1/sounds/som1.mp3"`,
`        },`,
`        {`,
`          "label": "SARAH",`,
`          "value": "sarah",`,
`          "image": "/${level}/${unit}/data1/imagens/imagem2.png",`,
`          "audio": "/${level}/${unit}/data1/sounds/som2.mp3"`,
`        },`,
`        {`,
`          "label": "FATHER",`,
`          "value": "father",`,
`          "image": "/${level}/${unit}/data1/imagens/imagem3.png",`,
`          "audio": "/${level}/${unit}/data1/sounds/som3.mp3"`,
`        }`,
`      ]`,
`    },`,
``,
``,
`‚ùå N√ÉO usar tts`,
`‚ùå N√ÉO usar prompt gen√©rico para √°udio`,
``,
`üîπ C) FILL IN THE BLANK (letra faltando) ‚Äî N√öCLEO DA ATIVIDADE`,
``,
`Alternativas s√£o LETRAS`,
``,
`A palavra aparece com {blank}`,
``,
`Foco m√°ximo em ortografia`,
``,
`‚úÖ Regra adicional (fixa√ß√£o do enunciado):`,
`O prompt deve ser exatamente:`,
`WRITE: {WORD_WITH_BLANK}.`,
`onde {WORD_WITH_BLANK} cont√©m {blank} inserido em UMA posi√ß√£o adequada (ex.: W{blank}RD)`,
`e deve usar a palavra real do item.`,
``,
`Estrutura (exemplo):`,
`{`,
`  "type": "fillblank",`,
`  "prompt": "WRITE: W{blank}RD.",`,
`  "image": "/${level}/${unit}/dataX/imagens/imagemN.png",`,
`  "options": [`,
`    { "label": "O", "value": "o" },`,
`    { "label": "A", "value": "a" },`,
`    { "label": "E", "value": "e" }`,
`  ],`,
`  "answer": "o",`,
`  "promptAudio": "/${level}/${unit}/QAY/prompt3.mp3"`,
`}`,
``,
``,
`üìå promptAudio aqui l√™ o enunciado, n√£o a resposta.`,
``,
`IMPORTANTE: TIPOS OFICIAIS DE QUEST√ïES (VOCABUL√ÅRIO FECHADO)`,
``,
`‚ö†Ô∏è APENAS estes 8 valores s√£o permitidos no campo type:`,
``,
`mcq`,
`yesno`,
`truefalse`,
`image_mcq`,
`audio_mcq`,
`fillblank`,
`order`,
`match`,
``,
``,
`‚ùå N√£o inventar novos tipos`,
`‚ùå N√£o usar nomes alternativos`,
``,
``,
`4Ô∏è‚É£ ESTRUTURA FIXA ‚Äî 10 QUEST√ïES POR GRUPO`,
``,
`Para cada grupo, voc√™ deve gerar EXATAMENTE 10 quest√µes, nesta l√≥gica pedag√≥gica:`,
``,
`1Ô∏è‚É£‚Äì2Ô∏è‚É£ ‚Üí ORDER`,
`3Ô∏è‚É£‚Äì5Ô∏è‚É£ ‚Üí FILL IN THE BLANK (letra)`,
`6Ô∏è‚É£‚Äì7Ô∏è‚É£ ‚Üí LISTEN. CHOOSE.`,
`8Ô∏è‚É£‚Äì10Ô∏è‚É£ ‚Üí FILL IN THE BLANK (letra)`,
``,
`‚úîÔ∏è Palavras podem se repetir`,
`‚úîÔ∏è Tipos podem se repetir`,
`‚ùå Nunca misturar grupos`,
``,
`5Ô∏è‚É£ PROMPTS DE √ÅUDIO (promptAudio) ‚Äî REGRA FINAL`,
``,
`üîä Para TODOS OS TIPOS DE QUEST√ïES`,
``,
`promptAudio = enunciado da quest√£o`,
``,
`Caminho:`,
``,
`/${level}/Unitx/QAY/prompt1.mp3`,
`/${level}/Unitx/QAY/prompt2.mp3`,
`...`,
``,
`6) ARQUIVOS .TXT COM LISTA DE PROMPTS (OBRIGAT√ìRIO)`,
``,
`Depois de gerar os JSONs, gere tamb√©m um arquivo .txt por grupo:`,
``,
`BlockA_prompts.txt`,
``,
`BlockB_prompts.txt`,
``,
`BlockC_prompts.txt (se houver grupo C)`,
``,
`Cada enunciado deve estar em uma linha.`,
``,
`‚ö†Ô∏è FORMATO OBRIGAT√ìRIO DO TXT:`,
``,
`- Apenas texto simples (plain text)`,
`- Uma linha por prompt`,
`- Sem colchetes []`,
`- Sem v√≠rgulas`,
`- Sem aspas`,
`- Sem JSON`,
`- Sem "file"`,
`- Sem "lines"`,
`- Sem qualquer estrutura`,
``,
`O conte√∫do deve ser TEXTO LIMPO, CRU e DIRETO.`,
``,
`Exemplo de formato correto:`,
``,
`WRITE: GOD`,
`WRITE: WORLD`,
`WRITE: GOD.`,
`WRITE: WORLD.`,
`WRITE: LIGHT.`,
`Listen. Choose.`,
`Listen. Choose.`,
`WRITE: SKY.`,
`WRITE: WATER.`,
`WRITE: LAND.`,
``,
`‚úÖ Regra adicional (fixa√ß√£o dos enunciados nos arquivos .txt):`,
``,
`- Para ORDER:`,
`  A linha deve ser exatamente:`,
`  WRITE: {WORD}`,
`  (usar a palavra real completa)`,
``,
`- Para FILLBLANK:`,
`  A linha deve ser exatamente:`,
`  WRITE: {WORD_WITH_BLANK}.`,
`  Por√©m, no arquivo TXT, N√ÉO deve aparecer {blank}.`,
`  Deve ser usada a palavra completa.`,
``,
`  Exemplo:`,
`  JSON ‚Üí WRITE: W{blank}RD.`,
`  TXT ‚Üí WRITE: WORD.`,
``,
`- Para LISTEN. CHOOSE.:`,
`  A linha deve ser exatamente:`,
`  Listen. Choose.`,
``,
`7) SA√çDA ESPERADA`,
``,
`- Para as quest√µes: retornar APENAS JSON`,
`- Para os prompts: retornar APENAS TEXTO (TXT)`,
``,
`- Um bloco JSON separado por grupo`,
`- Um bloco TXT separado por grupo`,
``,
`‚ö†Ô∏è IMPORTANTE:`,
``,
`- N√£o misturar JSON com TXT`,
`- N√£o colocar JSON dentro do TXT`,
`- N√£o adicionar explica√ß√µes`,
`- N√£o adicionar coment√°rios`,
`- N√£o adicionar t√≠tulos`,
`- N√£o adicionar texto extra fora dos blocos`,

`üéØ OBJETIVO FINAL`,
``,
`Gerar atividades que:`,
``,
`‚úîÔ∏è funcionem imediatamente no app`,
`‚úîÔ∏è treinem escrita de forma progressiva`,
`‚úîÔ∏è respeitem rigorosamente paths e assets`,
`‚úîÔ∏è n√£o precisem de corre√ß√µes posteriores`,
``,
`10) DADOS PARA EXECU√á√ÉO`,
``,
`N√≠vel CEFR (Aluno): ${cefr}`,
``,
`Level / Unit: ${level} / ${unit}`,
``,
`QA A: ${qaA}`,
`QA B: ${qaB}`,
`QA C: ${qaC}`,
``,
`Agora eu vou colar os grupos de palavras (A, B e possivelmente C) abaixo.`,
``,
`Grupo A:`,
`${groupA.join("\n")}`,
``,
`Grupo B:`,
`${groupB.length ? groupB.join("\n") : ""}`,
``,
`Grupo C:`,
`${groupC.length ? groupC.join("\n") : ""}`
      ].join("\n");
    }

    // ========= Loaders =========
    async function loadAll(){
      const baseUrl = normalizeBaseUrl($("baseUrl").value);
      const level = normalizePathSegment($("level").value);
      const unit  = normalizePathSegment($("unit").value);

      const urlA = joinUrl(baseUrl, `/${level}/${unit}/data1/words.txt`);
      const urlB = joinUrl(baseUrl, `/${level}/${unit}/data2/words.txt`);
      const urlC = joinUrl(baseUrl, `/${level}/${unit}/data3/words.txt`);

      setStatus("warn", "Carregando...");
      $("btnLoadAll").disabled = true;

      try{
        const aTxt = await fetchText(urlA);
        $("groupA").value = wordsToTextarea(parseWords(aTxt));

        try{
          const bTxt = await fetchText(urlB);
          $("groupB").value = wordsToTextarea(parseWords(bTxt));
        }catch(_e){
          $("groupB").value = "";
        }

        try{
          const cTxt = await fetchText(urlC);
          $("groupC").value = wordsToTextarea(parseWords(cTxt));
        }catch(_e){
          $("groupC").value = "";
        }

        setStatus("ok", "Carregado com sucesso");
      }catch(e){
        console.error(e);
        setStatus("err", "Erro ao carregar (ver console)");
        alert("Falha ao carregar do Netlify.\n\nDetalhe: " + (e && e.message ? e.message : String(e)));
      }finally{
        $("btnLoadAll").disabled = false;
      }
    }

    function generatePrompt(){
      const cefr  = $("cefr").value;
      const level = normalizePathSegment($("level").value);
      const unit  = normalizePathSegment($("unit").value);

      const qaA = normalizePathSegment($("qaA").value);
      const qaB = normalizePathSegment($("qaB").value);
      const qaC = normalizePathSegment($("qaC").value);

      const groupA = parseWords($("groupA").value || "");
      const groupB = parseWords($("groupB").value || "");
      const groupC = parseWords($("groupC").value || "");

      const prompt = buildFullPrompt({ cefr, level, unit, qaA, qaB, qaC, groupA, groupB, groupC });
      $("outPrompt").value = prompt;
      $("copyHint").textContent = "";
      updateCount();
    }

    // ========= Events =========
    $("btnLoadAll").addEventListener("click", loadAll);
    $("btnGenerate").addEventListener("click", generatePrompt);

    $("btnCopy").addEventListener("click", async () => {
      const text = $("outPrompt").value || "";
      if (!text.trim()) return;
      const ok = await copyToClipboard(text);
      $("copyHint").textContent = ok ? "‚úÖ Copiado." : "‚ö†Ô∏è N√£o foi poss√≠vel copiar automaticamente. Selecione o texto e copie manualmente.";
    });

    $("outPrompt").addEventListener("input", updateCount);
    updateCount();
  </script>
</body>
</html>