<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Gerador de Prompt ‚Äî Di√°logo (Robot Samuel & Hannah)</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; margin:16px; line-height:1.35}
    label{font-weight:600}
    textarea, select, input{width:100%; max-width:1100px; padding:10px; margin-top:6px; border:1px solid #cfd6df; border-radius:10px}
    textarea{min-height:110px}
    .row{display:grid; grid-template-columns:1fr 1fr 1fr; gap:12px; max-width:1100px}
    .row2{display:grid; grid-template-columns:1fr 1fr; gap:12px; max-width:1100px}
    .btn{padding:12px 14px; border:0; border-radius:12px; background:#2563eb; color:#fff; font-weight:700; cursor:pointer}
    .btn:disabled{opacity:.6; cursor:not-allowed}
    .card{max-width:1100px; border:1px solid #e5e7eb; border-radius:14px; padding:12px; margin:14px 0}
    .muted{color:#6b7280; font-size:14px}
    .status{white-space:pre-wrap; font-size:13px; background:#f7f9fc; border:1px dashed #cfd6df; border-radius:12px; padding:10px; max-width:1100px}
    .small{font-size:13px}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
  </style>
</head>
<body>

  <h2>Gerador de Prompt ‚Äî Di√°logo</h2>
  <div class="muted">
    Este gerador busca automaticamente o vocabul√°rio (<code>words.txt</code>) da <b>Unit atual</b> + <b>2 Units anteriores</b> (com ‚Äúwrap‚Äù entre Levels, considerando 20 Units por Level).
    Tamb√©m busca a gram√°tica de <code>/grammar/grammar.json</code> (na Base URL).
    <br><br>
    <b>Nova regra principal:</b> a <b>LI√á√ÉO</b> manda no di√°logo (estrutura e frases-alvo). O vocabul√°rio puxado √© apenas um <b>banco de palavras j√° estudadas</b> (apoio/limite), e pode ser ignorado quando n√£o fizer sentido para o tema.
  </div>

  <div class="card">
    <label for="baseUrl">Base URL (onde est√£o os arquivos do curso):</label>
    <input id="baseUrl" value="https://hannahenglishcourse.netlify.app" />
    <div class="muted small">
      Se voc√™ estiver rodando este HTML localmente, este campo precisa apontar para o seu Netlify.
      Ex.: <span class="mono">https://hannahenglishcourse.netlify.app</span>
    </div>

    <hr style="border:none;border-top:1px solid #e5e7eb;margin:12px 0"/>

    <label for="temaInput">Li√ß√£o de Conversa√ß√£o (FONTE PRIM√ÅRIA ‚Äî OBRIGAT√ìRIA):</label>
    <textarea id="temaInput">Cole aqui a li√ß√£o completa (objetivo, key phrases e exemplos). O di√°logo deve ensinar e praticar esta li√ß√£o.</textarea>

    <div class="row" style="margin-top:12px">
      <div>
        <label for="englishLevel">N√≠vel (CEFR):</label>
        <select id="englishLevel">
          <option value="Starter">Starter (antes do A1)</option>
          <option value="A1">A1 - Iniciante</option>
          <option value="A2">A2 - B√°sico</option>
          <option value="B1">B1 - Intermedi√°rio</option>
          <option value="B2">B2 - Intermedi√°rio Superior</option>
          <option value="C1">C1 - Avan√ßado</option>
          <option value="C2">C2 - Profici√™ncia</option>
        </select>
      </div>
      <div>
        <label for="levelNumber">Level atual (n√∫mero):</label>
        <input id="levelNumber" type="number" min="0" step="1" value="0"/>
        <div class="muted small">Ex.: 0, 1, 2, 3, 4</div>
      </div>
      <div>
        <label for="unitNumber">Unit atual (n√∫mero):</label>
        <input id="unitNumber" type="number" min="1" step="1" value="3"/>
        <div class="muted small">Ex.: 1 at√© 20</div>
      </div>
    </div>

    <div class="row2" style="margin-top:12px">
      <div>
        <label for="unitsPerLevel">Units por Level (padr√£o 20):</label>
        <input id="unitsPerLevel" type="number" min="1" step="1" value="20"/>
      </div>
      <div>
        <label for="maxWords">M√°ximo de palavras ‚Äúextras‚Äù no prompt (padr√£o 90):</label>
        <input id="maxWords" type="number" min="10" step="1" value="90"/>
        <div class="muted small">
          Essas palavras s√£o <b>apoio/limite</b>, n√£o o foco.
          Prioridade: Unit atual ‚Üí Unit-1 ‚Üí Unit-2
        </div>
      </div>
    </div>

    <div style="margin-top:12px">
      <label for="textoInspirador">Texto inspirador (opcional ‚Äî apoio leve):</label>
      <textarea id="textoInspirador" placeholder="Opcional. Se voc√™ preencher, o texto entra como apoio (vocabul√°rio/express√µes). N√ÉO copiar frases completas."></textarea>
      <div class="muted small">
        Observa√ß√£o: o vocabul√°rio principal vem da li√ß√£o. As listas de words.txt e este texto s√£o apoios.
      </div>
    </div>

    <div style="margin-top:12px">
      <button id="btnGerar" class="btn" onclick="gerarPrompt()">Gerar Prompt (li√ß√£o manda + apoios)</button>
    </div>

    <div style="margin-top:12px">
      <div class="status" id="statusBox">Status: pronto.</div>
    </div>

    <div style="margin-top:12px">
      <label for="debugBox">Debug (URLs tentadas e status):</label>
      <textarea id="debugBox" class="mono" style="min-height:160px" spellcheck="false"></textarea>
      <div class="muted small">
        Se aparecer 404 aqui, o caminho n√£o existe no Netlify. Se aparecer ‚ÄúFailed to fetch‚Äù, √© Base URL errada, CORS, rede ou execu√ß√£o fora do dom√≠nio sem headers.
      </div>
    </div>
  </div>

  <div class="card">
    <label for="promptOutput">Prompt Gerado:</label>
    <textarea id="promptOutput" style="min-height:320px" spellcheck="false"></textarea>
    <div class="muted small">Copie e cole na IA para gerar o <code>dialogo.txt</code>.</div>
  </div>

<script>
/** ======= UI helpers ======= */
function setStatus(msg) {
  document.getElementById("statusBox").textContent = msg;
}
function debugLog(line) {
  const box = document.getElementById("debugBox");
  box.value = (box.value ? box.value + "\n" : "") + line;
}
function clearDebug() {
  document.getElementById("debugBox").value = "";
}
function clampInt(n, min, max) {
  n = Number(n);
  if (!Number.isFinite(n)) return min;
  n = Math.floor(n);
  if (n < min) return min;
  if (typeof max === "number" && n > max) return max;
  return n;
}
function unitKey(unitNumber) {
  return "Unit" + unitNumber;
}
function levelKey(levelNumber) {
  return "Level" + levelNumber;
}
function normalizeBaseUrl(raw) {
  const s = (raw || "").trim();
  if (!s) return "";
  return s.replace(/\/+$/, "");
}
function buildUrl(baseUrl, path) {
  baseUrl = normalizeBaseUrl(baseUrl);
  if (!path.startsWith("/")) path = "/" + path;
  return baseUrl + path;
}

/** ======= Linear index helpers ======= */
function toLinearIndex(levelNum, unitNum, unitsPerLevel) {
  return (levelNum * unitsPerLevel) + unitNum; // unitNum come√ßa em 1
}
function fromLinearIndex(idx, unitsPerLevel) {
  const zeroBased = idx - 1;
  const levelNum = Math.floor(zeroBased / unitsPerLevel);
  const unitNum = (zeroBased % unitsPerLevel) + 1;
  return { levelNum, unitNum };
}

/** ======= Fetch helpers ======= */
async function fetchTextSafeAbs(url) {
  try {
    const res = await fetch(url, { cache: "no-store" });
    debugLog(`${res.status} ${url}`);
    if (!res.ok) return null;
    return await res.text();
  } catch (e) {
    debugLog(`ERR  ${url}  -> ${e && e.message ? e.message : String(e)}`);
    return null;
  }
}
async function fetchJsonSafeAbs(url) {
  try {
    const res = await fetch(url, { cache: "no-store" });
    debugLog(`${res.status} ${url}`);
    if (!res.ok) return null;
    return await res.json();
  } catch (e) {
    debugLog(`ERR  ${url}  -> ${e && e.message ? e.message : String(e)}`);
    return null;
  }
}

/**
 * words.txt no seu projeto pode estar:
 * - uma palavra por linha
 * - OU v√°rias palavras na mesma linha separadas por espa√ßos
 * Aqui tratamos ambos:
 */
function parseWordsTxt(txt) {
  const lines = txt.split(/\r?\n/g).map(s => (s || "").trim()).filter(Boolean);
  const words = [];
  for (const line of lines) {
    // divide por espa√ßos/tabs m√∫ltiplos, preservando express√µes com espa√ßo?
    // Como voc√™ tem itens como "STAND UP", este parser N√ÉO deve quebrar por espa√ßo se essa express√£o estiver em uma linha sozinha.
    // Ent√£o: se a linha tiver 1 palavra -> ok; se tiver v√°rias palavras e for "lista" -> quebra.
    // Heur√≠stica: se a linha tiver mais de 3 tokens, provavelmente √© lista; se 2 tokens pode ser express√£o (STAND UP).
    const tokens = line.split(/\s+/).filter(Boolean);
    if (tokens.length >= 4) {
      words.push(...tokens);
    } else {
      words.push(line);
    }
  }
  return words.map(w => w.trim()).filter(Boolean);
}

/** ======= Vocabulary fetch (tries data1/data2/data3 + case variants) ======= */
async function fetchWordsForUnit(baseUrl, levelNum, unitNum) {
  const base = `/${levelKey(levelNum)}/${unitKey(unitNum)}`;
  const dataFolders = ["data1","data2","data3","Data1","Data2","Data3"];

  const all = [];
  for (const df of dataFolders) {
    const url = buildUrl(baseUrl, `${base}/${df}/words.txt`);
    const txt = await fetchTextSafeAbs(url);
    if (txt) all.push(...parseWordsTxt(txt));
  }
  return Array.from(new Set(all));
}

/** ======= Grammar fetch ======= */
async function fetchGrammarJSON(baseUrl) {
  const url = buildUrl(baseUrl, "/grammar/grammar.json");
  return await fetchJsonSafeAbs(url);
}
function getGrammarForUnit(grammarData, levelNum, unitNum) {
  if (!grammarData) return [];
  const L = grammarData[levelKey(levelNum)];
  if (!L) return [];
  const U = L[unitKey(unitNum)];
  if (!Array.isArray(U)) return [];
  return U.map(s => (s || "").trim()).filter(Boolean);
}

/** ======= Prompt building ======= */
function buildLevelRules(englishLevel) {
  const rules = {
    Starter: [
      "P√∫blico: crian√ßas pequenas (primeiro contato com ingl√™s).",
      "Linguagem MUITO simples, concreta e repetitiva.",
      "Frases curtas (prefer√™ncia: 2‚Äì6 palavras; m√°ximo: 8).",
      "Evitar: passado, futuro, continuous, phrasal verbs, idioms, g√≠rias.",
      "Repetir estruturas importantes 2‚Äì3 vezes com pequenas varia√ß√µes.",
      "Se houver frase-alvo na li√ß√£o (ex.: ‚ÄúHow old are you?‚Äù), usar v√°rias vezes.",
      "Simplificar qualquer frase complexa que apare√ßa no texto inspirador (se fornecido)."
    ],
    A1: [
      "Frases simples e diretas. Vocabul√°rio b√°sico.",
      "Perguntas/respostas curtas com pequenas varia√ß√µes.",
      "Evitar explica√ß√µes longas."
    ],
    A2: [
      "Frases curtas a m√©dias. Mais varia√ß√µes de perguntas.",
      "Pode usar conectores simples (and, but, because) com modera√ß√£o."
    ],
    B1: [
      "Di√°logo mais natural, com pequenos detalhes e justificativas simples.",
      "Pode incluir opini√µes curtas."
    ],
    B2: [
      "Mais flu√™ncia. Vocabul√°rio mais amplo, mas sempre ligado ao tema.",
      "Pode incluir reformula√ß√µes e nuances."
    ],
    C1: [
      "Di√°logo sofisticado, vocabul√°rio avan√ßado e natural.",
      "Pode incluir explica√ß√µes e precis√£o lingu√≠stica."
    ],
    C2: [
      "M√°xima naturalidade e precis√£o. Registro apropriado ao contexto.",
      "Pode incluir sutilezas/idioms apenas se fizer sentido no contexto."
    ]
  };
  return (rules[englishLevel] || rules.Starter).map(x => `- ${x}`).join("\n");
}

function formatList(title, items) {
  if (!items || !items.length) return `${title}\n- (nenhum)\n`;
  return `${title}\n${items.map(x => `- ${x}`).join("\n")}\n`;
}
function mergeDedup(arr) {
  return Array.from(new Set((arr || []).map(s => (s || "").trim()).filter(Boolean)));
}

function selectWordsWithPriority(currentWords, prev1Words, prev2Words, maxWords) {
  const result = [];
  const seen = new Set();
  function pushFrom(list) {
    for (const w of list) {
      const key = (w || "").trim();
      if (!key) continue;
      if (seen.has(key)) continue;
      seen.add(key);
      result.push(key);
      if (result.length >= maxWords) return false;
    }
    return true;
  }
  pushFrom(currentWords);
  if (result.length < maxWords) pushFrom(prev1Words);
  if (result.length < maxWords) pushFrom(prev2Words);
  return result;
}

/** ======= Main ======= */
async function gerarPrompt() {
  const btn = document.getElementById("btnGerar");
  btn.disabled = true;
  clearDebug();

  try {
    const baseUrl = normalizeBaseUrl(document.getElementById("baseUrl").value);
    const lesson = document.getElementById("temaInput").value.trim();
    const textoInspirador = document.getElementById("textoInspirador").value.trim();
    const englishLevel = document.getElementById("englishLevel").value;

    const unitsPerLevel = clampInt(document.getElementById("unitsPerLevel").value, 1, 200);
    const maxWords = clampInt(document.getElementById("maxWords").value, 10, 200);

    const levelNum = clampInt(document.getElementById("levelNumber").value, 0, 999);
    const unitNum = clampInt(document.getElementById("unitNumber").value, 1, unitsPerLevel);

    if (!baseUrl) {
      setStatus("Status: erro ‚Äî Base URL est√° vazia.");
      btn.disabled = false;
      return;
    }
    if (!lesson) {
      setStatus("Status: erro ‚Äî a Li√ß√£o (fonte prim√°ria) est√° vazia.");
      btn.disabled = false;
      return;
    }

    setStatus("Status: buscando vocabul√°rio extra (words.txt) na Base URL...");
    const currentIdx = toLinearIndex(levelNum, unitNum, unitsPerLevel);
    const idxs = [currentIdx, currentIdx - 1, currentIdx - 2].filter(i => i >= 1);
    const targets = idxs.map(i => fromLinearIndex(i, unitsPerLevel));

    const wordsByTarget = [];
    for (const t of targets) {
      setStatus(`Status: vocabul√°rio extra ${levelKey(t.levelNum)} / ${unitKey(t.unitNum)}...`);
      const words = await fetchWordsForUnit(baseUrl, t.levelNum, t.unitNum);
      wordsByTarget.push(words);
    }

    const currentWords = wordsByTarget[0] || [];
    const prev1Words = wordsByTarget[1] || [];
    const prev2Words = wordsByTarget[2] || [];
    const extraWords = selectWordsWithPriority(currentWords, prev1Words, prev2Words, maxWords);

    setStatus("Status: buscando gram√°tica (grammar.json) na Base URL...");
    const grammarData = await fetchGrammarJSON(baseUrl);

    // Gram√°tica cumulativa: Unit atual + 2 anteriores (dedup)
    const grammarLists = targets.map(t => getGrammarForUnit(grammarData, t.levelNum, t.unitNum));
    const allowedGrammar = mergeDedup([].concat(...grammarLists));

    // Vocabul√°rio b√°sico de liga√ß√£o (sempre liberado)
    const basicWordsAllowed = [
      "I","YOU","HE","SHE","IT","WE","THEY",
      "MY","YOUR","HIS","HER","OUR","THEIR",
      "A","AN","THE",
      "AM","IS","ARE",
      "YES","NO",
      "WHAT","HOW","WHO","WHERE",
      "AND","OR","BUT",
      "PLEASE","THANK YOU",
      "OK","HELLO","HI","GOOD MORNING","GOODBYE"
    ];

    const inspirationBlock = textoInspirador
      ? `\nTEXTO INSPIRADOR (OPCIONAL ‚Äî APOIO LEVE)\n- Use apenas como fonte de algumas palavras/express√µes.\n- N√ÉO copiar frases completas.\n${textoInspirador}\n`
      : "";

    const levelRulesText = buildLevelRules(englishLevel);

    /**
     * ===== NOVAS REGRAS PRINCIPAIS (HIERARQUIA) =====
     * - A LI√á√ÉO MANDA: estruturas, frases-alvo, exemplos, objetivo.
     * - Vocabul√°rio extra (words.txt) √© s√≥ apoio/limite.
     * - Pode ignorar palavras irrelevantes.
     */
    const prompt = `
Voc√™ √© um gerador de di√°logos para ensino de ingl√™s. Crie um arquivo "dialogo.txt" contendo um di√°logo realista e did√°tico entre o Robot Samuel e a menina Hannah.

üî¥ HIERARQUIA OBRIGAT√ìRIA (N√ÉO CONFUNDIR)
1) A LI√á√ÉO abaixo √© a FONTE PRIM√ÅRIA e MANDA no di√°logo.
   - O di√°logo deve ensinar e praticar as frases-alvo, estruturas e exemplos da li√ß√£o.
   - O di√°logo deve permanecer focado no objetivo da li√ß√£o.
2) GRAM√ÅTICA PERMITIDA √© um LIMITE: pode usar as estruturas j√° estudadas (cumulativas).
3) VOCABUL√ÅRIO EXTRA (words.txt) √© APENAS APOIO/LIMITE:
   - Serve como banco de palavras que o aluno j√° conhece.
   - Use somente se fizer sentido para o tema da li√ß√£o.
   - N√ÉO tente usar todas as palavras.
   - Se houver palavras irrelevantes (ex.: comandos de sala) e o tema n√£o for esse, IGNORE.
4) BASIC WORDS ALLOWED sempre pode ser usado para ligar frases.
${inspirationBlock ? "5) TEXTO INSPIRADOR (se fornecido) √© APOIO LEVE, nunca o foco.\n" : ""}

N√çVEL DE INGL√äS (CEFR)
- N√≠vel escolhido: ${englishLevel}

REGRAS DO N√çVEL (OBRIGAT√ìRIAS)
${levelRulesText}

CONTROLE DE GRAM√ÅTICA (OBRIGAT√ìRIO)
- Use apenas as estruturas listadas em GRAM√ÅTICA PERMITIDA.
- N√ÉO use tempos verbais/estruturas n√£o ensinados (past, future, continuous, etc.).
- Se houver d√∫vida, escolha a forma mais simples.

CONTROLE DE VOCABUL√ÅRIO (OBRIGAT√ìRIO)
- Prioridade m√°xima: usar as palavras e frases que aparecem na LI√á√ÉO.
- Pode usar BASIC WORDS ALLOWED para naturalidade.
- VOCABUL√ÅRIO EXTRA: use apenas quando precisar de palavras adicionais e apenas se forem relevantes ao tema.
- N√ÉO invente vocabul√°rio avan√ßado fora do n√≠vel.

ELEMENTOS DID√ÅTICOS (OBRIGAT√ìRIOS)
- Repeti√ß√£o inteligente: repetir as frases-alvo da li√ß√£o 2‚Äì3 vezes com pequenas varia√ß√µes.
- Perguntas curtas e respostas curtas (guiadas).
- Reformula√ß√£o simples (dizer a mesma ideia de forma mais f√°cil).
- Foco total no objetivo da li√ß√£o.

FORMATO DO ARQUIVO "dialogo.txt" (OBRIGAT√ìRIO)
- Apenas falas (uma fala por linha).
- Sem t√≠tulos, sem explica√ß√µes, sem coment√°rios, sem listas.
- Sem marca√ß√µes extras.
- Robot Samuel e Hannah devem alternar as falas.
- Tamanho sugerido:
  - Starter/A1: 10 a 16 linhas
  - A2/B1: 12 a 22 linhas
  - B2/C1/C2: 14 a 26 linhas

${formatList("GRAM√ÅTICA PERMITIDA (CUMULATIVA):", allowedGrammar).trim()}

${formatList("VOCABUL√ÅRIO EXTRA (APOIO/LIMITE ‚Äî USE S√ì SE FOR RELEVANTE):", extraWords).trim()}

${formatList("BASIC WORDS ALLOWED (VOCABUL√ÅRIO B√ÅSICO DE LIGA√á√ÉO):", basicWordsAllowed).trim()}

${inspirationBlock ? inspirationBlock.trim() + "\n" : ""}

--- LI√á√ÉO (FONTE PRIM√ÅRIA ‚Äî O DI√ÅLOGO DEVE ENSINAR ISTO) ---
${lesson}
--- FIM DA LI√á√ÉO ---

Agora, gere APENAS o conte√∫do final do arquivo "dialogo.txt", seguindo todas as regras acima.
`.trim();

    document.getElementById("promptOutput").value = prompt;

    const info = [
      "Status: pronto.",
      `Base URL: ${baseUrl}`,
      `N√≠vel atual: ${levelKey(levelNum)} / ${unitKey(unitNum)} (unitsPerLevel=${unitsPerLevel})`,
      `Units usadas (wrap): ${targets.map(t => `${levelKey(t.levelNum)}/${unitKey(t.unitNum)}`).join(" , ")}`,
      `Vocabul√°rio EXTRA: current=${currentWords.length}, prev1=${prev1Words.length}, prev2=${prev2Words.length} => usados=${extraWords.length} (max=${maxWords})`,
      `Gram√°tica (cumulativa): itens=${allowedGrammar.length}`,
      grammarData ? "grammar.json: carregado." : "grammar.json: N√ÉO carregado (verifique /grammar/grammar.json)."
    ].join("\n");

    setStatus(info);

  } catch (err) {
    setStatus("Status: erro inesperado.\n" + (err && err.message ? err.message : String(err)));
  } finally {
    btn.disabled = false;
  }
}
</script>

</body>
</html>
